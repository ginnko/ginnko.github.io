---
layout: post
title: react源码学习之首次渲染调度更新的过程
date: 2020-07-15
tag: 
- react
- 源码
---


之前知道了首次渲染创建更新的过程，现在进入调度更新的过程（下图中的右侧部分，从scheduleUpdateOnFiber开始进入调度阶段）。

<!-- more -->


```mermaid
graph TD;

  render --> legacyRenderSubtreeIntoContainer;
  legacyRenderSubtreeIntoContainer --> legacyCreateRootFromDOMContainer;
  legacyRenderSubtreeIntoContainer --> unbatchedUpdates;
  unbatchedUpdates --> updateContainer;
  updateContainer --> scheduleUpdateOnFiber;
  scheduleUpdateOnFiber --> checkForNestedUpdates;
  scheduleUpdateOnFiber --> markUpdateTimeFromFiberToRoot;
  markUpdateTimeFromFiberToRoot --> markRootUpdatedAtTime;
  scheduleUpdateOnFiber --> getCurrentPriorityLevel;
  scheduleUpdateOnFiber --> schedulePendingInteractions;
  schedulePendingInteractions --> scheduleInteractions;
  scheduleUpdateOnFiber --> performSyncWorkOnRoot;
  performSyncWorkOnRoot --> renderRootSync;
  renderRootSync --> pushDispatcher;
  renderRootSync --> prepareFreshStack;
  prepareFreshStack --> createWorkInProgress;
  renderRootSync --> startWorkOnPendingInteractions;
  startWorkOnPendingInteractions --> scheduleInteractions;
  renderRootSync --> pushInteractions;
  renderRootSync --> workLoopSync;
```

  <!-- beginWork  pushHostRootContext;
  pushHostRootContext  pushTopLevelContextObject;
  pushHostRootContext  pushHostContainer;
  pushHostContainer  getRootHostContext;
  getRootHostContext  getChildNamespace;
  pushHostContainer  pop;
  beginWork  bailoutOnAlreadyFinishedWork; -->





|  函数名     |   参数(类型)    |   位置    |
|  ---  |  ---  |  ---  |
|scheduleUpdateOnFiber|fiber(Fiber)、expirationTime(ExpirationTime)|react-reconciler/src/ReactFiberWorkLoop|
|checkForNestedUpdates|-|react-reconciler/src/ReactFiberWorkLoop|
|markUpdateTimeFromFiberToRoot|-|react-reconciler/src/ReactFiberWorkLoop|
|markRootUpdatedAtTime|fiber(Fiber)、expirationTime(ExpirationTime)|react-reconciler/src/ReactFiberRoot|
|getCurrentPriorityLevel|-|react-reconciler/src/SchedulerWithReactIntegration|
|schedulePendingInteractions|-|react-reconciler/src/SchedulerWithReactIntegration|
|scheduleInteractions|root, expirationTime, interactions|react-reconciler/src/ReactFiberWorkLoop|
|performSyncWorkOnRoot|root(FiberRoot)|react-reconciler/src/ReactFiberWorkLoop|
|renderRootSync|root(FiberRoot), expirationTime|react-reconciler/src/ReactFiberWorkLoop|
|pushDispatcher|root(FiberRoot), expirationTime|react-reconciler/src/ReactFiberWorkLoop|
|prepareFreshStack|root(FiberRoot), expirationTime|react-reconciler/src/ReactFiberWorkLoop|
|startWorkOnPendingInteractions|root(FiberRoot), expirationTime|react-reconciler/src/ReactFiberWorkLoop|
|startWorkOnPendingInteractions|root(FiberRoot), expirationTime, interactions|react-reconciler/src/ReactFiberWorkLoop|
|pushInteractions|root(FiberRoot)|react-reconciler/src/ReactFiberWorkLoop|
|workLoopSync|-|react-reconciler/src/ReactFiberWorkLoop|
|performUnitOfWork|workInProgress(Fiber)|react-reconciler/src/ReactFiberWorkLoop|
|createWorkInProgress|Fiber, pendingProps|react-reconciler/src/ReactFiber|
|pushHostRootContext|Fiber|react-reconciler/src/ReactFiberBeginWork|
|pushTopLevelContextObject|Fiber, context, didChange(boolean)|react-reconciler/src/ReactFiberContext|
|push|cursor(StackCursor<T>), value(T), fiber|react-reconciler/src/ReactFiberStack|
|pushHostContainer|fiber, dom|react-reconciler/src/ReactFiberHostContext|
|getRootHostContext|dom|react-dom/src/client/ReactDOMHostConfig|
|getChildNamespace|parentNamespace(string或null),type(string)|react-dom/src/shared/DOMNamespaces|
|pop|cursor(StackCursor<T>), value(T), fiber|react-reconciler/src/ReactFiberStack|
|beginWork|current(Fiber 或 null), workInProgress(Fiber), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactFiberBeginWork|
|bailoutOnAlreadyFinishedWork|current(Fiber 或 null), workInProgress(Fiber), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactFiberBeginWork|
|updateHostRoot|current(Fiber 或 null), workInProgress(Fiber), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactFiberBeginWork|
|cloneUpdateQueue|current(Fiber), workInProgress(Fiber)|react-reconciler/src/ReactUpdateQueue|
|processUpdateQueue|workInProgress(Fiber), props(any), instance(any), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactUpdateQueue|
|markRenderEventTimeAndConfig|expirationTime(ExpirationTime), suspenseConfig(null或SuspenseConfig)|react-reconciler/src/ReactFiberWorkLoop|
|getStateFromUpdate|workInProgress(Fiber), queue(UpdateQueue), update(Update), prevState(State), nextProps(any), instance(any)|react-reconciler/src/ReactUpdateQueue|
|reconcileChildren|current(Fiber 或 null), workInProgress(Fiber), nextChildren(any), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactFiberBeginWork|
|reconcileChildFibers|returnFiber(Fiber), currentFirstChild(Fiber或null), newChild(any), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactChildFiber|
|placeSingleChild|newFiber(Fiber)|react-reconciler/src/ReactChildFiber|
|reconcileSingleElement|returnFiber(Fiber), currentFirstChild(Fiber或null), element(ReactElement), expiration(Expiration)|react-reconciler/src/ReactChildFiber|
|createFiberFromElement|element(ReactElement), mode(TypeOfMode), expiration(Expiration)|react-reconciler/src/ReactFiber|
|createFiberFromTypeAndProps|type(ReactElementType), key(null或string), pendingProps(any), owner(null或Fiber), mode(TypeOfMode), expiration(Expiration)|react-reconciler/src/ReactFiber|
|coerceRef|returnFiber(Fiber), current(null或Fiber), element(ReactElement)|react-reconciler/src/ReactFiber|
|updateMode|current(null或Fiber), workInProgress(Fiber), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactFiber|
|mountChildFibers|returnFiber(Fiber), currentFirstChild(Fiber或null), newChild(any), renderExpirationTime(ExpirationTime)|react-reconciler/src/ReactChildFiber|
|placeSingleChild|newFiber(Fiber)|react-reconciler/src/ReactChildFiber|

---

### 主要函数

1. scheduleUpdateOnFiber

```js
  // export const NoContext = /*             */ 0b0000000;
  // const BatchedContext = /*               */ 0b0000001;
  // const EventContext = /*                 */ 0b0000010;
  // const DiscreteEventContext = /*         */ 0b0000100;
  // const LegacyUnbatchedContext = /*       */ 0b0001000;
  // const RenderContext = /*                */ 0b0010000;
  // const CommitContext = /*                */ 0b0100000;
  export function scheduleUpdateOnFiber(
    fiber: Fiber,
    expirationTime: ExpirationTime,
  ) {
    checkForNestedUpdates();
    // warnAboutRenderPhaseUpdatesInDEV(fiber); // 这个函数运行在测试环境
    // 首次渲染这个函数给FiberRoot的pendingTime设置了范围(firstPendingTime = MAX_SIGNED_31_BIT_INT, lastPendingTime = MAX_SIGNED_31_BIT_INT)
    const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
    if (root === null) {
      warnAboutUpdateOnUnmountedFiberInDEV(fiber);
      return;
    }

    // TODO: computeExpirationForFiber also reads the priority. Pass the
    // priority as an argument to that function and this one.
    const priorityLevel = getCurrentPriorityLevel(); // 首次渲染 NormalPriority = 3

    if (expirationTime === Sync) { // 首次渲染等于Sync
      // 首次渲染过程中，处理过executionContext的地方位于unbatchedUpdates中
      // 经过如下步骤：
      // const prevExecutionContext = executionContext;
      // executionContext &= ~BatchedContext;
      // executionContext |= LegacyUnbatchedContext;
      // 此时的executionContext中加入了LegacyUnbatchedContext，所以值为0b0001000，也就是8
      if (
        // Check if we're inside unbatchedUpdates
        (executionContext & LegacyUnbatchedContext) !== NoContext &&
        // Check if we're not already rendering
        (executionContext & (RenderContext | CommitContext)) === NoContext
      ) { // 首次渲染进入该分支
        // Register pending interactions on the root to avoid losing traced interaction data.
        schedulePendingInteractions(root, expirationTime);

        // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
        // root inside of batchedUpdates should be synchronous, but layout updates
        // should be deferred until the end of the batch.
        performSyncWorkOnRoot(root);
      } else {
        ensureRootIsScheduled(root);
        schedulePendingInteractions(root, expirationTime);
        if (executionContext === NoContext) {
          // Flush the synchronous work now, unless we're already working or inside
          // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
          // scheduleCallbackForFiber to preserve the ability to schedule a callback
          // without immediately flushing it. We only do this for user-initiated
          // updates, to preserve historical behavior of legacy mode.
          flushSyncCallbackQueue();
        }
      }
    } else {
      // Schedule a discrete update but only if it's not Sync.
      if (
        (executionContext & DiscreteEventContext) !== NoContext &&
        // Only updates at user-blocking priority or greater are considered
        // discrete, even inside a discrete event.
        (priorityLevel === UserBlockingPriority ||
          priorityLevel === ImmediatePriority)
      ) {
        // This is the result of a discrete event. Track the lowest priority
        // discrete update per root so we can flush them early, if needed.
        if (rootsWithPendingDiscreteUpdates === null) {
          rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
        } else {
          const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
          if (
            lastDiscreteTime === undefined ||
            lastDiscreteTime > expirationTime
          ) {
            rootsWithPendingDiscreteUpdates.set(root, expirationTime);
          }
        }
      }
      // Schedule other updates after in case the callback is sync.
      ensureRootIsScheduled(root);
      schedulePendingInteractions(root, expirationTime);
    }
  }
```

2. checkForNestedUpdates

```js
  const NESTED_UPDATE_LIMIT = 50;
  let nestedUpdateCount: number = 0;

  function checkForNestedUpdates() {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = null;
      invariant(
        false,
        'Maximum update depth exceeded. This can happen when a component ' +
          'repeatedly calls setState inside componentWillUpdate or ' +
          'componentDidUpdate. React limits the number of nested updates to ' +
          'prevent infinite loops.',
      );
    }
  }
```
3. markUpdateTimeFromFiberToRoot

传入该函数的fiber值：

```js
// ====================fiber============================
  {
    actualDuration: 0,
    actualStartTime: -1,
    alternate: null,
    child: null,
    childExpirationTime: NoWork, // 0
    dependencies_old: null,
    effectTag: NoEffect, // 0
    elementType: null,
    expirationTime: NoWork, // 0
    firstEffect: null,
    index: 0,
    key: null,
    lastEffect: null,
    memoizedProps: null,
    memoizedState: null,
    mode: NoMode, // 0
    nextEffect: null,
    pendingProps: null,
    ref: null,
    return: null,
    setBaseDuration: 0,
    sibling: null,
    stateNode: container,
    tag: HostRoot, // 3
    treeBaseDuration: 0,
    type: null,
    updateQueue: {
      baseState: null,
      effects: null,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
      },
    },
  }

  // ======================expirationTime==================

  MAX_SIGNED_31_BIT_INT, // 1073741823

  // ======================FiberRoot=======================

  {
    callbackNode: null,
    callbackPriority_old: Nopriority, // 90
    containerInfo: '<div id="root">', // dom元素()
    context: {},
    current,
    finishedExpirationTime: NoWork, // 0
    finishedWork: null,
    firstPendingTime: NoWork, // 0
    firstSuspendedTime: NoWork, // 0
    hydrate: false,
    interactionThreadID: 1,
    lastExpiredTime: NoWork, // 0
    lastPendingTime: NoWork, // 0
    lastPingedTime: NoWork, // 0
    lastSuspendedTime: NoWork, // 0
    memoizedInteractions: Set[],
    mutableSourceEagerHydrationData: null,
    mutableSourceLastPendingUpdateTime: NoWork, // 0
    nextKnownPendingLevel: NoWork, // 0
    pendingChildren: null,
    pendingContext: null,
    pendingInteractionMap_old: Map(0),
    pingCache: null,
    timeoutHandle: noTimeout, // -1
    tag: LegacyRoot, // 0
  }
```

```js
  let workInProgressRoot: FiberRoot | null = null;


  // This is split into a separate function so we can mark a fiber with pending
  // work without treating it as a typical update that originates from an event;
  // e.g. retrying a Suspense boundary isn't an update, but it does schedule work
  // on a fiber.
  function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
    // Update the source fiber's expiration time
    if (fiber.expirationTime < expirationTime) {
      fiber.expirationTime = expirationTime;
    }
    let alternate = fiber.alternate;
    if (alternate !== null && alternate.expirationTime < expirationTime) { // 首次渲染alternate是null，不会进入这个分支
      alternate.expirationTime = expirationTime;
    }

    // Walk the parent path to the root and update the child expiration time.
    let node = fiber.return; // 首次渲染，值为null
    let root = null;
    if (node === null && fiber.tag === HostRoot) { // 首次渲染进入该分支
      root = fiber.stateNode; // 首次渲染值为FiberRoot
    } else {
      while (node !== null) {
        alternate = node.alternate;
        if (node.childExpirationTime < expirationTime) {
          node.childExpirationTime = expirationTime;
          if (
            alternate !== null &&
            alternate.childExpirationTime < expirationTime
          ) {
            alternate.childExpirationTime = expirationTime;
          }
        } else if (
          alternate !== null &&
          alternate.childExpirationTime < expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
        if (node.return === null && node.tag === HostRoot) {
          root = node.stateNode;
          break;
        }
        node = node.return;
      }
    }

    if (root !== null) {
      if (workInProgressRoot === root) { // 首次渲染 workInProgressRoot === null，不进入该分支
        // Received an update to a tree that's in the middle of rendering. Mark
        // that's unprocessed work on this root.
        markUnprocessedUpdateTime(expirationTime);

        if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
          // The root already suspended with a delay, which means this render
          // definitely won't finish. Since we have a new update, let's mark it as
          // suspended now, right before marking the incoming update. This has the
          // effect of interrupting the current render and switching to the update.
          // TODO: This happens to work when receiving an update during the render
          // phase, because of the trick inside computeExpirationForFiber to
          // subtract 1 from `renderExpirationTime` to move it into a
          // separate bucket. But we should probably model it with an exception,
          // using the same mechanism we use to force hydration of a subtree.
          // TODO: This does not account for low pri updates that were already
          // scheduled before the root started rendering. Need to track the next
          // pending expiration time (perhaps by backtracking the return path) and
          // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.
          markRootSuspendedAtTime(root, renderExpirationTime);
        }
      }
      // Mark that the root has a pending update.
      markRootUpdatedAtTime(root, expirationTime);
    }

    return root;
  }
```
4. markRootUpdatedAtTime

首次渲染的时候上面的函数没有执行实质性的操作，该函数做的实质性操作是给FiberRoot的pending times设置了范围

```js
// Mark that the root has a pending update.

export function markRootUpdatedAtTime(
  root: FiberRoot,
  expirationTime: ExpirationTime,
): void {
  // Update the range of pending times
  const firstPendingTime = root.firstPendingTime; // 首次渲染 NoWork = 0
  if (expirationTime > firstPendingTime) {
    root.firstPendingTime = expirationTime; // 首次渲染 MAX_SIGNED_31_BIT_INT = 1073741823
  }
  const lastPendingTime = root.lastPendingTime; // 首次渲染 NoWork = 0
  if (lastPendingTime === NoWork || expirationTime < lastPendingTime) {
    root.lastPendingTime = expirationTime; // 首次渲染 MAX_SIGNED_31_BIT_INT = 1073741823
  }

  // Update the range of suspended times. Treat everything lower priority or
  // equal to this update as unsuspended.
  const firstSuspendedTime = root.firstSuspendedTime; // 首次渲染 NoWork = 0
  if (firstSuspendedTime !== NoWork) { // 首次渲染不会进入该分支
    if (expirationTime >= firstSuspendedTime) {
      // The entire suspended range is now unsuspended.
      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;
    } else if (expirationTime >= root.lastSuspendedTime) {
      root.lastSuspendedTime = expirationTime + 1;
    }

    // This is a pending level. Check if it's higher priority than the next
    // known pending level.
    if (expirationTime > root.nextKnownPendingLevel) {
      root.nextKnownPendingLevel = expirationTime;
    }
  }
}
```
5. getCurrentPriorityLevel

```js
  export const NoPriority = 0;
  export const ImmediatePriority = 1;
  export const UserBlockingPriority = 2;
  export const NormalPriority = 3;
  export const LowPriority = 4;
  export const IdlePriority = 5;

  var currentPriorityLevel = NormalPriority;
  // Scheduler_getCurrentPriorityLevel就是unstable_getCurrentPriorityLevel
  function unstable_getCurrentPriorityLevel() {
    return currentPriorityLevel;
  }

  // ImmediatePriority as unstable_ImmediatePriority,
  // UserBlockingPriority as unstable_UserBlockingPriority,
  // NormalPriority as unstable_NormalPriority,
  // IdlePriority as unstable_IdlePriority,
  // LowPriority as unstable_LowPriority,

  // unstable_ImmediatePriority: Scheduler_ImmediatePriority,
  // unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,
  // unstable_NormalPriority: Scheduler_NormalPriority,
  // unstable_LowPriority: Scheduler_LowPriority,
  // unstable_IdlePriority: Scheduler_IdlePriority,

  function getCurrentPriorityLevel(): ReactPriorityLevel {
    switch (Scheduler_getCurrentPriorityLevel()) {
      case Scheduler_ImmediatePriority:
        return ImmediatePriority;
      case Scheduler_UserBlockingPriority:
        return UserBlockingPriority;
      case Scheduler_NormalPriority:
        return NormalPriority;
      case Scheduler_LowPriority:
        return LowPriority;
      case Scheduler_IdlePriority:
        return IdlePriority;
      default:
        invariant(false, 'Unknown priority level.');
    }
  }
```
首次渲染返回的结果是NormalPriority

6. schedulePendingInteractions

```js
  function schedulePendingInteractions(root, expirationTime) {
    // This is called when work is scheduled on a root.
    // It associates the current interactions with the newly-scheduled expiration.
    // They will be restored when that expiration is later committed.
    if (!enableSchedulerTracing) { // enableSchedulerTracing = true
      return;
    }
    scheduleInteractions(root, expirationTime, __interactionsRef.current); // __interactionsRef.current = Set[]
  }
```

代码中的`__interactionsRef`初始值是null，但何时更改了新值完全没发现。。。最一开始调用`createElement`的时候就已经是此处看到的值了。。。

7. scheduleInteractions

首次渲染，不进入任何分支

```js
  function scheduleInteractions(root, expirationTime, interactions) {
    if (!enableSchedulerTracing) {
      return;
    }

    if (interactions.size > 0) {
      const pendingInteractionMap = root.pendingInteractionMap_old;
      const pendingInteractions = pendingInteractionMap.get(expirationTime);
      if (pendingInteractions != null) {
        interactions.forEach(interaction => {
          if (!pendingInteractions.has(interaction)) {
            // Update the pending async work count for previously unscheduled interaction.
            interaction.__count++;
          }

          pendingInteractions.add(interaction);
        });
      } else {
        pendingInteractionMap.set(expirationTime, new Set(interactions));

        // Update the pending async work count for the current interactions.
        interactions.forEach(interaction => {
          interaction.__count++;
        });
      }

      const subscriber = __subscriberRef.current;
      if (subscriber !== null) {
        const threadID = computeThreadID(root, expirationTime);
        subscriber.onWorkScheduled(interactions, threadID);
      }
    }
  }
```

8. performSyncWorkOnRoot

首次渲染走同步流程

```js
  // This is the entry point for synchronous tasks that don't go
  // through Scheduler
  function performSynliuchengcWorkOnRoot(root) {
    invariant(
      (executionContext & (RenderContext | CommitContext)) === NoContext,
      'Should not already be working.',
    );

    flushPassiveEffects(); // 首次渲染内部不会进入分支，直接跳出

    const lastExpiredTime = root.lastExpiredTime; // 首次渲染NoWork

    let expirationTime;
    if (lastExpiredTime !== NoWork) {
      // There's expired work on this root. Check if we have a partial tree
      // that we can reuse.
      if (
        root === workInProgressRoot &&
        renderExpirationTime >= lastExpiredTime
      ) {
        // There's a partial tree with equal or greater than priority than the
        // expired level. Finish rendering it before rendering the rest of the
        // expired work.
        expirationTime = renderExpirationTime;
      } else {
        // Start a fresh tree.
        expirationTime = lastExpiredTime;
      }
    } else {
      // There's no expired work. This must be a new, synchronous render.
      expirationTime = Sync; // 首次渲染 MAX_SIGNED_31_BIT_INT 1073741823
    }

    let exitStatus = renderRootSync(root, expirationTime);

    if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
      executionContext |= RetryAfterError;

      // If an error occurred during hydration,
      // discard server response and fall back to client side render.
      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      }

      // If something threw an error, try rendering one more time. We'll
      // render synchronously to block concurrent data mutations, and we'll
      // render at Idle (or lower) so that all pending updates are included.
      // If it still fails after the second attempt, we'll give up and commit
      // the resulting tree.
      expirationTime = expirationTime > Idle ? Idle : expirationTime;
      exitStatus = renderRootSync(root, expirationTime);
    }

    if (exitStatus === RootFatalErrored) {
      const fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, expirationTime);
      markRootSuspendedAtTime(root, expirationTime);
      ensureRootIsScheduled(root);
      throw fatalError;
    }

    // We now have a consistent tree. Because this is a sync render, we
    // will commit it even if something suspended.
    const finishedWork: Fiber = (root.current.alternate: any);
    root.finishedWork = finishedWork;
    root.finishedExpirationTime = expirationTime;
    root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
    commitRoot(root);

    // Before exiting, make sure there's a callback scheduled for the next
    // pending level.
    ensureRootIsScheduled(root);

    return null;
  }
```

9. renderRootSync

```js
  // 首次渲染过程中，处理过executionContext的地方位于unbatchedUpdates中
  // 经过如下步骤：
  // const prevExecutionContext = executionContext;
  // executionContext &= ~BatchedContext;
  // executionContext |= LegacyUnbatchedContext;
  // 此时的executionContext中加入了LegacyUnbatchedContext，所以值为0b0001000，也就是8

  // const RenderContext = 0b0010000;
  // let renderExpirationTime: ExpirationTime = NoWork;

  function renderRootSync(root, expirationTime) {
    const prevExecutionContext = executionContext; // LegacyUnbatchedContext = 0b0001000
    executionContext |= RenderContext; // RenderContext | LegacyUnbatchedContext = 0b0011000
    const prevDispatcher = pushDispatcher(root); // 首次渲染此处的返回值见下方
    
    // 每太明白下面的注释
    // If the root or expiration time have changed, throw out the existing stack
    // and prepare a fresh one. Otherwise we'll continue where we left off.
    if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) { // 首次渲染会进入该分支
      prepareFreshStack(root, expirationTime);
      startWorkOnPendingInteractions(root, expirationTime);
    }

    const prevInteractions = pushInteractions(root);

    do {
      try {
        workLoopSync();
        break;
      } catch (thrownValue) {
        handleError(root, thrownValue);
      }
    } while (true);
    resetContextDependencies();
    if (enableSchedulerTracing) {
      popInteractions(((prevInteractions: any): Set<Interaction>));
    }

    executionContext = prevExecutionContext;
    popDispatcher(prevDispatcher);

    if (workInProgress !== null) {
      // This is a sync render, so we should have finished the whole tree.
      invariant(
        false,
        'Cannot commit an incomplete root. This error is likely caused by a ' +
          'bug in React. Please file an issue.',
      );
    }

    // Set this to null to indicate there's no in-progress render.
    workInProgressRoot = null;

    return workInProgressRootExitStatus;
  }
```

10. pushDispatcher

```js
  /**
  * Keeps track of the current dispatcher.
  */
  const ReactCurrentDispatcher = {
    current: (null: null | Dispatcher),
  };

  const ContextOnlyDispatcher = {
    readContext,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useResponder: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useMutableSource: throwInvalidHookError,
    useOpaqueIdentifier: throwInvalidHookError,

    unstable_isNewReconciler: enableNewReconciler,
  };

  function pushDispatcher(root) {
    const prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = ContextOnlyDispatcher;
    if (prevDispatcher === null) {
      // The React isomorphic package does not include a default dispatcher.
      // Instead the first renderer will lazily attach one, in order to give
      // nicer error messages.
      return ContextOnlyDispatcher; // 这里返回ContextOnlyDispatcher（感觉像是和Hook相关的）
    } else {
      return prevDispatcher;
    }
  }
```

11. prepareFreshStack

```js
  // export const noTimeout = -1;

  // // The root we're working on
  // let workInProgressRoot: FiberRoot | null = null;

  // // The fiber we're working on
  // let workInProgress: Fiber | null = null;

  // const RootIncomplete = 0;
  // // Whether to root completed, errored, suspended, etc.
  // let workInProgressRootExitStatus: RootExitStatus = RootIncomplete;

  // // A fatal error, if one is thrown
  // let workInProgressRootFatalError: mixed = null;

  // // Most recent event time among processed updates during this render.
  // // This is conceptually a time stamp but expressed in terms of an ExpirationTime
  // // because we deal mostly with expiration times in the hot path, so this avoids
  // // the conversion happening in the hot path.
  // let workInProgressRootLatestProcessedExpirationTime: ExpirationTime = Sync;
  // let workInProgressRootLatestSuspenseTimeout: ExpirationTime = Sync;
  // let workInProgressRootCanSuspendUsingConfig: null | SuspenseConfig = null;

  // // The work left over by components that were visited during this render. Only
  // // includes unprocessed updates, not work in bailed out children.
  // let workInProgressRootNextUnprocessedUpdateTime: ExpirationTime = NoWork;

  // // If we're pinged while rendering we don't always restart immediately.
  // // This flag determines if it might be worthwhile to restart if an opportunity
  // // happens latere.
  // let workInProgressRootHasPendingPing: boolean = false;

  // // Marks the need to reschedule pending interactions at these expiration times
  // // during the commit phase. This enables them to be traced across components
  // // that spawn new work during render. E.g. hidden boundaries, suspended SSR
  // // hydration or SuspenseList.
  // let spawnedWorkDuringRender: null | Array<ExpirationTime> = null;

  function prepareFreshStack(root, expirationTime) {
    root.finishedWork = null;
    root.finishedExpirationTime = NoWork;

    const timeoutHandle = root.timeoutHandle; // 首次渲染时 -1
    if (timeoutHandle !== noTimeout) { // 首次渲染不进入该分支
      // The root previous suspended and scheduled a timeout to commit a fallback
      // state. Now that we have additional work, cancel the timeout.
      root.timeoutHandle = noTimeout;
      // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
      cancelTimeout(timeoutHandle);
    }

    // Check if there's a suspended level at lower priority.
    const lastSuspendedTime = root.lastSuspendedTime; // 0
    if (lastSuspendedTime !== NoWork && lastSuspendedTime < expirationTime) { // 首次渲染不进入该分支
      const lastPingedTime = root.lastPingedTime;
      // Make sure the suspended level is marked as pinged so that we return back
      // to it later, in case the render we're about to start gets aborted.
      // Generally we only reach this path via a ping, but we shouldn't assume
      // that will always be the case.
      // Note: This is defensive coding to prevent a pending commit from
      // being dropped without being rescheduled. It shouldn't be necessary.
      if (lastPingedTime === NoWork || lastPingedTime > lastSuspendedTime) {
        root.lastPingedTime = lastSuspendedTime;
      }
    }

    if (workInProgress !== null) { // 首次渲染不进入该分支
      let interruptedWork = workInProgress.return;
      while (interruptedWork !== null) {
        unwindInterruptedWork(interruptedWork);
        interruptedWork = interruptedWork.return;
      }
    }
    workInProgressRoot = root;
    workInProgress = createWorkInProgress(root.current, null);
    renderExpirationTime = expirationTime;
    workInProgressRootExitStatus = RootIncomplete;
    workInProgressRootFatalError = null;
    workInProgressRootLatestProcessedExpirationTime = Sync;
    workInProgressRootLatestSuspenseTimeout = Sync;
    workInProgressRootCanSuspendUsingConfig = null;
    workInProgressRootNextUnprocessedUpdateTime = NoWork;
    workInProgressRootHasPendingPing = false;

    if (enableSchedulerTracing) {
      spawnedWorkDuringRender = null;
    }
  }
```

12.  createWorkInProgress

首次渲染时的调用：`createWorkInProgress(root.current, null);`

```js
  // 此时的current
  {
    actualDuration: 0,
    actualStartTime: -1,
    alternate: null,
    child: null,
    childExpirationTime: NoWork, // 0
    dependencies_old: null,
    effectTag: NoEffect, // 0
    elementType: null,
    expirationTime: NoWork, // 0
    firstEffect: null,
    index: 0,
    key: null,
    lastEffect: null,
    memoizedProps: null,
    memoizedState: null,
    mode: NoMode, // 0
    nextEffect: null,
    pendingProps: null,
    ref: null,
    return: null,
    setBaseDuration: 0,
    sibling: null,
    stateNode: container,
    tag: HostRoot, // 3
    treeBaseDuration: 0,
    type: null,
    updateQueue: {
      baseState: null,
      effects: null,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
      },
    },
  }
  // This is used to create an alternate fiber to do work on.
  export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
    let workInProgress = current.alternate; // 首次渲染 null
    if (workInProgress === null) {
      // We use a double buffering pooling technique because we know that we'll
      // only ever need at most two versions of a tree. We pool the "other" unused
      // node that we're free to reuse. This is lazily created to avoid allocating
      // extra objects for things that are never updated. It also allow us to
      // reclaim the extra memory if needed.
      workInProgress = createFiber(
        current.tag,
        pendingProps,
        current.key,
        current.mode,
      );
      workInProgress.elementType = current.elementType;
      workInProgress.type = current.type;
      workInProgress.stateNode = current.stateNode;
      // 上面的操作相当于半深拷贝了一个root对应的Fiber为workInProgress
      // 然后通过Fiber的alternate属性将current和workInProgress两个Fiber相互引用
      workInProgress.alternate = current; 
      current.alternate = workInProgress;
    } else {
      workInProgress.pendingProps = pendingProps;
      // Needed because Blocks store data on type.
      workInProgress.type = current.type;

      // We already have an alternate.
      // Reset the effect tag.
      workInProgress.effectTag = NoEffect;

      // The effect list is no longer valid.
      workInProgress.nextEffect = null;
      workInProgress.firstEffect = null;
      workInProgress.lastEffect = null;

      if (enableProfilerTimer) {
        // We intentionally reset, rather than copy, actualDuration & actualStartTime.
        // This prevents time from endlessly accumulating in new commits.
        // This has the downside of resetting values for different priority renders,
        // But works for yielding (the common case) and should support resuming.
        workInProgress.actualDuration = 0;
        workInProgress.actualStartTime = -1;
      }
    }

    workInProgress.childExpirationTime = current.childExpirationTime;
    workInProgress.expirationTime = current.expirationTime;

    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;

    // Clone the dependencies object. This is mutated during the render phase, so
    // it cannot be shared with the current fiber.
    const currentDependencies = current.dependencies_old;
    workInProgress.dependencies_old =
      currentDependencies === null
        ? null
        : {
            expirationTime: currentDependencies.expirationTime,
            firstContext: currentDependencies.firstContext,
            responders: currentDependencies.responders,
          };

    // These will be overridden during the parent's reconciliation
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;

    if (enableProfilerTimer) {
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
    }

    return workInProgress;
  }
```

13. schedulePendingInteractions

```js
  function schedulePendingInteractions(root, expirationTime) {
    // This is called when work is scheduled on a root.
    // It associates the current interactions with the newly-scheduled expiration.
    // They will be restored when that expiration is later committed.
    if (!enableSchedulerTracing) {
      return;
    }
    scheduleInteractions(root, expirationTime, __interactionsRef.current);
  }

```

14. scheduleInteractions

```js
  function scheduleInteractions(root, expirationTime, interactions) {
    if (!enableSchedulerTracing) {
      return;
    }
    if (interactions.size > 0) { // 首次渲染不会进入该分支
      const pendingInteractionMap = root.pendingInteractionMap_old;
      const pendingInteractions = pendingInteractionMap.get(expirationTime);
      if (pendingInteractions != null) {
        interactions.forEach(interaction => {
          if (!pendingInteractions.has(interaction)) {
            // Update the pending async work count for previously unscheduled interaction.
            interaction.__count++;
          }

          pendingInteractions.add(interaction);
        });
      } else {
        pendingInteractionMap.set(expirationTime, new Set(interactions));

        // Update the pending async work count for the current interactions.
        interactions.forEach(interaction => {
          interaction.__count++;
        });
      }

      const subscriber = __subscriberRef.current;
      if (subscriber !== null) {
        const threadID = computeThreadID(root, expirationTime);
        subscriber.onWorkScheduled(interactions, threadID);
      }
    }
  }
```

15. pushInteractions

```js
  function pushInteractions(root) {
    if (enableSchedulerTracing) {
      const prevInteractions: Set<Interaction> | null = __interactionsRef.current;
      __interactionsRef.current = root.memoizedInteractions;
      return prevInteractions;
    }
    return null;
  }
```


16. workLoopSync

```js
// The work loop is an extremely hot path. Tell Closure not to inline it.

function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

17. performUnitOfWork

```js
  // renderExpirationTime的值在执行prepareFreshStack函数时被赋予了新值

  export const NoMode = 0b00000;
  export const StrictMode = 0b00001;
  export const BlockingMode = 0b00010;
  export const ConcurrentMode = 0b00100;
  export const ProfileMode = 0b01000;
  export const DebugTracingMode = 0b10000;

  function performUnitOfWork(unitOfWork: Fiber): void {
    // The current, flushed, state of this fiber is the alternate. Ideally
    // nothing should rely on this, but relying on it here means that we don't
    // need an additional field on the work in progress.
    const current = unitOfWork.alternate;

    let next;
    if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
      startProfilerTimer(unitOfWork);
      next = beginWork(current, unitOfWork, renderExpirationTime);
      stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
    } else { // 首次渲染进入该分支
      next = beginWork(current, unitOfWork, renderExpirationTime);
    }

    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      completeUnitOfWork(unitOfWork);
    } else {
      workInProgress = next;
    }

    ReactCurrentOwner.current = null;
  }
```

18. beginWork

这个函数也太长了吧。。。

```js
  export const FunctionComponent = 0;
  export const ClassComponent = 1;
  export const IndeterminateComponent = 2; // Before we know whether it is function or class
  export const HostRoot = 3; // Root of a host tree. Could be nested inside another node.
  export const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
  export const HostComponent = 5;
  export const HostText = 6;
  export const Fragment = 7;
  export const Mode = 8;
  export const ContextConsumer = 9;
  export const ContextProvider = 10;
  export const ForwardRef = 11;
  export const Profiler = 12;
  export const SuspenseComponent = 13;
  export const MemoComponent = 14;
  export const SimpleMemoComponent = 15;
  export const LazyComponent = 16;
  export const IncompleteClassComponent = 17;
  export const DehydratedFragment = 18;
  export const SuspenseListComponent = 19;
  export const FundamentalComponent = 20;
  export const ScopeComponent = 21;
  export const Block = 22;
  export const OffscreenComponent = 23;
  export const LegacyHiddenComponent = 24;

  function beginWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderExpirationTime: ExpirationTime,
  ): Fiber | null {
    // 首次expirationTime为0
    const updateExpirationTime = workInProgress.expirationTime;

    if (current !== null) {
      const oldProps = current.memoizedProps;
      const newProps = workInProgress.pendingProps;

      if (
        oldProps !== newProps ||
        hasLegacyContextChanged() ||
        // Force a re-render if the implementation changed due to hot reload:
        (__DEV__ ? workInProgress.type !== current.type : false)
      ) {
        // If props or context changed, mark the fiber as having performed work.
        // This may be unset if the props are determined to be equal later (memo).
        didReceiveUpdate = true;
      } else if (updateExpirationTime < renderExpirationTime) { // updateExpirationTime = renderExpirationTime = 1073741823
        didReceiveUpdate = false;
        // This fiber does not have any pending work. Bailout without entering
        // the begin phase. There's still some bookkeeping we that needs to be done
        // in this optimized path, mostly pushing stuff onto the stack.
        switch (workInProgress.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress);
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress);
            if (
              workInProgress.mode & ConcurrentMode &&
              renderExpirationTime !== Never &&
              shouldDeprioritizeSubtree(workInProgress.type, newProps)
            ) {
              if (enableSchedulerTracing) {
                markSpawnedWork(Never);
              }
              // Schedule this fiber to re-render at offscreen priority. Then bailout.
              workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
              return null;
            }
            break;
          case ClassComponent: {
            const Component = workInProgress.type;
            if (isLegacyContextProvider(Component)) {
              pushLegacyContextProvider(workInProgress);
            }
            break;
          }
          case HostPortal:
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo,
            );
            break;
          case ContextProvider: {
            const newValue = workInProgress.memoizedProps.value;
            pushProvider(workInProgress, newValue);
            break;
          }
          case Profiler:
            if (enableProfilerTimer) {
              // Profiler should only call onRender when one of its descendants actually rendered.
              const hasChildWork =
                workInProgress.childExpirationTime >= renderExpirationTime;
              if (hasChildWork) {
                workInProgress.effectTag |= Update;
              }

              // Reset effect durations for the next eventual effect phase.
              // These are reset during render to allow the DevTools commit hook a chance to read them,
              const stateNode = workInProgress.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            break;
          case SuspenseComponent: {
            const state: SuspenseState | null = workInProgress.memoizedState;
            if (state !== null) {
              if (enableSuspenseServerRenderer) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(
                    workInProgress,
                    setDefaultShallowSuspenseContext(suspenseStackCursor.current),
                  );
                  // We know that this component will suspend again because if it has
                  // been unsuspended it has committed as a resolved Suspense component.
                  // If it needs to be retried, it should have work scheduled on it.
                  workInProgress.effectTag |= DidCapture;

                  return null;
                }
              }

              // If this boundary is currently timed out, we need to decide
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              // child fragment.
              const primaryChildFragment: Fiber = (workInProgress.child: any);
              const primaryChildExpirationTime =
                primaryChildFragment.childExpirationTime;
              if (primaryChildExpirationTime >= renderExpirationTime) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(
                  current,
                  workInProgress,
                  renderExpirationTime,
                );
              } else {
                // The primary child fragment does not have pending work marked
                // on it...

                // ...usually. There's an unfortunate edge case where the fragment
                // fiber is not part of the return path of the children, so when
                // an update happens, the fragment doesn't get marked during
                // setState. This is something we should consider addressing when
                // we refactor the Fiber data structure. (There's a test with more
                // details; to find it, comment out the following block and see
                // which one fails.)
                //
                // As a workaround, we need to recompute the `childExpirationTime`
                // by bubbling it up from the next level of children. This is
                // based on similar logic in `resetChildExpirationTime`.
                let primaryChild = primaryChildFragment.child;
                while (primaryChild !== null) {
                  const childUpdateExpirationTime = primaryChild.expirationTime;
                  const childChildExpirationTime =
                    primaryChild.childExpirationTime;
                  if (
                    childUpdateExpirationTime >= renderExpirationTime ||
                    childChildExpirationTime >= renderExpirationTime
                  ) {
                    // Found a child with an update with sufficient priority.
                    // Use the normal path to render the primary children again.
                    return updateSuspenseComponent(
                      current,
                      workInProgress,
                      renderExpirationTime,
                    );
                  }
                  primaryChild = primaryChild.sibling;
                }

                pushSuspenseContext(
                  workInProgress,
                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),
                );
                // The primary children do not have pending work with sufficient
                // priority. Bailout.
                const child = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderExpirationTime,
                );
                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(
                workInProgress,
                setDefaultShallowSuspenseContext(suspenseStackCursor.current),
              );
            }
            break;
          }
          case SuspenseListComponent: {
            const didSuspendBefore =
              (current.effectTag & DidCapture) !== NoEffect;

            const hasChildWork =
              workInProgress.childExpirationTime >= renderExpirationTime;

            if (didSuspendBefore) {
              if (hasChildWork) {
                // If something was in fallback state last time, and we have all the
                // same children then we're still in progressive loading state.
                // Something might get unblocked by state updates or retries in the
                // tree which will affect the tail. So we need to use the normal
                // path to compute the correct tail.
                return updateSuspenseListComponent(
                  current,
                  workInProgress,
                  renderExpirationTime,
                );
              }
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              workInProgress.effectTag |= DidCapture;
            }

            // If nothing suspended before and we're rendering the same children,
            // then the tail doesn't matter. Anything new that suspends will work
            // in the "together" mode, so we can continue from the state we had.
            const renderState = workInProgress.memoizedState;
            if (renderState !== null) {
              // Reset to the "together" mode in case we've started a different
              // update in the past but didn't complete it.
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }
            pushSuspenseContext(workInProgress, suspenseStackCursor.current);

            if (hasChildWork) {
              break;
            } else {
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              return null;
            }
          }
        }
        return bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderExpirationTime,
        );
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    } else {
      didReceiveUpdate = false; // 首次渲染直接到这里
    }

    // Before entering the begin phase, clear pending update priority.
    // TODO: This assumes that we're about to evaluate the component and process
    // the update queue. However, there's an exception: SimpleMemoComponent
    // sometimes bails out later in the begin phase. This indicates that we should
    // move this assignment out of the common path and into each branch.
    workInProgress.expirationTime = NoWork;

    switch (workInProgress.tag) {
      case IndeterminateComponent: {
        return mountIndeterminateComponent(
          current,
          workInProgress,
          workInProgress.type,
          renderExpirationTime,
        );
      }
      case LazyComponent: {
        const elementType = workInProgress.elementType;
        return mountLazyComponent(
          current,
          workInProgress,
          elementType,
          updateExpirationTime,
          renderExpirationTime,
        );
      }
      case FunctionComponent: {
        const Component = workInProgress.type;
        const unresolvedProps = workInProgress.pendingProps;
        const resolvedProps =
          workInProgress.elementType === Component
            ? unresolvedProps
            : resolveDefaultProps(Component, unresolvedProps);
        return updateFunctionComponent(
          current,
          workInProgress,
          Component,
          resolvedProps,
          renderExpirationTime,
        );
      }
      case ClassComponent: {
        const Component = workInProgress.type;
        const unresolvedProps = workInProgress.pendingProps;
        const resolvedProps =
          workInProgress.elementType === Component
            ? unresolvedProps
            : resolveDefaultProps(Component, unresolvedProps);
        return updateClassComponent(
          current,
          workInProgress,
          Component,
          resolvedProps,
          renderExpirationTime,
        );
      }
      case HostRoot: // 首次渲染第一次进入这个分支
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case SuspenseComponent:
        return updateSuspenseComponent(
          current,
          workInProgress,
          renderExpirationTime,
        );
      case HostPortal:
        return updatePortalComponent(
          current,
          workInProgress,
          renderExpirationTime,
        );
      case ForwardRef: {
        const type = workInProgress.type;
        const unresolvedProps = workInProgress.pendingProps;
        const resolvedProps =
          workInProgress.elementType === type
            ? unresolvedProps
            : resolveDefaultProps(type, unresolvedProps);
        return updateForwardRef(
          current,
          workInProgress,
          type,
          resolvedProps,
          renderExpirationTime,
        );
      }
      case Fragment:
        return updateFragment(current, workInProgress, renderExpirationTime);
      case Mode:
        return updateMode(current, workInProgress, renderExpirationTime);
      case Profiler:
        return updateProfiler(current, workInProgress, renderExpirationTime);
      case ContextProvider:
        return updateContextProvider(
          current,
          workInProgress,
          renderExpirationTime,
        );
      case ContextConsumer:
        return updateContextConsumer(
          current,
          workInProgress,
          renderExpirationTime,
        );
      case MemoComponent: {
        const type = workInProgress.type;
        const unresolvedProps = workInProgress.pendingProps;
        // Resolve outer props first, then resolve inner props.
        let resolvedProps = resolveDefaultProps(type, unresolvedProps);
        resolvedProps = resolveDefaultProps(type.type, resolvedProps);
        return updateMemoComponent(
          current,
          workInProgress,
          type,
          resolvedProps,
          updateExpirationTime,
          renderExpirationTime,
        );
      }
      case SimpleMemoComponent: {
        return updateSimpleMemoComponent(
          current,
          workInProgress,
          workInProgress.type,
          workInProgress.pendingProps,
          updateExpirationTime,
          renderExpirationTime,
        );
      }
      case IncompleteClassComponent: {
        const Component = workInProgress.type;
        const unresolvedProps = workInProgress.pendingProps;
        const resolvedProps =
          workInProgress.elementType === Component
            ? unresolvedProps
            : resolveDefaultProps(Component, unresolvedProps);
        return mountIncompleteClassComponent(
          current,
          workInProgress,
          Component,
          resolvedProps,
          renderExpirationTime,
        );
      }
      case SuspenseListComponent: {
        return updateSuspenseListComponent(
          current,
          workInProgress,
          renderExpirationTime,
        );
      }
      case FundamentalComponent: {
        if (enableFundamentalAPI) {
          return updateFundamentalComponent(
            current,
            workInProgress,
            renderExpirationTime,
          );
        }
        break;
      }
      case ScopeComponent: {
        if (enableScopeAPI) {
          return updateScopeComponent(
            current,
            workInProgress,
            renderExpirationTime,
          );
        }
        break;
      }
      case Block: {
        if (enableBlocksAPI) {
          const block = workInProgress.type;
          const props = workInProgress.pendingProps;
          return updateBlock(
            current,
            workInProgress,
            block,
            props,
            renderExpirationTime,
          );
        }
        break;
      }
    }
    invariant(
      false,
      'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +
        'React. Please file an issue.',
      workInProgress.tag,
    );
  }
```
=================================================================

*注意：由于判断失误。。。首次渲染不会调用19~26号函数。。。*

19. pushHostRootContext

首次渲染时，处理root对应的fiber时会调用这个函数

```js
  function pushHostRootContext(workInProgress) {
    const root = (workInProgress.stateNode: FiberRoot);
    if (root.pendingContext) { // root.pengingContext = null
      pushTopLevelContextObject(
        workInProgress,
        root.pendingContext,
        root.pendingContext !== root.context,
      );
    } else if (root.context) { // root.context = {}
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }
```

20. pushTopLevelContextObject

首次渲染的调用： `pushTopLevelContextObject(workInProgress, root.context, false);`


```js
  function pushTopLevelContextObject(
    fiber: Fiber,
    context: Object,
    didChange: boolean,
  ): void {
    if (disableLegacyContext) { // false
      return;
    } else {
      invariant(
        contextStackCursor.current === emptyContextObject,
        'Unexpected context found on stack. ' +
          'This error is likely caused by a bug in React. Please file an issue.',
      );
      // contextStackCursor = { current: {} }
      // context = {}
      // 首次渲染执行完这个函数的结果是
      // index = 0
      // valueStack = [{}]
      // contextStackCursor = { current: {} } current的值变为新的空对象
      push(contextStackCursor, context, fiber);
      // didPerformWorkStackCursor = { current: false }
      // didChange = false
      // 就结果而言没有变化
      push(didPerformWorkStackCursor, didChange, fiber);
      // 上面两个函数执行完的结果：
      // index = 1
      // valueStack = [{}, false]
    }
  }
```

21. push

```js
  // index = -1
  // valueStack = []
  function push<T>(cursor: StackCursor<T>, value: T, fiber: Fiber): void {
    index++;

    valueStack[index] = cursor.current;

    cursor.current = value;
  }
```

22. pushHostContainer

```js
  // 执行下面指令之前的相关变量值
  // index = 1
  // valueStack = [{}, false]
  // 分别是：contextStackCursor和didPerformWorkStackCursor

  // const NO_CONTEXT: NoContextT = ({}: any);
  // const rootInstanceStackCursor: StackCursor<
  //   Container | NoContextT,
  // > = createCursor(NO_CONTEXT);

  // const contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(
  //   NO_CONTEXT,
  // );
  // const contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(
  //   NO_CONTEXT,
  // );

  function pushHostContainer(fiber: Fiber, nextRootInstance: Container) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    // index = 2
    // valueStack = [{}, false, {}]
    // rootInstanceStackCursor = { current: container }
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    // index = 3
    // valueStack = [{}, false, {}, {}]
    // contextFiberStackCursor = { current: workInProgress }
    push(contextFiberStackCursor, fiber, fiber);

    // Finally, we need to push the host context to the stack.
    // However, we can't just call getRootHostContext() and push it because
    // we'd have a different number of entries on the stack depending on
    // whether getRootHostContext() throws somewhere in renderer code or not.
    // So we push an empty value first. This lets us safely unwind on errors.

    // index = 4
    // valueStack = [{}, false, {}, {}, {}]
    // contextStackCursor = { current: {} }
    push(contextStackCursor, NO_CONTEXT, fiber);
    const nextRootContext = getRootHostContext(nextRootInstance); // 计算得到：http://www.w3.org/1999/xhtml
    // Now that we know this function doesn't throw, replace it.
    // index = 3
    // valueStack = [{}, false, {}, {}, null]
    // contextStackCursor = { current: {} }
    pop(contextStackCursor, fiber);
    // index = 4
    // valueStack = [{}, false, {}, {}, {} ]
    // contextStackCursor = { current: "http://www.w3.org/1999/xhtml" }
    push(contextStackCursor, nextRootContext, fiber);
  }
```

23. getRootHostContext

这是进入react内部第一次遇到直接操纵dom的地方

```js
  function getRootHostContext(
    rootContainerInstance: Container,
  ): HostContext {
    let type;
    let namespace;
    const nodeType = rootContainerInstance.nodeType; // 1 ELEMENT_NODE （首次渲染）
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE: {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        const root = (rootContainerInstance: any).documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }
      default: { // 首次渲染走这个分支
        const container: any =
          nodeType === COMMENT_NODE
            ? rootContainerInstance.parentNode
            : rootContainerInstance;
        const ownNamespace = container.namespaceURI || null; // http://www.w3.org/1999/xhtml
        type = container.tagName; // 'DIV'
        namespace = getChildNamespace(ownNamespace, type); // http://www.w3.org/1999/xhtml
        break;
      }
    }

    return namespace;
  }
```

24. getChildNamespace

完全没看懂这个函数。。。为啥要绕一圈。。。

```js
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';

  function getChildNamespace(
    parentNamespace: string | null,
    type: string,
  ): string {
    if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
      // No (or default) parent namespace: potential entry point.
      return getIntrinsicNamespace(type);
    }
    if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
      // We're leaving SVG.
      return HTML_NAMESPACE;
    }
    // By default, pass namespace below.
    return parentNamespace;
  }
```

25. pop

```js
  function pop<T>(cursor: StackCursor<T>, fiber: Fiber): void {
    if (index < 0) {
      return;
    }

    cursor.current = valueStack[index];

    valueStack[index] = null;

    index--;
  }
```

26. bailoutOnAlreadyFinishedWork

此处调用： `return bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderExpirationTime,
      );`


```js
  function bailoutOnAlreadyFinishedWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderExpirationTime: ExpirationTime,
  ): Fiber | null {
    if (current !== null) {
      // Reuse previous dependencies
      workInProgress.dependencies_old = current.dependencies_old;
    }

    if (enableProfilerTimer) {
      // Don't update "base" render times for bailouts.
      stopProfilerTimerIfRunning(workInProgress);
    }

    const updateExpirationTime = workInProgress.expirationTime;
    if (updateExpirationTime !== NoWork) {
      markUnprocessedUpdateTime(updateExpirationTime);
    }

    // Check if the children have any pending work.
    const childExpirationTime = workInProgress.childExpirationTime;
    if (childExpirationTime < renderExpirationTime) {
      // The children don't have any work either. We can skip them.
      // TODO: Once we add back resuming, we should check if the children are
      // a work-in-progress set. If so, we need to transfer their effects.
      return null;
    } else {
      // This fiber doesn't have work, but its subtree does. Clone the child
      // fibers and continue.
      cloneChildFibers(current, workInProgress);
      return workInProgress.child;
    }
  }
```

==================================================================================


27. updateHostRoot


此刻的各个属性值:

```js
  updateQueue: {
    effects: null,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
    },
    element: {
      $$typeof: Symbol(react.element),
      key: null,
      ref: null,
      type: Symbol(react.strict_mode)
      _owner: null,
      props: {
        children: {
          $$typeof: Symbol(react.element),
          key: null,
          props: {},
          ref: null,
          type: App(),
          _owner: null,
        }
      },
    }
  }

  pendingProps: null

  memoizedState: {
    element: {
      $$typeof: Symbol(react.element),
      key: null,
      ref: null,
      type: Symbol(react.strict_mode)
      _owner: null,
      props: {
        children: {
          $$typeof: Symbol(react.element),
          key: null,
          props: {},
          ref: null,
          type: App(),
          _owner: null,
        }
      },
    }
  }
```

```js
  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress); // 见上
    const updateQueue = workInProgress.updateQueue;
    const nextProps = workInProgress.pendingProps;
    const prevState = workInProgress.memoizedState;
    const prevChildren = prevState !== null ? prevState.element : null; // null
    cloneUpdateQueue(current, workInProgress);
    processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);
    const nextState = workInProgress.memoizedState;
    // Caution: React DevTools currently depends on this property
    // being called "element".
    const nextChildren = nextState.element;
    if (nextChildren === prevChildren) {
      // If the state is the same as before, that's a bailout because we had
      // no work that expires at this time.
      resetHydrationState();
      return bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderExpirationTime,
      );
    }
    const root: FiberRoot = workInProgress.stateNode;
    if (root.hydrate && enterHydrationState(workInProgress)) {
      // If we don't have any current children this might be the first pass.
      // We always try to hydrate. If this isn't a hydration pass there won't
      // be any children to hydrate which is effectively the same thing as
      // not hydrating.

      if (supportsHydration) {
        const mutableSourceEagerHydrationData =
          root.mutableSourceEagerHydrationData;
        if (mutableSourceEagerHydrationData != null) {
          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
            const mutableSource = ((mutableSourceEagerHydrationData[
              i
            ]: any): MutableSource<any>);
            const version = mutableSourceEagerHydrationData[i + 1];
            setWorkInProgressVersion(mutableSource, version);
          }
        }
      }

      const child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderExpirationTime,
      );
      workInProgress.child = child;

      let node = child;
      while (node) {
        // Mark each child as hydrating. This is a fast path to know whether this
        // tree is part of a hydrating tree. This is used to determine if a child
        // node has fully mounted yet, and for scheduling event replaying.
        // Conceptually this is similar to Placement in that a new subtree is
        // inserted into the React tree here. It just happens to not need DOM
        // mutations because it already exists.
        node.effectTag = (node.effectTag & ~Placement) | Hydrating;
        node = node.sibling;
      }
    } else {
      // Otherwise reset hydration state in case we aborted and resumed another
      // root.
      reconcileChildren(
        current,
        workInProgress,
        nextChildren,
        renderExpirationTime,
      );
      resetHydrationState();
    }
    return workInProgress.child;
  }
```

28. cloneUpdateQueue

这个函数是将current的updateQueue浅拷贝给workInProgress的updateQueue

```js
function cloneUpdateQueue<State>(
  current: Fiber,
  workInProgress: Fiber,
): void {
  // Clone the update queue from current. Unless it's already a clone.
  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);
  const currentQueue: UpdateQueue<State> = (current.updateQueue: any);
  if (queue === currentQueue) {
    const clone: UpdateQueue<State> = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      effects: currentQueue.effects,
    };
    workInProgress.updateQueue = clone;
  }
}
```

29. processUpdateQueue

此处调用：processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);

```js
// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
let hasForceUpdate = false;

queue.shared.pending = {
  callback: null,
  expirationTime: 1073741823,
  next: pending, // next引用另一个pending，此处是它所在的pending
  suspenseConfig: null,
  tag: 0,
  payload: {
    element: {
      $$typeof: Symbol(react.element),
      key: null,
      ref: null,
      type: Symbol(react.strict_mode),
      _owner: null,
      props: {
        children: {
          $$typeof: Symbol(react.element),
          key: null,
          props: {},
          ref: null,
          type: App(),
          _owner: null,
        },
      }
    }
  }
}

queue: {
  baseState: null,
  effects: null,
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: 见上
}

// The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.
let workInProgressRootNextUnprocessedUpdateTime: ExpirationTime = NoWork;

export function markUnprocessedUpdateTime(
  expirationTime: ExpirationTime,
): void {
  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {
    workInProgressRootNextUnprocessedUpdateTime = expirationTime;
  }
}

export function processUpdateQueue<State>(
  workInProgress: Fiber,
  props: any,
  instance: any,
  renderExpirationTime: ExpirationTime,
): void {
  // This is always non-null on a ClassComponent or HostRoot
  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);

  hasForceUpdate = false;

  let firstBaseUpdate = queue.firstBaseUpdate; // null
  let lastBaseUpdate = queue.lastBaseUpdate; // null

  // Check if there are pending updates. If so, transfer them to the base queue.
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) { 
    queue.shared.pending = null;

    // The pending queue is circular. Disconnect the pointer between first
    // and last so that it's non-circular.
    const lastPendingUpdate = pendingQueue;
    const firstPendingUpdate = lastPendingUpdate.next;
    // lastPendingUpdate === firstPendingUpdate   true
    lastPendingUpdate.next = null;
    // Append pending updates to base queue
    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;

    // If there's a current queue, and it's different from the base queue, then
    // we need to transfer the updates to that queue, too. Because the base
    // queue is a singly-linked list with no cycles, we can append to both
    // lists and take advantage of structural sharing.
    // TODO: Pass `current` as argument
    const current = workInProgress.alternate;
    if (current !== null) {
      // This is always non-null on a ClassComponent or HostRoot
      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);
      // currentQueue = {
      //   baseState: null,
      //   effects: null,
      //   firstBaseUpdate: null,
      //   lastBaseUpdate: null,
      //   shared: {
      //     pending: null,
      //   },
      // }
      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;
      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }
        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  }

  // These values may change as we process the queue.
  if (firstBaseUpdate !== null) {
    // Iterate through the list of updates to compute the result.
    let newState = queue.baseState;
    let newExpirationTime = NoWork;

    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;

    let update = firstBaseUpdate;
    do {
      const updateExpirationTime = update.expirationTime;
      if (updateExpirationTime < renderExpirationTime) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        const clone: Update<State> = {
          expirationTime: update.expirationTime,
          suspenseConfig: update.suspenseConfig,

          tag: update.tag,
          payload: update.payload,
          callback: update.callback,

          next: null,
        };
        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        // Update the remaining priority in the queue.
        if (updateExpirationTime > newExpirationTime) {
          newExpirationTime = updateExpirationTime;
        }
      } else {
        // This update does have sufficient priority.

        if (newLastBaseUpdate !== null) {
          const clone: Update<State> = {
            expirationTime: Sync, // This update is going to be committed so we never want uncommit it.
            suspenseConfig: update.suspenseConfig,

            tag: update.tag,
            payload: update.payload,
            callback: update.callback,

            next: null,
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }

        // Mark the event time of this update as relevant to this render pass.
        // TODO: This should ideally use the true event time of this update rather than
        // its priority which is a derived and not reverseable value.
        // TODO: We should skip this update if it was already committed but currently
        // we have no way of detecting the difference between a committed and suspended
        // update here.
        // 首次渲染第一次什么都没干
        markRenderEventTimeAndConfig(
          updateExpirationTime,
          update.suspenseConfig,
        );

        // Process this update.
        newState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          newState,
          props,
          instance,
        );
        const callback = update.callback;
        if (callback !== null) {
          workInProgress.effectTag |= Callback;
          const effects = queue.effects;
          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }
      update = update.next;
      if (update === null) {
        pendingQueue = queue.shared.pending;
        if (pendingQueue === null) {
          break;
        } else {
          // An update was scheduled from inside a reducer. Add the new
          // pending updates to the end of the list and keep processing.
          const lastPendingUpdate = pendingQueue;
          // Intentionally unsound. Pending updates form a circular list, but we
          // unravel them when transferring them to the base queue.
          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);
          lastPendingUpdate.next = null;
          update = firstPendingUpdate;
          queue.lastBaseUpdate = lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = ((newBaseState: any): State);
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;

    // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.
    markUnprocessedUpdateTime(newExpirationTime);
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = newState;
  }
}
```

30.  markRenderEventTimeAndConfig

```js
// Most recent event time among processed updates during this render.
// This is conceptually a time stamp but expressed in terms of an ExpirationTime
// because we deal mostly with expiration times in the hot path, so this avoids
// the conversion happening in the hot path.
let workInProgressRootLatestProcessedExpirationTime: ExpirationTime = Sync;
// Idle is slightly higher priority than Never. It must completely finish in
// order to be consistent.
export const Idle = 2;

function markRenderEventTimeAndConfig(
  expirationTime: ExpirationTime, // 1073741823
  suspenseConfig: null | SuspenseConfig, // null
): void {
  if (
    expirationTime < workInProgressRootLatestProcessedExpirationTime &&
    expirationTime > Idle
  ) {
    workInProgressRootLatestProcessedExpirationTime = expirationTime;
  }
  if (suspenseConfig !== null) {
    if (
      expirationTime < workInProgressRootLatestSuspenseTimeout &&
      expirationTime > Idle
    ) {
      workInProgressRootLatestSuspenseTimeout = expirationTime;
      // Most of the time we only have one config and getting wrong is not bad.
      workInProgressRootCanSuspendUsingConfig = suspenseConfig;
    }
  }
}
```

31. getStateFromUpdate

此处调用：getStateFromUpdate(workInProgress, workInProgress.updateQueue, firstPendingUpdate, null, null, null)

```js
export const UpdateState = 0;
export const ReplaceState = 1;
export const ForceUpdate = 2;
export const CaptureUpdate = 3;

function getStateFromUpdate<State>(
  workInProgress: Fiber,
  queue: UpdateQueue<State>,
  update: Update<State>,
  prevState: State,
  nextProps: any,
  instance: any,
): any {
  switch (update.tag) { // 0
    case ReplaceState: {
      const payload = update.payload;
      if (typeof payload === 'function') {
        // Updater function
        const nextState = payload.call(instance, prevState, nextProps);
        return nextState;
      }
      // State object
      return payload;
    }
    case CaptureUpdate: {
      workInProgress.effectTag =
        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;
    }
    // Intentional fallthrough
    case UpdateState: {
      // 首次渲染第一次
      // payload = {
      //   $$typeof: Symbol(react.element)
      //   key: null,
      //   props: {
      //     children: {
      //       $$typeof: Symbol(react.element),
      //       key: null,
      //       props: {},
      //       ref: null,
      //       type: f App(),
      //       _owner: null
      //     }
      //   }
      //   ref: null,
      //   type: Symbol(react.strict_mode)
      //   _owner: null
      // }
      const payload = update.payload;
      let partialState;
      if (typeof payload === 'function') {
        // Updater function
        partialState = payload.call(instance, prevState, nextProps);
      } else {
        // Partial state object
        partialState = payload;
      }
      if (partialState === null || partialState === undefined) {
        // Null and undefined are treated as no-ops.
        return prevState;
      }
      // Merge the partial state and the previous state.
      return Object.assign({}, prevState, partialState); 
    }
    case ForceUpdate: {
      hasForceUpdate = true;
      return prevState;
    }
  }
  return prevState;
}
```

32. reconcileChildren

此处调用： `    reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderExpirationTime,
    );`

```js
  export function reconcileChildren(
    current: Fiber | null,
    workInProgress: Fiber,
    nextChildren: any,
    renderExpirationTime: ExpirationTime,
  ) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderExpirationTime,
      );
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.

      // ================================进入下面这个函数时的各个参数值==================
      // child: null
      // nextChildren: {
      //   $$typeof: Symbol(react.element)
      //   key: null
      //   props: {
      //     children: {
      //       $$typeof: Symbol(react.element)
      //       key: null
      //       props: {}
      //       ref: null
      //       type: ƒ App()
      //       _owner: null
      //     }
      //   }
      //   ref: null
      //   type: Symbol(react.strict_mode)
      //   _owner: null
      // }
      // renderExpirationTime: 1073741823
      // ===========================================================================
      workInProgress.child = reconcileChildFibers(
        workInProgress,
        current.child,
        nextChildren,
        renderExpirationTime,
      );
    }
  }
```

33. reconcileChildFibers

```js
  // nextChildren: {
  //   $$typeof: Symbol(react.element),
  //   key: null,
  //   ref: null,
  //   type: Symbol(react.strict_mode)
  //   _owner: null,
  //   props: {
  //     children: {
  //       $$typeof: Symbol(react.element),
  //       key: null,
  //       props: {},
  //       ref: null,
  //       type: App(),
  //       _owner: null,
  //     }
  //   },
  // }

  // REACT_ELEMENT_TYPE = symbolFor('react.element');
  // shouldTrackSideEffects = true;
  // export const Placement =  0b00000000000010;

  function placeSingleChild(newFiber: Fiber): Fiber {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    expirationTime: ExpirationTime,
  ): Fiber {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        switch (child.tag) {
          case Fragment: {
            if (element.type === REACT_FRAGMENT_TYPE) {
              deleteRemainingChildren(returnFiber, child.sibling);
              const existing = useFiber(child, element.props.children);
              existing.return = returnFiber;
              return existing;
            }
            break;
          }
          case Block:
            if (enableBlocksAPI) {
              let type = element.type;
              if (type.$$typeof === REACT_LAZY_TYPE) {
                type = resolveLazyType(type);
              }
              if (type.$$typeof === REACT_BLOCK_TYPE) {
                // The new Block might not be initialized yet. We need to initialize
                // it in case initializing it turns out it would match.
                if (
                  ((type: any): BlockComponent<any, any>)._render ===
                  (child.type: BlockComponent<any, any>)._render
                ) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  const existing = useFiber(child, element.props);
                  existing.type = type;
                  existing.return = returnFiber;
                  return existing;
                }
              }
            }
          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough
          default: {
            if (
              child.elementType === element.type ||
              // Keep this check inline so it only runs on the false path:
              (__DEV__
                ? isCompatibleFamilyForHotReloading(child, element)
                : false)
            ) {
              deleteRemainingChildren(returnFiber, child.sibling);
              const existing = useFiber(child, element.props);
              existing.ref = coerceRef(returnFiber, child, element);
              existing.return = returnFiber;
              return existing;
            }
            break;
          }
        }
        // Didn't match.
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        expirationTime,
        element.key,
      );
      created.return = returnFiber;
      return created;
    } else {
      // 进入这个分支
      const created = createFiberFromElement(
        element,
        returnFiber.mode,
        expirationTime,
      );
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    const isUnkeyedTopLevelFragment =
      typeof newChild === 'object' &&
      newChild !== null &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      newChild.key === null; // false
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    }

    // Handle object types
    const isObject = typeof newChild === 'object' && newChild !== null; // true

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          '' + newChild,
          expirationTime,
        ),
      );
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent: {
        }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionComponent: {
          const Component = returnFiber.type;
          invariant(
            false,
            '%s(...): Nothing was returned from render. This usually means a ' +
              'return statement is missing. Or, to render nothing, ' +
              'return null.',
            Component.displayName || Component.name || 'Component',
          );
        }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }
```

34. createFiberFromElement

```js
  function createFiberFromElement(
    element: ReactElement,
    mode: TypeOfMode,
    expirationTime: ExpirationTime,
  ): Fiber {
    let owner = null;
    const type = element.type;
    const key = element.key;
    const pendingProps = element.props;
    const fiber = createFiberFromTypeAndProps(
      type,
      key,
      pendingProps,
      owner,
      mode,
      expirationTime,
    );
    return fiber;
  }
```

35. createFiberFromTypeAndProps

```js
  // type: Symbol(react.strict_mode)
  // key: null,
  // pendingProps: {
  //   children: {
  //     $$typeof: Symbol(react.element)
  //     key: null
  //     props: {}
  //     ref: null
  //     type: ƒ App()
  //     _owner: null
  //   }
  // }
  // owner: null
  // mode: 0
  // expirationTime: 1073741823
  export const NoMode = 0b00000;
  export const StrictMode = 0b00001;
  export const IndeterminateComponent = 2; // Before we know whether it is function or class
  function createFiberFromTypeAndProps(
    type: any, // React$ElementType
    key: null | string,
    pendingProps: any,
    owner: null | Fiber,
    mode: TypeOfMode,
    expirationTime: ExpirationTime,
  ): Fiber {
    let fiberTag = IndeterminateComponent; // 2
    // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
    let resolvedType = type; // Symbol(react.strict_mode)
    if (typeof type === 'function') {
      if (shouldConstruct(type)) {
        fiberTag = ClassComponent;
      } else {
      }
    } else if (typeof type === 'string') {
      fiberTag = HostComponent;
    } else {
      getTag: switch (type) {
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(
            pendingProps.children,
            mode,
            expirationTime,
            key,
          );
        case REACT_DEBUG_TRACING_MODE_TYPE:
          fiberTag = Mode;
          mode |= DebugTracingMode;
          break;
        case REACT_STRICT_MODE_TYPE: // 进入这个分支
          fiberTag = Mode; // 8
          mode |= StrictMode; // 0b00001
          break;
        case REACT_PROFILER_TYPE:
          return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
        case REACT_SUSPENSE_TYPE:
          return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
        case REACT_SUSPENSE_LIST_TYPE:
          return createFiberFromSuspenseList(
            pendingProps,
            mode,
            expirationTime,
            key,
          );
        default: {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;
              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;
                break getTag;
              case REACT_MEMO_TYPE:
                fiberTag = MemoComponent;
                break getTag;
              case REACT_LAZY_TYPE:
                fiberTag = LazyComponent;
                resolvedType = null;
                break getTag;
              case REACT_BLOCK_TYPE:
                fiberTag = Block;
                break getTag;
              case REACT_FUNDAMENTAL_TYPE:
                if (enableFundamentalAPI) {
                  return createFiberFromFundamental(
                    type,
                    pendingProps,
                    mode,
                    expirationTime,
                    key,
                  );
                }
                break;
              case REACT_SCOPE_TYPE:
                if (enableScopeAPI) {
                  return createFiberFromScope(
                    type,
                    pendingProps,
                    mode,
                    expirationTime,
                    key,
                  );
                }
            }
          }
          let info = '';
          invariant(
            false,
            'Element type is invalid: expected a string (for built-in ' +
              'components) or a class/function (for composite components) ' +
              'but got: %s.%s',
            type == null ? type : typeof type,
            info,
          );
        }
      }
    }

    const fiber = createFiber(fiberTag, pendingProps, key, mode); // createFiber(8, {
      // children: {
      //   $$typeof: Symbol(react.element)
      //   key: null
      //   props: {}
      //   ref: null
      //   type: ƒ App()
      //   _owner: null
      //   }
      // }, null, 0b00001)
    fiber.elementType = type;
    fiber.type = resolvedType;
    fiber.expirationTime = expirationTime;

    return fiber;
  }
```

36. coerceRef

```js
  function coerceRef(
    returnFiber: Fiber, // 
    current: Fiber | null, // null
    element: ReactElement,
  ) {
    const mixedRef = element.ref; // null
    if (
      mixedRef !== null &&
      typeof mixedRef !== 'function' &&
      typeof mixedRef !== 'object'
    ) {
      if (element._owner) {
        const owner: ?Fiber = (element._owner: any);
        let inst;
        if (owner) {
          const ownerFiber = ((owner: any): Fiber);
          invariant(
            ownerFiber.tag === ClassComponent,
            'Function components cannot have string refs. ' +
              'We recommend using useRef() instead. ' +
              'Learn more about using refs safely here: ' +
              'https://fb.me/react-strict-mode-string-ref',
          );
          inst = ownerFiber.stateNode;
        }
        invariant(
          inst,
          'Missing owner for string ref %s. This error is likely caused by a ' +
            'bug in React. Please file an issue.',
          mixedRef,
        );
        const stringRef = '' + mixedRef;
        // Check if previous string ref matches new string ref
        if (
          current !== null &&
          current.ref !== null &&
          typeof current.ref === 'function' &&
          current.ref._stringRef === stringRef
        ) {
          return current.ref;
        }
        const ref = function(value) {
          let refs = inst.refs;
          if (refs === emptyRefsObject) {
            // This is a lazy pooled frozen object, so we need to initialize.
            refs = inst.refs = {};
          }
          if (value === null) {
            delete refs[stringRef];
          } else {
            refs[stringRef] = value;
          }
        };
        ref._stringRef = stringRef;
        return ref;
      } else {
        invariant(
          typeof mixedRef === 'string',
          'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',
        );
        invariant(
          element._owner,
          'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' +
            ' the following reasons:\n' +
            '1. You may be adding a ref to a function component\n' +
            "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
            '3. You have multiple copies of React loaded\n' +
            'See https://fb.me/react-refs-must-have-owner for more information.',
          mixedRef,
        );
      }
    }
    return mixedRef;
  }
```

35. updateMode

```js
  function updateMode(
    current: Fiber | null,
    workInProgress: Fiber,
    renderExpirationTime: ExpirationTime,
  ) {
    const nextChildren = workInProgress.pendingProps.children;
    reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderExpirationTime,
    );
    return workInProgress.child;
  }
```






---

### workLoopSync中的循环

1. container参与的过程

函数调用过程：

```mermaid
  graph TD;

  workLoopSync --> performUnitOfWork;
  performUnitOfWork --> beginWork;
  beginWork --> updateHostRoot;
  updateHostRoot --> cloneUpdateQueue;
  updateHostRoot --> processUpdateQueue;
  processUpdateQueue --> markRenderEventTimeAndConfig;
  processUpdateQueue --> getStateFromUpdate;
  updateHostRoot --> reconcileChildren;
  reconcileChildren --> reconcileChildFibers;
  reconcileChildFibers --> placeSingleChild;
  placeSingleChild --> reconcileSingleElement;
  reconcileSingleElement --> createFiberFromElement;
  createFiberFromElement --> createFiberFromTypeAndProps;
  reconcileSingleElement --> coerceRef;
```

该过程执行结果：

**到这里拿到了最外层组件对应的Fiber对象（performUnitOfWork函数中的next），其实例为：**

```js
{
  actualDuration:0,
  actualStartTime:-1,
  alternate: null,
  child: null,
  childExpirationTime: 0,
  dependencies_old: null,
  effectTag: 2,
  elementType: Symbol(react.strict_mode),
  expirationTime: 1073741823,
  firstEffect: null,
  index: 0,
  key: null,
  lastEffect: null,
  memoizedProps: null,
  memoizedState: null,
  mode: 1,
  nextEffect: null,
  pendingProps: {
    children: {
      $$typeof: Symbol(react.element),
      key: null,
      props: {},
      ref: null,
      type: f App(),
      _owner: null
    }
  },
  ref: null,
  return: RootFiber,
  selfBaseDuration: 0,
  sibling: null,
  stateNode: null,
  tag: 8,
  treeBaseDuration: 0,
  type: Symbol(react.strict_mode),
  updateQueue: null,
}
```

**RootFiber：**

```js
  {
    actualDuration: 0,
    actualStartTime: -1,
    child: null,
    childExpirationTime: 0,
    dependencies_old: null,
    alternate: ,
    effectTag: 0,
    elementType: null,
    expirationTime: 1073741823,
    firstEffect: null,
    index: 0,
    key: null,
    lastEffect: null,
    memoizedProps: null,
    memoizedState: null,
    mode: 0,
    nextEffect: null,
    pendingProps: null,
    ref: null,
    return: null,
    selfBaseDuration: 0,
    sibling: null,
    tag: 3,
    treeBaseDuration: 0,
    type: null,
    stateNode: FiberRoot,
    updateQueue: {
      baseState: null,
      effects: null,
      shared: { pending: null },
      firstBaseUpdate: {
        callback: null,
        expirationTime: 1073741823,
        next: null,
        payload: {
          element: {
            $$typeof: Symbol(react.element),
            key: null,
            props: {
              children: {
                $$typeof: Symbol(react.element)
                key: null
                props: {}
                ref: null
                type: ƒ App()
                _owner: null
              }
            },
            ref: null
            type: Symbol(react.strict_mode)
            _owner: null
          }
        }
        suspenseConfig: null,
        tag: 0,
      },
      lastBaseUpdate: {
        callback: null,
        expirationTime: 1073741823,
        next: null,
        payload: {
          element: {
            $$typeof: Symbol(react.element)
            key: null
            props: {
              children: {
                $$typeof: Symbol(react.element)
                key: null
                props: {}
                ref: null
                type: ƒ App()
                _owner: null
              }
            }
            ref: null
            type: Symbol(react.strict_mode)
            _owner: null
          }
        },
        suspenseConfig: null,
        tag: 0,
      }
    },
  }
```
**FiberRoot:**

```js
  {
    callbackNode: null
    callbackPriority_old: 90
    containerInfo: div#root
    context: {}
    current: RootFiber
    finishedExpirationTime: 0
    finishedWork: null
    firstPendingTime: 1073741823
    firstSuspendedTime: 0
    hydrate: false
    interactionThreadID: 1
    lastExpiredTime: 0
    lastPendingTime: 1073741823
    lastPingedTime: 0
    lastSuspendedTime: 0
    memoizedInteractions: Set(0) {}
    mutableSourceEagerHydrationData: null
    mutableSourceLastPendingUpdateTime: 0
    nextKnownPendingLevel: 0
    pendingChildren: null
    pendingContext: null
    pendingInteractionMap_old: Map(0) {}
    pingCache: null
    tag: 0
    timeoutHandle: -1
  }
```

**WorkInProgress:**

```js
  {
    actualDuration: 0
    actualStartTime: -1
    alternate: RootFiber
    child: next
    childExpirationTime: 0
    dependencies_old: null
    effectTag: 0
    elementType: null
    expirationTime: 0
    firstEffect: null
    index: 0
    key: null
    lastEffect: null
    memoizedProps: null
    memoizedState: {
      element: {
        $$typeof: Symbol(react.element)
        key: null
        props: {
          children: {
            $$typeof: Symbol(react.element)
            key: null
            props: {}
            ref: null
            type: ƒ App()
            _owner: null
          }
        }
        ref: null
        type: Symbol(react.strict_mode)
        _owner: null
      }
    }
    mode: 0
    nextEffect: null
    pendingProps: null
    ref: null
    return: null
    selfBaseDuration: 0
    sibling: null
    stateNode: FiberRoot
    tag: 3
    treeBaseDuration: 0
    type: null
    updateQueue: {
      baseState: {
        element: {
          $$typeof: Symbol(react.element)
          key: null
          props: {
            children: {
              $$typeof: Symbol(react.element)
              key: null
              props: {}
              ref: null
              type: ƒ App()
              _owner: null
            }
          }
          ref: null
          type: Symbol(react.strict_mode)
          _owner: null
        }
      }
      effects: null
      firstBaseUpdate: null
      lastBaseUpdate: null
      shared: {pending: null}
    }
  }
```

2. `<React.StrictMode>
    <App />
  </React.StrictMode>`参与的循环过程

函数调用过程：

```mermaid
  graph TD;

  workLoopSync --> performUnitOfWork;
  performUnitOfWork --> beginWork;
  beginWork --> updateMode;
  updateMode --> reconcileChildren;
  reconcileChildren --> mountChildFibers;
  mountChildFibers --> placeSingleChild;
  placeSingleChild --> reconcileSingleElement;
  reconcileSingleElement --> createFiberFromElement;
  createFiberFromElement --> createFiberFromTypeAndProps;
  reconcileSingleElement --> coerceRef;
```

进行到`updateMode --> reconcileChildren`这一步的时候，当前的workInProgress(next)的child为null，但pendingProps.children中携带了子元素，用于child的构建（感觉pendingProps这个属性使用来存储后续更新用的）

mountChildFibers该函数同reconcileChildFibers，只不过其中的`shouldTrackSideEffects = false`


`$$typeof`用于在诸如`reconcileChildFibers`函数中进行分支判断

本次循环得到的结果：

**下一层的Fiber，next的值：**

```js
  {
    actualDuration: 0
    actualStartTime: -1
    alternate: null
    child: null
    childExpirationTime: 0
    dependencies_old: null
    effectTag: 0
    elementType: ƒ App()
    expirationTime: 1073741823
    firstEffect: null
    index: 0
    key: null
    lastEffect: null
    memoizedProps: null
    memoizedState: null
    mode: 1
    nextEffect: null
    pendingProps: {}
    ref: null
    return: FiberNode {tag: 8, key: null, elementType: Symbol(react.strict_mode), type: Symbol(react.strict_mode), stateNode: null, …}
    selfBaseDuration: 0
    sibling: null
    stateNode: null
    tag: 2
    treeBaseDuration: 0
    type: ƒ App()
    updateQueue: null
  }
```

**本次workInProgress:**

```js
  {
    actualDuration: 0
    actualStartTime: -1
    alternate: null
    child: FiberNode {tag: 2, key: null, stateNode: null, elementType: ƒ, type: ƒ, …}
    childExpirationTime: 0
    dependencies_old: null
    effectTag: 2
    elementType: Symbol(react.strict_mode)
    expirationTime: 0
    firstEffect: null
    index: 0
    key: null
    lastEffect: null
    memoizedProps: {
      children: {
        $$typeof: Symbol(react.element)
        key: null
        props: {}
        ref: null
        type: ƒ App()
        _owner: null
      }
    }
    memoizedState: null
    mode: 1
    nextEffect: null
    pendingProps: {
      children: {
        $$typeof: Symbol(react.element)
        key: null
        props: {}
        ref: null
        type: ƒ App()
        _owner: null
      }
    }
    ref: null
    return: RootFiber对应的workInProgress（container循环那层形成的workInProgress）
    selfBaseDuration: 0
    sibling: null
    stateNode: null
    tag: 8
    treeBaseDuration: 0
    type: Symbol(react.strict_mode)
    updateQueue: null
  }
```

---

### 参考资料