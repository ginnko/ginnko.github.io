<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客迁移</title>
      <link href="/2019/05/02/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/05/02/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="新博客说明"><a href="#新博客说明" class="headerlink" title="新博客说明"></a>新博客说明</h1><ol><li><p>新博客基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>。</p></li><li><p>模板使用<a href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank" rel="noopener">xoxo</a>。</p></li></ol><a id="more"></a><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><ol><li><p>原模板没有给出添加<em>标签页</em>和<em>搜索页</em>的方法，添加方法使用参考中的链接<em>1</em>。</p></li><li><p>原模板没有给出正确修改图片的方法，添加方法使用参考中的链接<em>2</em>。</p></li><li><p>该模板需要的额外插件：<code>hexo-reading-time</code>，<code>hexo-generator-search</code>。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于promise的理解</title>
      <link href="/2019/04/28/promise/"/>
      <url>/2019/04/28/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="基于回调函数的异步编程"><a href="#基于回调函数的异步编程" class="headerlink" title="基于回调函数的异步编程"></a>基于回调函数的异步编程</h1><blockquote><p>回调函数真正的问题在于它剥夺了我们使用return和throw这些关键字的能力。相反，我们的整个diamante流程都是基于副作用的：一个函数会附带调用其他函数。<sup>1</sup></p></blockquote><blockquote><p>并且，它会将我们通常在大部分编程语言中能获得的堆栈破坏。<sup>1</sup></p></blockquote><blockquote><p><strong><code>Primise</code>给予我们的是在我们使用异步时丢失的最重要的语言基石：<code>return</code>，<code>throw</code>以及<code>堆栈</code>。</strong><sup>1</sup></p></blockquote><a id="more"></a><h1 id="promise是什么"><a href="#promise是什么" class="headerlink" title="promise是什么"></a>promise是什么</h1><blockquote><p>promise是一种代码结构和流程<sup>1</sup></p></blockquote><blockquote><p>依照 promises 规范，一旦一个 promise 被创建，它就被执行了。<sup>1</sup></p></blockquote><h1 id="使用promise"><a href="#使用promise" class="headerlink" title="使用promise"></a>使用promise</h1><ol><li>在then()函数内部能处理的事情</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I'm inside a then() function</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以处理以下三件事<sup>1</sup>：</p><ul><li>return另外一个promise：这个用在<code>composing promises</code>写法中</li><li><p>return 一个 <strong>同步</strong> 的值(或者undefined)</p><p>下面第二个函数不需要关心<code>userAccount</code>是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个好的习惯：<strong>在then()函数内部，永远返回或抛出</strong></p></li><li><p>throw一个 <strong>同步</strong> 异常：catch()函数在捕获异常的时候，不关心异常是同步的还是异步的</p><blockquote><p>任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。</p></blockquote><p>可以 <strong>直接</strong> 使用<code>Promise.resolve</code>来进行同步或异步的封装，<code>Promise.reject()</code>同理。</p></li></ul><ol start="2"><li>永远都是往 then() 中传递函数<sup>1</sup></li></ol><p>参考:</p><ol><li><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6之后添加的日常开发用的到的新特性</title>
      <link href="/2019/04/08/new-feature/"/>
      <url>/2019/04/08/new-feature/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的新函数"><a href="#数组的新函数" class="headerlink" title="数组的新函数"></a>数组的新函数</h1><ol><li><p><code>Array.prototype.includes()</code></p><p>判断一个数组是否包含一个指定的值，包含返回<code>true</code>，否则返回<code>false</code>。</p></li><li><p><code>Array.prototype.flat()</code></p><p>这个方法按照一个可指定的深度递归遍历数组，将所有元素与遍历到的子数组中的元素合并为一个新数组返回（另外可以利用这个函数进行数组空项去除）。</p></li></ol><a id="more"></a><ol start="3"><li><p><code>Array.prototype.flatMap()</code></p><p>这个方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。</p></li></ol><h1 id="对象的新函数"><a href="#对象的新函数" class="headerlink" title="对象的新函数"></a>对象的新函数</h1><ol><li><p><code>Object.values()</code></p><p>这个方法不是定义在原型上的，返回指定对象自身属性的所有值，不包含继承的值。</p></li><li><p><code>Object.entries()</code></p><p>这个方法也没有定义在原型上，返回指定对象自身可枚举属性的键值对的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.fromEntries()</code></p><p>上一个函数的反转。</p></li></ol><h1 id="函数的新方法"><a href="#函数的新方法" class="headerlink" title="函数的新方法"></a>函数的新方法</h1><ol><li><p><code>Function.prototype.toString()</code></p><p>改进版的返回精确字符，包含空格和注释</p></li></ol><h1 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在后台面板</span></span><br><span class="line"><span class="comment">// 拿到单品id</span></span><br><span class="line"><span class="comment">// 进行单品详细信息轮寻获取的时候好像用到了类似的方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这两种方式都无法正确执行异步过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h1><p>不论是<code>resolve</code>还是<code>reject</code>最后都可以执行<code>finally</code>中的代码。</p><h1 id="新的基本累心"><a href="#新的基本累心" class="headerlink" title="新的基本累心"></a>新的基本累心</h1><ul><li>String</li><li>Number</li><li>Boolean</li><li>Nill</li><li>Undefined</li><li>Symbol</li><li><strong>BigInt</strong>：这个好像还在提案中</li></ul><p>参考:</p><ol><li><a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank" rel="noopener">https://juejin.im/post/5ca2e1935188254416288eb2</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础学习笔记</title>
      <link href="/2019/02/13/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/13/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql基础学习笔记"><a href="#mysql基础学习笔记" class="headerlink" title="mysql基础学习笔记"></a>mysql基础学习笔记</h1><p>学习视频：<a href="https://www.bilibili.com/video/av19538278?t=47&amp;p=32" target="_blank" rel="noopener">https://www.bilibili.com/video/av19538278?t=47&amp;p=32</a></p><p>视频中用到的资料：<a href="https://blog.csdn.net/qq_27229113/article/details/75206309" target="_blank" rel="noopener">https://blog.csdn.net/qq_27229113/article/details/75206309</a></p><p>这套视频详细介绍了增删改查，左连接，子查询，视图，简单介绍了事务，引擎的区别。关于这套教程的一些想法：老师是真的教得好。还会讲一些项目、字段的设计、字符集之类的话题，感觉平时自己只是随便取出数据就用来控制或是显示了，没有怎么细想过，现在感觉理解上有些不一样了，也说不好哪儿不一样，总之感觉进步了一点点。</p><p>orm vs 原生sql：</p><ol><li><a href="https://stackoverflow.com/questions/3360304/orm-vs-traditional-database-query-which-are-their-fields" target="_blank" rel="noopener">https://stackoverflow.com/questions/3360304/orm-vs-traditional-database-query-which-are-their-fields</a></li><li><a href="https://stackoverflow.com/questions/494816/using-an-orm-or-plain-sql" target="_blank" rel="noopener">https://stackoverflow.com/questions/494816/using-an-orm-or-plain-sql</a></li><li><a href="https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5" target="_blank" rel="noopener">https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5</a></li><li><a href="https://medium.com/ameykpatil/why-orm-shouldnt-be-your-best-bet-fffb66314b1b" target="_blank" rel="noopener">https://medium.com/ameykpatil/why-orm-shouldnt-be-your-best-bet-fffb66314b1b</a></li></ol><p>决定后面的练习写sql了。</p><a id="more"></a><hr><h3 id="解决乱码的办法"><a href="#解决乱码的办法" class="headerlink" title="解决乱码的办法"></a>解决乱码的办法</h3><p><code>set names gbk</code></p><h3 id="一个建表语句"><a href="#一个建表语句" class="headerlink" title="一个建表语句"></a>一个建表语句</h3><p>create table class(<br>  id int primary key auto_increment,<br>  sname varchar(10) not null default ‘’,<br>  gender char(1) not null default ‘’,<br>  company varchar(20) not null default ‘’,<br>  salary decimal(6,2) not null default 0.00,<br>  fanbu smallint not null default 0<br>) engine myisam charset utf8;</p><h3 id="增的操作"><a href="#增的操作" class="headerlink" title="增的操作"></a>增的操作</h3><ol><li>往哪张表</li><li>往哪几列</li><li>添加哪些值</li></ol><p>insert into class<br>(id,sname,gender,company,salary,fanbu)<br>values<br>(1,’张三’,’男’,’百度’,8888.67,234);</p><!-- 增多行 --><p>insert into class<br>(sname,company,salary)<br>values<br>(‘刘备’,’皇室成员’,15.28),<br>(‘孙策’,’江东集团’,56.34),<br>(‘曹操’,’宦官后裔’,88.56);</p><h3 id="删的操作"><a href="#删的操作" class="headerlink" title="删的操作"></a>删的操作</h3><p>删除就是指删除整行，不存在删除某几列</p><ol><li>删哪张表</li><li>删哪行</li></ol><p>delete from class where salary&gt;8000;</p><p>delete from class where salary&gt;8000 and gender=’女’;</p><h3 id="改的操作"><a href="#改的操作" class="headerlink" title="改的操作"></a>改的操作</h3><ol><li>改哪张表</li><li>该哪几列</li><li>改成什么值</li><li>在哪一行生效</li></ol><p>update class<br>set<br>gender=’女’,<br>company=’千度’<br>where id=2;</p><p>update class<br>set fanbu=150<br>where gender=’男’ and salary&gt;8000;</p><p>update class<br>set fanbu=100<br>where 1;</p><h3 id="查的操作"><a href="#查的操作" class="headerlink" title="查的操作"></a>查的操作</h3><ol><li>从哪张表查</li><li>查哪几列</li><li>满足哪些条件</li></ol><p>select * from class; // 查class表中的所有数据</p><p>select sname,gender from class where id&lt;5; //查class表中id&lt;5的sname和gender列</p><p>select * from class where id=3; // 从class表中查id=3的所有列</p><p>select sname,gender from class; //从class表中查sname，gender两列的所有行</p><h3 id="后面要学"><a href="#后面要学" class="headerlink" title="后面要学"></a>后面要学</h3><ol><li>如何自己建表</li><li>如何修改表（增加减少列等）</li><li>多表联查</li><li>子查询</li><li>触发器</li><li>事务</li><li>存储过程</li><li>备份恢复</li></ol><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>建表的过程就是一个 <strong>声明字段</strong> 的过程.</p><p><strong>存储同样的数据，不同的列类型所占据的空间和效率是不一样的，这就是建表前学习列类型的意义。重点学列类型的存储范围和占据的字节大小。</strong></p><p>为什么建表时，加<em>not null default ‘’/0</em>？</p><p>答：不想让表中出现null值。</p><p>为什么不想要null值？</p><p>答：1.不好比较，null是一种类型，比较时只能用专门的is null和is not null来比较，碰到运算符一律返回null；2.效率不高，不利于提高索引效果。因此 <strong>在建表时往往声明not null default 0/‘’</strong>。</p><p>比较null要用专门的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where sname is null;</span><br><span class="line">select * from test where sname is not null;</span><br></pre></td></tr></table></figure><p>mysql三大列类型</p><ul><li><p>数值型</p><ul><li><p>整型</p><ul><li>Tinyint<ul><li>占据空间：1个字节</li><li>存储范围：-128~127（0~255）</li><li>参数：(M) unsigned zerofill</li><li>默认有符号</li></ul></li><li>Smallint</li><li>Mediumint</li><li>bigint</li></ul></li><li><p>小数(浮点型、定点型)</p><ul><li>M：精度（小数所有位数）</li><li>D：标度（小数后位数）</li><li>范围：float能存10^38.10^-38</li><li>占据空间：M&lt;=24，占4个字节，否则占8个字节</li><li>定点：定点数是把整数部分和小数部分分开存储的，比float精确。float有时会损失精度，如果像银行这样的敏感字段，建议用decimal</li></ul></li></ul></li><li><p>补码规则</p></li></ul><p>计算机中的负数，不是按照后面的绝对值位乘-1得到的，而是用补码规则换算的。</p><p>负数 = 绝对值位 - 128</p><p>1111 1111 =========&gt; -1</p><p>1000 0000 =========&gt; -128</p><ul><li><p>字符串类型</p><ul><li>char：定长类型，对于char(M)，M代表宽度（占用空间，限制的是字符不是字节），0&lt;=M&lt;=255之间，表示能输M个字符，不够M个长度在尾部用空格补齐，能通过数学计算出位置。从利用率的角度，能达到100%。在存取特点上，char型如果不够M个字符，内部用空格补齐，取出时再把右侧空格删掉，这意味着如果右侧本身有空格，将会丢失。速度上定长类型快一些。</li><li>varchar：变长类型，对于varchar(M)，M代表宽度（占用空间，限制的是字符不是字节），0&lt;=M&lt;=65535(以ascii字符为例，utf8 22000左右)。varchar(100)能存0-100个字符。每个varchar前还有1-2个字符用来表示当前字符的长度，从利用率的角度，到不了100%。</li><li>Text：文本类型，可以存比较大的文本段，搜索速度稍慢。如果不是特别大的内容，建议使用char、varchar来代替。</li><li>Blob：是二进制类型，用来存储图像，音频等二进制信息。<strong>Blob在于防止因为字符集的问题，导致信息丢失。比如一张图片中有0xFF字节，这个在ascii字符集中认为非法，在入库的时候被过滤。</strong></li><li>日期类型：5.7版本的mysql的date类型不支持0为默认值，具体原因参考<a href="https://blog.csdn.net/chenshun123/article/details/79676567" target="_blank" rel="noopener">这里</a>。date类型能存储的范围是<code>1000-01-01~9999-12-31</code>。</li><li>时间类型</li><li>日期时间类型：输入格式YYYY-mm-dd HH:mm:ss。但一般使用时间戳来存储。</li><li>时间戳类型：timestamp</li><li>年份类型：year 1901-2155 255个年份+0000一个错误年份</li></ul></li></ul><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ul><li><p>新增列语法：</p><ol><li>alter table 表名 add 列名称 列类型 列参数;(加在最后)</li><li>alter table 表名 add 列名称 列类型 列参数 after 指定列;(加在指定列后面)</li><li>alter table 表名 add 列名称 列类型 列参数 first；（加在第一行）</li></ol></li><li><p>删除列语法：</p><ol><li>alter table 表名 drop 类名;</li></ol></li></ul><ul><li><p>修改列语法：</p><ol><li>alter table 表名 modify 列明 新类型 新参数;（此方法不能该表名）</li></ol></li><li><p>修改列明和列类型语法：</p><ol><li>alter table 表名 change 旧列名 新列名 新参数；</li></ol></li></ul><h3 id="查询建表语句"><a href="#查询建表语句" class="headerlink" title="查询建表语句"></a>查询建表语句</h3><p>show create table 表名;</p><h3 id="从一个表中将特定几列的数据拷入另一个表中"><a href="#从一个表中将特定几列的数据拷入另一个表中" class="headerlink" title="从一个表中将特定几列的数据拷入另一个表中"></a>从一个表中将特定几列的数据拷入另一个表中</h3><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>使用某个具体的字段来数的话，如果这个字段下某一行的值为null，使用count时，不计入数量。使用count(*)数绝对的行数。</strong></p><p><strong>用count(*)和count(1)谁好呢？</strong></p><p><strong>对于myisam引擎的表来说没有区别，这种表内部有一个计数器用来维护行数。对于Innodb引擎的表来说，用count(*)直接读行数效率很低，因为innodb真的要去数一遍</strong></p><p><em>以下查询基于<a href="https://blog.csdn.net/qq_27229113/article/details/75206309" target="_blank" rel="noopener">这里</a>的数据。</em></p><ol><li><p>基础查询 <strong>where</strong> 的练习</p><p> 1.1 主键为32的商品id、商品名称和商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods where goods_id=32;</span><br></pre></td></tr></table></figure><p> 1.2 类型不是3的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id!=3;</span><br></pre></td></tr></table></figure><p> 1.3 商城内价格高于3000块的商品的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price&gt;3000;</span><br></pre></td></tr></table></figure><p> 1.4 商城内价格低于或等于100块的商品的商品id、类型id、商品名称、商城内售价</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price&lt;=100;</span><br></pre></td></tr></table></figure><p> 1.5 查询分类为4和11的商品，不许用or</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name.shop_price from goods where cat_id in (4,11);</span><br></pre></td></tr></table></figure><p> 1.6 查询大于等于100块小于等于500块的商品，不能用逻辑与and</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where shop_price between 100 and 500;</span><br></pre></td></tr></table></figure><p> 1.7 取出不再分类为3且不在分类为11中的商品，用not in 和 and 分别实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用not in实现 --&gt;</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id not in (3,11);</span><br><span class="line"></span><br><span class="line">&lt;!-- 用and实现 --&gt;</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where cat_id != 3 and cat_id != 11;</span><br></pre></td></tr></table></figure><p> 1.8 取出价格大于100且小于300或者大于4000且小于5000的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where (shop_price&gt;100 and shop_price&lt;300) or (shop_price&gt;4000 and shop_price&lt;5000);</span><br></pre></td></tr></table></figure><p> 1.9 取出分类3下的价格小于1000或者大于3000，同时点击量大于等于5的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where (cat_id=3) and (shop_price&lt;1000 or shop_price&gt;3000) and (click&gt;=5);</span><br></pre></td></tr></table></figure><p> 1.10 查出名字以诺开头的商品</p><p> 模糊查询 关键字 <strong>like</strong></p><p> 在查询字段后加 <strong>%(百分号匹配任意个字符)</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where goods_name like &apos;诺记%&apos;;</span><br></pre></td></tr></table></figure><p> 使用 <strong>_</strong>匹配任意个单个字符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,cat_id,goods_name,shop_price from goods where goods_name like &apos;诺记__&apos;;</span><br></pre></td></tr></table></figure><p> 1.11 查出在商城中购买商品比市场价省多少钱</p><p> 将字段名字看作是变量，既然是变量就可以参与运算</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,(market_price-shop_price) as discount from goods where cat_id&gt;10;</span><br></pre></td></tr></table></figure><p> 1.12 查出本店价比市场价省的钱，而且省200以上的商品</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,(market_price-shop_price) as discount from goods where (market_price-shop_price)&gt;200;</span><br></pre></td></tr></table></figure><p> 此处where中不能使用discount是因为where是在原表中发挥作用，原表中没有discount的字段，结果表中才有discount的字段，继续筛结果表中的数据要使用 <strong>having</strong>。</p><p> 1.13 将20-19之间的数改为20,30-39之间的数改为30</p><p> 把num当成变量看，num/10取整再乘以10。。。麻的，真妥么想不到诶。。。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update cv set num=floor(num/10)*10 where num between 20 and 40;</span><br></pre></td></tr></table></figure><p> <strong>大胆的把列看成变量，参与运算，甚至调用函数来处理，常用的函数有substring()、concat（）</strong></p></li><li><p>分组 <strong>group</strong> 查询</p></li></ol><p>group by cat_id 从语义上来分析，select的列只能是cat_id/max/min/avg/sum/count()这种统计类型的列。使用select *从语义上分析就不对，严格说不符合sql标准</p><pre><code>2.1 查询出最贵的商品价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.2 查询出最便宜的商品的价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.3 查询出最小的商品id<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(goods_id) from goods;</span><br></pre></td></tr></table></figure>2.4 查询所有商品总库存量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(goods_num) from goods;</span><br></pre></td></tr></table></figure>2.5 查询所有商品的平均价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(shop_price) from goods;</span><br></pre></td></tr></table></figure>2.6 查询有多少种商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from goods;</span><br></pre></td></tr></table></figure>2.7 计算分类3下的所有商品的库存量之和<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(goods_number) from goods where cat_id=3;</span><br></pre></td></tr></table></figure>2.8 一条语句计算每个分组下的库存量之和<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(goods_number) from goods group by cat_id;</span><br></pre></td></tr></table></figure>2.9 按商品分类分组，计算每个分类下的商品的平均价格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,avg(shop_price) from goods group by cat_id;</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>having查询</p><p> sql语句的查询筛选过程：先根据where查询出满足条件的行，列和原表的列一样，得到一个中间表，再在这个中间表的基础上进行列之间的计算以及分组group，得到的结果集再通过having进行下一步的操作得到最终结果集。</p><p> 3.1 查询出每个商品积压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,shop_price * goods_number from goods;</span><br></pre></td></tr></table></figure><p> 3.2 查询该店积压的总货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(shop_price * goods_number) as sum from goods;</span><br></pre></td></tr></table></figure><p> 3.3 查询每个分类下挤压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(shop_price*goods_number) as sum from goods group by cat_id;</span><br></pre></td></tr></table></figure><p> 3.4 查询加压货款超过2万以及积压的货款</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,sum(shop_price*goods_number) as sum from goods group by cat_id having sum&gt;20000;</span><br></pre></td></tr></table></figure><p> 3.5 查询比市场价省钱200块以上的商品以及该商品省的钱</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,(market_price-shop_price) as discount from goods having discount&gt;200;</span><br></pre></td></tr></table></figure><p> 3.6 查询2门及2门以上不及格者的平均成绩</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//写错了。。。。。。</span><br><span class="line">//因为count函数不管传入的是什么都数</span><br><span class="line">select name,avg(score) as average,count(score&lt;60) as gks from result group by name having gks&gt;=2;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正确结果：利用布尔值正确返回1错误返回0 --&gt;</span><br><span class="line"></span><br><span class="line">select name,avg(score),sum(score&lt;60) as gks from result group by name having gks&gt;=2;</span><br><span class="line"></span><br><span class="line">&lt;!-- 另一种方法 --&gt;</span><br><span class="line">&lt;!-- 先筛选出名字，得到一张表，根据这张表继续筛选 --&gt;</span><br><span class="line">&lt;!-- 三层嵌套 --&gt;</span><br><span class="line"></span><br><span class="line">select name,avg(score) from result where name in (select name from (select name,count(1) as gks from result where score&lt;60 group by name having gks&gt;=2)as tmp) group by name;</span><br></pre></td></tr></table></figure></li><li><p>排序</p></li></ol><p>排序发生在得到最终的结果集（拿到原始筛选数据）之后，排序是针对最终结果集的，也就是说order要放在where/group by/having后面，顺序不能乱。</p><p>排序的语法：</p><p>order by 结果集中的列名1 desc/asc,结果集中的列名2 desc/asc (<strong>注意：这样写有排序先后，先按列名1排序，再按列名2排序</strong>)</p><pre><code>4.1 取出分类4下的商品，并按价格由高到低排序。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods where cat_id=4 order by shop_price desc;</span><br></pre></td></tr></table></figure>4.2 按分类升序排列，同一个分类下的商品，再按商品的价格降序排列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by cat_id asc,shop_price desc;</span><br></pre></td></tr></table></figure></code></pre><ol start="5"><li>limit限制条数</li></ol><p>limit用在语句的最后，起到限制条目的作用。</p><p>limit[offset,] N，其中：</p><p>offset：偏移量，如果不写，相当于0<br>N：取出条目</p><pre><code>5.1 取出本店价格最高的前三名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 0,3;</span><br></pre></td></tr></table></figure>5.2 查询本店价格最高的第三名到第五名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 2,3;</span><br></pre></td></tr></table></figure>5.3 取商品价格最高的一件商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price from goods order by shop_price desc limit 1;</span><br></pre></td></tr></table></figure></code></pre><ol start="6"><li><p>子查询</p><ol><li><p>where型子查询：将内层查询的结果作为外层查询的条件。</p><p>典型题：查询最大商品、最贵商品</p><p>如果where列=（内层sql），则内层sql返回的必是单行单列，也就是单个值<br>如果where列 in (内层sql)，则内层sql只返回单列，可以多行</p></li><li><p>from型子查询</p><p>这里插入一个重要概念</p><p><strong>查询模型</strong></p></li><li><p>列就是变量，在每一行上，列的值都在变化</p></li><li>where条件是表达式，在哪一行上表达式为真，哪一行就取出来</li><li><p>查询结果集可以当成表看</p><p>from型子查询：内层sql的查询结果，当成一张临时表，供外层sql再次查询。</p></li><li><p>exists型子查询</p><p>exists型子查询：把外层sql的结果拿到内层sql去测试，如果内层sql成立，则该行被取出。</p></li></ol></li></ol><p>练习题</p><pre><code>6.1 查询出每个分类下id号最大的一条商品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅想出这种嵌套的方法 --&gt;</span><br><span class="line">select goods_id,goods_name,cat_id from goods where goods_id in (select max(goods_id) from goods group by cat_id) order by cat_id asc;</span><br></pre></td></tr></table></figure>6.2 查出本店最新的商品，要求不用排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name from goods where goods_id=(select max(goods_id) from goods);</span><br><span class="line"></span><br><span class="line">&lt;!-- select max(goods_id) from goods 这条语句返回的就是最大值 --&gt;</span><br></pre></td></tr></table></figure>6.3 查出有商品的分类号和分类名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cat_id,cat_name from category where exists (select * from goods where goods.cat_id=category.cat_id);</span><br></pre></td></tr></table></figure></code></pre><h3 id="表与集合的关系"><a href="#表与集合的关系" class="headerlink" title="表与集合的关系"></a>表与集合的关系</h3><p>一张表就是一个集合</p><p>每一行就是一个元素</p><p>在数据库中，用 <strong>,(逗号)</strong>将两个表名隔开即可完成两张表笛卡尔积查询</p><p>比如查询商品表和分类表，得到商品名称、库存、价格和分类名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,cat_name from goods,category where goods.cat_id=category.cat_id;</span><br></pre></td></tr></table></figure><p>但是这样做效率低。</p><p><em>两张表全相乘，比如A表10000行数据，B表10000万行数据，都不算大，但是两表全相乘，在内存中生成一个非常大的数据。10000\</em>10000行。另外索引没用上。*</p><p>先记下来：<strong>两张表联查之后没有索引</strong></p><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><p>假设A表在左，不动，B表在A表的右边滑动，A表与B表通过一个关系来筛选B表的行。</p><p>语法：</p><p><strong>A left join B on 条件</strong>，条件为真，则B表对应的行取出。</p><p><strong>A left join B on 条件</strong>这个部分形成的也是一个结果集，可以看成一张表，设为c。既如此，可以对c表进行查询，where\group\having\order by\limit照常可以使用。同样，C看成表之后还可以继续和其他表进行左连接。</p><p><strong>直接使用上面的语句会报语法错误诶…貌似5.7版本不能单独使用，和select一块儿使用就可以通过…</strong></p><p>问：C表可以查询的列有哪些？<br>答：AB两表的列都可以查询。</p><p>练习：</p><ol><li><p>取出第4个分类下的商品以及商品的分类名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select goods_id,goods_name,shop_price,cat_name from (goods left join category on goods.cat_id = category.cat_id) where goods.cat_id = 4;</span><br></pre></td></tr></table></figure></li></ol><ul><li>左连接、右连接、内连接的区别</li></ul><p>左右连接可以互换</p><p>A left join B &lt;=&gt; B right join A</p><p><em>注意：既然左右连接可以互换，尽量用左连接，处于移植时兼容性方面的考虑。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select boy.*,girl.* from boy inner join girl on boy.other = girl.other;</span><br></pre></td></tr></table></figure><p>从集合的角度看，内连接是左右连接的交集。</p><p><em>外连接是左右连接的并集，但是在mysql中不支持外连接。</em></p><p>作业题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表结构 --&gt;</span><br><span class="line"></span><br><span class="line">Match 赛程表</span><br><span class="line">字段名称字段类型描述</span><br><span class="line">matchIDint主键</span><br><span class="line">hostTeamIDint主队的ID</span><br><span class="line">guestTeamIDint客队的ID</span><br><span class="line">matchResultvarchar(20)比赛结果，如（2:0）</span><br><span class="line">matchTimedate比赛开始时间</span><br><span class="line"></span><br><span class="line">Team 参赛队伍表</span><br><span class="line">字段名称字段类型描述</span><br><span class="line">teamIDint主键</span><br><span class="line">teamNamevarchar(20)队伍名称</span><br><span class="line"></span><br><span class="line">&lt;!-- 表数据 --&gt;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from m;</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">| mid | hid | gid | mres | matime |</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">| 1 | 1 | 2 | 2:0 | 2006-05-21 |</span><br><span class="line">| 2 | 2 | 3 | 1:2 | 2006-06-21 |</span><br><span class="line">| 3 | 3 | 1 | 2:5 | 2006-06-25 |</span><br><span class="line">| 4 | 2 | 1 | 3:2 | 2006-07-21 |</span><br><span class="line">+-----+------+------+------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+------+----------+</span><br><span class="line">| tid | tname |</span><br><span class="line">+------+----------+</span><br><span class="line">| 1 | 国安 |</span><br><span class="line">| 2 | 申花 |</span><br><span class="line">| 3 | 传智联队 |</span><br><span class="line">+------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">&lt;!-- 查出 2006-6-1 到2006-7-1之间举行的所有比赛，并且用以下形式列出：</span><br><span class="line">拜仁 2：0 不来梅 2006-6-21 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 想出的答案 --&gt;</span><br><span class="line"></span><br><span class="line">select team.teamName,matchResult,tmpTeam.teamName,matchTime from ((matchResult left join team on hostTeamId=teamId) left join team as tmpTeam on guestTeamId=tmpTeam.teamId) where matchTime between &apos;2006-06-01&apos; and &apos;2006-07-01&apos;;</span><br><span class="line"></span><br><span class="line">+--------------+-------------+--------------+------------+</span><br><span class="line">| teamName     | matchResult | teamName     | matchTime  |</span><br><span class="line">+--------------+-------------+--------------+------------+</span><br><span class="line">| 申花         | 1:2         | 传智联队     | 2006-06-21 |</span><br><span class="line">| 传智联队     | 2:5         | 国安         | 2006-06-25 |</span><br><span class="line">+--------------+-------------+--------------+------------+</span><br></pre></td></tr></table></figure><p><em>注意：要把第二次左连接用到的team表名起一个别名，否则会报错。</em></p><p><em>注意：match是mysql的关键字。</em></p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>合并2条或多条语句的结果。</p><p>语法：sql1 union sql2</p><p>问：内否从2张表查询完再union呢？<br>答：可以，union合并的是“结果集”，不区分在哪一张表。</p><p>问：取自于2张表，通过别名让2个结果集的列一致，如果取出的结果集，列名字不一样，还能否union？<br>答：可以，以第一张表的列名为准。</p><p>问：union满足什么条件就可以用了？<br>答：只要结果集中的列数一致就可以。</p><p>问：列的类型不一致也可以嘛？<br>答：见上题。</p><p>问：union后的结果集可否再排序呢？<br>答：可以。</p><p>问：使用union语句时，内层的排序有时发挥效果有时不发挥效果，这是问什么？<br>答：内层的order by语句单独使用时，不影响结果集，仅排序，在执行期间就被mysql的代码分析器给优化掉了，内层的order by必须能够影响结果集时才有意义，比如配合limit使用。</p><p>问：如果union后的结果有重复（即某2行或n行的值都一样），怎么办？<br>答：这种情况是比较常见的默认会去重。</p><p>问：如果不想去重怎么办？<br>答：union all</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如果mysql函数和javascript函数都实现某个功能，优先使用哪一个？</p><ol><li><p>mysql的函数肯定是要影响查询速度。应该在建表时通过合理的表结构减少函数的使用合理的表结构减少函数的使用；</p></li><li><p>如果确实要使用函数，比如时间的格式化，优先放在业务逻辑层，即用javascript处理；</p></li><li><p>在查询时使用了函数，最大的一个坏处是索引无法使用，比如date_format(A)，则A列的索引将无法使用。在where函数中，使用了索引，where查询的是函数处理后的条件，索引失效。</p></li></ol><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图View可以看成一张虚拟表，是表通过某种运算得到的一个投影，表的变化会影响到视图。</p><p>视图的定义一直存在，但不占用空间。</p><p>对于一些简单的视图，它在发挥作用的过程中，并没有建立临时表，而只是把条件存起来，下次查询，把条件一合并，直接去查表。</p><p>问：建视图的时候要指定视图的列名与列类型么？<br>答：不要，它只是一个投影，是一种关系，会继承原表的字段。</p><ul><li>创建视图的语法</li></ul><p>既然视图只是表的某种查询的投影，所以主要步骤在于查询表上，查询的结果命名为视图就可以了。</p><p><strong>create view 视图名字 as select语句</strong></p><ul><li><p>视图有什么用</p><ol><li>可以简化查询；</li><li>可以更精细的权限控制，比如某张用户表，2个网站搞合作，可以查询对方网站的用户，需要向对方开放用户表的权限，但是又不想开放用户表中的密码字段，可以使用视图；</li><li>数据多，分表时可以用到。比如小说站，article表，1000万篇，分成article1、article2…article5，查询小说时，不知道在哪张表上，可以创建一个五张表合在一起的视图一次型查出。</li></ol></li><li><p>表与视图数据变化时的相互影响问题</p><ol><li>表的数据变化，视图跟着变</li><li>视图的数据发生变化时，满足视图的数据和表的数据一一对应，类似函数和反函数的关系时，会影响到原表</li></ol></li></ul><p><em>注意：一一对应指的是根据select关系，从表中取出的行，只能计算出视图中确定的一行，反之，视图中任意抽一行，能够反推出表中确定的一行</em><br><em>注意：order by limit得到的结果与表不是一一对应的</em></p><ul><li>删除视图</li></ul><p><code>drop view 表名</code></p><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><ul><li><p>视图合并查询条件 vs 临时表</p><ol><li><p>如果将创建的视图看作临时表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp = select * from godds where shop_price &gt; 300;</span><br><span class="line">select * from tmp where shop_price &lt; 500;</span><br></pre></td></tr></table></figure></li><li><p>如果没有临时表，查这个视图，还有没有可能完成</p><p>可以。查原表，把建视图时的条件和查询视图的条件叠加起来，直接去查原表。</p></li></ol></li><li><p>这两种方式哪个快</p><ol><li>建表：查询=&gt;形成临时表=&gt;查询临时表</li><li>叠加：合并条件=&gt;查询表</li></ol></li><li><p>到底是创建临时表还是合并语句，就由algorithm来决定，当它的值为：</p><ol><li>merge：合并查询语句</li><li>temptable：临时表</li><li><p>undefined：未定义，由系统判断</p><p>合并条件的视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create algorithm=merge view v2</span><br><span class="line">as</span><br><span class="line">select * from goods where shop_price&gt;300;</span><br></pre></td></tr></table></figure><p>建临时表的视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 复杂查询 --&gt;</span><br><span class="line">&lt;!-- 比如建立平均价格视图 --&gt;</span><br><span class="line">create algorithm=temptable view v3</span><br><span class="line">as</span><br><span class="line">select goods_id,cat_id,goods_name,shop_price</span><br><span class="line">from goods</span><br><span class="line">order by cat_id asc,shop_price desc;</span><br></pre></td></tr></table></figure><p>由系统来决定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果拿不准就写algorithm=undefined，由系统来决定</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>字符集的概念</li></ul><p>2进制编码到字符的映射就是字符集。</p><ul><li>一些字符集</li></ul><p>ascii、ansi、gb2312、gbk、unicode、utf-8。</p><p>从容量上来看：GB2312&lt;GBK&lt;UTF-8</p><ul><li>unicode和utf-8的关系</li></ul><p>unicode用4个字节来编号，有2^32种组合。</p><p>unicode只负责分配编号，而且都是用4个字节来分配编号。</p><p>utf-8在不改变编号的基础上简化字节，把高位浪费的0值，用一定的规则舍弃。</p><p><strong>unicode和utf-8的关系就像源文件和压缩文件的关系。由给定的unicode字符可=&gt;utf-8的二进制值，反过来，由utf-8的二进制值=&gt;unicode字符。</strong></p><ul><li>utf8的长度</li></ul><p>变长，否则压缩就没有意义了。</p><ul><li>如何截取utf8（各国语言都有），无乱码？</li></ul><p>从头开始，取1个字节。通过位运算，计算连续的1的个数。如果为0，则截取1个字节，如果为N，则截取N个字节。</p><ul><li>GBK是如何转为UTF-8的？</li></ul><p>GBK也是和unicode有对应关系的，GBK=&gt;unicode=&gt;utf8。</p><ul><li><p>乱码原因</p><ol><li>可修复的情况：解码时与实际编码不一致</li><li>不可修复的情况：传输过程中，编码不一致，导致字节丢失</li></ol></li><li><p>客户端和服务器端的编码转换</p></li></ul><p>客户端与服务器之间存在一个 <strong>连接器</strong>。客户端的字符先发给连接器，连接器选择一种编码将其转换，临时存储，之后再次转换成服务器需要的编码，并最终存储在服务器。</p><p>告诉连接器客户端使用GBK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_client=gbk;</span><br></pre></td></tr></table></figure><p>告诉连接器使用utf8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_connection=utf8;</span><br></pre></td></tr></table></figure><p>告诉连接器如果返回值，返回GBK结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set character_set_results=gbk;</span><br></pre></td></tr></table></figure><p>如果上面三个参数都设置成GBK，可以简写，简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set names gbk;</span><br></pre></td></tr></table></figure><ul><li>使用上面三个设置的一个基本原则</li></ul><p>服务器字符集容量 &gt;= 连接器字符集容量 &gt;= 客户端字符集容量</p><ul><li><p>保证下面三者字符集的一直就绝不会出现乱码的可能</p><ol><li>网页文件本身编码</li><li>meta信息</li><li>client/connection/results的指定</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator函数初步学习</title>
      <link href="/2019/01/06/2019-1-6-generator/"/>
      <url>/2019/01/06/2019-1-6-generator/</url>
      
        <content type="html"><![CDATA[<p>看了许多材料后，感觉下面这三篇文章对于理解generator函数有非常大的帮助，囊括了常见用法、控制流程、循环操作等，理解的程度已经基本能满足现在的需求。</p><ol><li><a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">https://davidwalsh.name/es6-generators</a></li><li><a href="https://davidwalsh.name/es6-generators-dive" target="_blank" rel="noopener">https://davidwalsh.name/es6-generators-dive</a></li><li><a href="https://davidwalsh.name/async-generators" target="_blank" rel="noopener">https://davidwalsh.name/async-generators</a></li></ol><p>下面的内容为阅读材料时随手做的笔记，未经过整理。</p><a id="more"></a><h2 id="关于generator函数的基本概念"><a href="#关于generator函数的基本概念" class="headerlink" title="关于generator函数的基本概念"></a>关于generator函数的基本概念</h2><p><a href="https://davidwalsh.name/es6-generators" target="_blank" rel="noopener">这篇</a>文章描述generator使用了<code>...so powerful for the future of JS.</code>。</p><p>万万没想到！之前对generator的认知仅停留在是个新的函数种类，没想到这里厉害。</p><p>到目前已经遇到两种衍生的技术了：</p><ol><li><p>async函数</p></li><li><p>saga结合成的redux-saga。</p></li></ol><p>原文：</p><blockquote><p>If you ‘ve ever read anything about concurrency or threaded programming, you may have seen the term ‘cooperative’, which basically indicates that a process(in our case, a function) itself chooses when it will allow an interruption, so that it can cooperate with other code. This concept is contrasted with ‘preemptive’, which suggests that a process/function could be interrupted against its will.</p></blockquote><p>就是说，并行编程有两种，在一段程序运行的时候可以被打断，执行另一段程序，主动打断的称为 <strong>cooperative</strong>，被动打断的称为 <strong>preemptive</strong>。Generator函数就是前者，它通过<code>yield</code>关键字，从generator函数内部打断执行过程，需要从外部恢复执行。</p><p>Generator函数并不仅仅是简单的打断、启动这种流程控制，它还允许向generator函数的内部和外部进行双向的数据传递。</p><h3 id="创建iterator"><a href="#创建iterator" class="headerlink" title="创建iterator"></a>创建iterator</h3><p>调用一个generator函数便会创建一个iterator，并且创建的过程并不会执行generator函数中的内容。</p><h2 id="关于generator的工作流程"><a href="#关于generator的工作流程" class="headerlink" title="关于generator的工作流程"></a>关于generator的工作流程</h2><p>以下内容出自<a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">此处</a>。</p><ol><li>Advancing the Generator</li></ol><p>使用next()函数</p><ol start="2"><li>Pass a Value To the Iterator</li></ol><p>在function*函数中使用yield关键字</p><ol start="3"><li>Receive a Value From the Iterator</li></ol><p>yield keyword can receive a value back from the iterator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line"></span><br><span class="line">iterator.next(<span class="string">'foo'</span>);</span><br><span class="line">iterator.next(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>好奇怪，为啥执行第一个next不输出<code>foo</code>，而是将这个值丢弃？</p><ol start="4"><li>内部执行顺序</li></ol><p>执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo, f;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'yield 1'</span>, <span class="keyword">yield</span> <span class="string">'A'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 2'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'yield 2'</span>, <span class="keyword">yield</span> <span class="string">'B'</span>);</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">'generator 3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'b'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'c'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'tick 4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="string">'d'</span>));</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tick <span class="number">1</span></span><br><span class="line">generator <span class="number">1</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">'A'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">tick <span class="number">2</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">1</span> b</span><br><span class="line">generator <span class="number">2</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="string">'B'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">tick <span class="number">3</span></span><br><span class="line"><span class="keyword">yield</span> <span class="number">2</span> c</span><br><span class="line">generator <span class="number">3</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">tick <span class="number">4</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用<code>for...of...</code>循环</li></ol><p>准则：</p><ol><li>The iteration will continue as long as done property is false.</li><li>The for..of loop cannot be used in cases where you need to pass in values to the generator steps.</li><li>The for..of loop will throw away the return value.</li></ol><ol start="6"><li>委托yield</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">  <span class="keyword">yield</span> * bar();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">yield</span> * baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>委托一个generator到另一个generator相当于将目标generator的函数体导入到目的generator中，<br>相当于下面这种代码形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><ol start="7"><li>用yield控制异步流程</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">name, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(name);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">method, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    args.push(callback);</span><br><span class="line">    <span class="keyword">return</span> method.apply(&#123;&#125;, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controller = <span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = generator();</span><br><span class="line">  <span class="keyword">const</span> advancer = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    state = iterator.next(response);</span><br><span class="line">    <span class="keyword">if</span> (!state.done) &#123;</span><br><span class="line">      state.value(advancer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  advancer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controller(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> curry(foo, <span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> curry(foo, <span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> curry(foo, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="8"><li>带错误处理的yield异步流程控制</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">parameters, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    callback(parameters);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">method, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    args.push(callback);</span><br><span class="line">    <span class="keyword">return</span> method.apply(&#123;&#125;, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controller = <span class="function">(<span class="params">generator</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> iterator = generator();</span><br><span class="line">  <span class="keyword">const</span> advancer = <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; response.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> iterator.throw(response.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = iterator.next(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.done) &#123;</span><br><span class="line">      state.value(advancer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  advancer();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">controller(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a, b, c;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a = <span class="keyword">yield</span> curry(foo, <span class="string">'a'</span>);</span><br><span class="line">    b = <span class="keyword">yield</span> curry(foo, &#123;<span class="attr">error</span>: <span class="string">'Something went wrong.'</span>&#125;);</span><br><span class="line">    c = <span class="keyword">yield</span> curry(foo, <span class="string">'c'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="generator的一个理解角度"><a href="#generator的一个理解角度" class="headerlink" title="generator的一个理解角度"></a>generator的一个理解角度</h2><p>以下部分出自<a href="https://goshakkk.name/javascript-generators-understanding-sample-use-cases/" target="_blank" rel="noopener">此处</a></p><p>翻译其中的understanding部分：</p><p>当一个函数被调用，其中的命令会一个接一个的按顺序执行，函数能够通过<code>return</code>将一些值传给它的调用者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">regular</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doA();</span><br><span class="line">  doB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>generators</code>的出现能够像对待一个<code>program</code>一样对待一个函数。</strong>这个函数能够根据你定义的规则执行。所以我们可以将这个<code>generator</code>函数成为一个<code>program</code>。</p><p>为了执行一个<code>program</code>，我们需要一个<code>interpreter</code>，这个<code>interpreter</code>将“take the program in and run it”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interpreter(<span class="function"><span class="keyword">function</span>* <span class="title">program</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>yield</code>命令告诉一个<code>program</code>跳出generator调到<code>interpreter</code>中。<code>program</code>和<code>interpreter</code>的交流是双向的：</p><ol><li><code>program</code>可以向<code>interpreter</code>发送一些东西</li><li><code>interpreter</code>也可以向<code>program</code>返回一些东西</li></ol><p>基于上面的描述，可以从下面的角度描述下面这行代码：</p><p><code>const a = yield b;</code>这行代码表示了我们如何发送一个命令b到<code>interpreter</code>然后把它的结果给a。<code>generator</code>函数将会暂停，直到<code>interpreter</code>告诉它才会继续执行后面的代码。</p><p>从redux-saga的角度阐述这个概念。</p><p>redux-saga没有将<code>side-effect</code>分散进多个action creator 和 reducer中，而是按逻辑组合多个片段行为，这个组合体被成为一个<strong>saga</strong>。</p><p>redux-saga中的<code>helper</code>函数，相当于在翻译<code>command</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">welcomeSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> take(<span class="string">'REGISTRATION_FINISHED'</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(showWelcomePopup());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(welcomeSaga);</span><br></pre></td></tr></table></figure><p>sagaMiddleware感觉就是一个interpreter。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dva初步学习</title>
      <link href="/2018/12/17/dva%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/17/dva%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>这篇博客摘自<a href="https://dvajs.com/guide/" target="_blank" rel="noopener">此处</a>，是从方便自己理解的角度整理了下。</p><h3 id="Dva的本质"><a href="#Dva的本质" class="headerlink" title="Dva的本质"></a>Dva的本质</h3><p>Dva = React-Router + Redux + Redux-saga</p><a id="more"></a><h3 id="Dva中的数据流向"><a href="#Dva中的数据流向" class="headerlink" title="Dva中的数据流向"></a>Dva中的数据流向</h3><p>数据的改变通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候，可以通过<code>dispatch</code>发起一个action，如果是同步行为会直接通过<code>reducers</code>改变<code>State</code>，如果是异步行为（副作用）会先触发<code>Effects</code>然后流向<code>Reducers</code>最终改变<code>State</code>。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>state操作的时候每次都要当做不可变数据来对待，保证每次都是全新的对象，没有引用关系，这样才能保证State的独立性，便于测试和追踪变化。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><h3 id="dispatch函数"><a href="#dispatch函数" class="headerlink" title="dispatch函数"></a>dispatch函数</h3><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>这个函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。感觉这也是Reducer名字的来源。  </p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>这个要好好看看，对这个不太熟悉。</p><p>Effect是一个Generator函数，内部使用yield关键字，标识每一步的操作。</p><blockquote><p>Effect被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。</p></blockquote><blockquote><p>dva为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而键effects转为纯函数</p></blockquote><p>后面要学的东西：</p><ol><li>redux-sagas</li><li><del>generator-将异步转为同步写法</del></li><li>纯函数好像是个<a href="https://github.com/MostlyAdequate/mostly-adequate-guide" target="_blank" rel="noopener">狼人</a></li></ol><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>Subscription语义是订阅，用于订阅一个数据源，然后根据条件dispatch需要的action。数据源可以是当前的时间、服务器的websocket连接、keyboard输入、geolocation变化、history路由变化等。</p><p>给了一个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> key form <span class="string">'keymaster'</span>;</span><br><span class="line"></span><br><span class="line">add.model(&#123;</span><br><span class="line">  namespace: <span class="string">'count'</span>,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    keyEvent(&#123;dispatch&#125;) &#123;</span><br><span class="line">      key(<span class="string">'ctrl+up'</span>, () =&gt; &#123;dispatch(&#123;<span class="attr">type</span>: <span class="string">'add'</span>&#125;)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>dva实例提供了router方法来控制路由，使用的是react-router。</p><h3 id="Route-Components"><a href="#Route-Components" class="headerlink" title="Route Components"></a>Route Components</h3><p>在Dva中，我们将Container Components约束为Route Components，因为在Dva中，我么通常以页面维度来设计Container Components。</p><p>所以在Dva中，通常需要connect Mode的组件都是Router Components，组织在<code>/routes/</code>目录下，而<code>/components/</code>目录下则是纯组件。</p><h3 id="dva的结构"><a href="#dva的结构" class="headerlink" title="dva的结构"></a>dva的结构</h3><p><a href="https://dvajs.com/guide/introduce-class.html#dva-%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E7%AE%80%E7%BB%93%E6%9E%84%EF%BC%88%E5%B8%A6-model" target="_blank" rel="noopener">见这里</a></p><ol><li>创建应用</li><li>注册Model</li><li>注册视图</li><li>启动应用</li></ol><h3 id="关于Model对象"><a href="#关于Model对象" class="headerlink" title="关于Model对象"></a>关于Model对象</h3><ol><li><p>所有的应用逻辑都定义在app.model这个对象上面</p></li><li><p>Model对象的属性</p><ul><li>namespace：当前Model的名称，整个应用的state，由多个小的Model的state以namespace为key合成</li><li>state：该Model当前的状态。数据保存在这里，直接决定了视图层的输出</li><li>reducers：Action处理器，处理同步动作，用来算出最新的state</li><li>effects：Action处理器，处理异步动作</li></ul></li></ol><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">参考MDN</a></p><blockquote><p>Calling a generator function does not execute its body immediately; an iterator object for the function is returned instead. When the iterator’s next() method is called, the generator function’s body is executed until the first yield expression, which specifies the value to be returned from the iterator or, with yield*, delefates to another generator function. The next() method returns an object with a value property containing the yielded value and a done property which indicates whether the generator has yielded its last value as a boolean. Calling the next() method with an argument will resume the generator function execution, replacing the yield expression where execution was paused with the arguments from next().</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Dva </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React纯组件</title>
      <link href="/2018/12/17/pure-component/"/>
      <url>/2018/12/17/pure-component/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">https://reactjs.org/docs/react-api.html#reactpurecomponent</a></li><li><a href="https://segmentfault.com/a/1190000014979065" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014979065</a></li><li><a href="https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs" target="_blank" rel="noopener">https://www.zcfy.cc/article/why-and-how-to-use-purecomponent-in-react-js-60devs</a></li><li><a href="https://juejin.im/post/5b1caceb5188257d63226743" target="_blank" rel="noopener">https://juejin.im/post/5b1caceb5188257d63226743</a></li></ol><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>React为了提升性能，产生了纯组件。纯组件的子组件也是纯组件。</p><p>关于纯组件自己的理解：类似于纯函数，只要是一样的state和props，就必定是同样的结果，可以不用再render，直接使用上次的结果。</p><p><code>React.PureComponent</code>通过减少应用中的渲染次数提升性能可以避免手写检查代码。</p><p>纯组件忽略重新渲染时，会影响它和它的所有子元素，所以出组件的最佳使用场景就是展示组件，既没有子组件，也没有依赖应用的全局状态。</p><p>解决纯组件的初始化问题：</p><ol><li>default Props</li><li>向子组件中传入的函数传引用，而不是函数本身，否则会重新创建函数对象</li></ol><p>不要在render中创建一个新函数或对象或方法。任何包含子元素的组件，shallowEqual检查总会返回false。</p><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><p>这个要补充一下</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async函数使用方法</title>
      <link href="/2018/12/15/async%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/15/async%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Simple_example" target="_blank" rel="noopener">MDN的一个使用实例，有讲顺序启动，并行启动之类的常用方法，其他的感觉讲的不如下面的资料清楚</a></p></li><li><p><a href="http://exploringjs.com/es2016-es2017/ch_async-functions.html" target="_blank" rel="noopener">自己写的这篇博客里说到的主要概念和理解都出自这篇材料，写的很好</a></p></li><li><p><a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c" target="_blank" rel="noopener">这篇材料讲述了避免async/await hell的一个主要解决途径就是分离启动promise和resolve promise这两个过程</a></p></li></ol><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li><p>描述了涉及async函数的主要概念，包括：</p><ul><li>async函数的返回值Promise对象的创建工作过程</li><li>await操作符的作用</li><li>async函数中return和await的区别</li></ul></li><li><p>描述了顺序启动和并行启动的方法</p></li><li>描述了是否使用await的区别</li></ol><h2 id="有待补充和学习的"><a href="#有待补充和学习的" class="headerlink" title="有待补充和学习的"></a>有待补充和学习的</h2><ol><li>async的原理</li><li>async函数的一些复杂的使用场景</li><li>其他异步执行方法，promise、yield的深入理解</li></ol><h2 id="对async函数使用的理解"><a href="#对async函数使用的理解" class="headerlink" title="对async函数使用的理解"></a>对async函数使用的理解</h2><ol><li>局限在async函数内部，利用await</li><li>利用async函数的返回值promise对象</li></ol><h2 id="async函数是如何工作的"><a href="#async函数是如何工作的" class="headerlink" title="async函数是如何工作的"></a>async函数是如何工作的</h2><ol><li><p>The result of an async function is always a Promise p. That Promise is created when starting the execution of the async function.</p></li><li><p>The body is executed. Execution may finish permanently via return or throw. Or it may finish temporarily via await, in which case execution will usually continue later on.</p></li><li><p>The Promise p is returned.</p></li></ol><p>When executing the body of the async function, <code>return x resolves the Promise p with x</code>, while throw err rejects p with err.</p><h2 id="await的本质"><a href="#await的本质" class="headerlink" title="await的本质"></a>await的本质</h2><p>waiting for a Promsie to be settled.</p><ol><li><p>if the Promise is fulfilled, the result of await is the fulfillment value（也就是说，此刻的结果是普通的值，而不是一个promsie对象， 比如下面的示例：）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">  <span class="built_in">console</span>.log(reuslt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个函数完全等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> otherAsyncFunc()</span><br><span class="line">  .then(<span class="function"><span class="params">reuslt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If the promise is rejected， await throws the rejection value。这个同样有两种处理方式，一种是在async函数内部使用try…catch来解决，另一种是传到async函数外，使用catch来解决。</p></li><li><p>await后面是个常数，则会以这种形式返回返回值：<code>Promise.resolve(value)</code></p></li></ol><h2 id="async函数中的return"><a href="#async函数中的return" class="headerlink" title="async函数中的return"></a>async函数中的return</h2><p>Resolving a Promise is a standard operation. return uses it to resolve the Promise p of an async function.</p><ol><li><p>Returning a non-Promise value fulfills p with that value</p></li><li><p>Returning a Promise means that p now mirrors the state of that Promise</p></li></ol><h2 id="是否使用await"><a href="#是否使用await" class="headerlink" title="是否使用await"></a>是否使用await</h2><ol><li><p>在返回语句中不使用await</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数的返回值使用的是上面第二种情况</span></span><br><span class="line"><span class="comment">// 效率高</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在返回语句中使用await</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个函数的返回语句中会发生先解包（await解包），在包装（return 会再次包装成Promise.resolve的过程）</span></span><br><span class="line"><span class="comment">// 效率低</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> anotherAsyncFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="async函数使用的几种场景（出自上述参考资料1）"><a href="#async函数使用的几种场景（出自上述参考资料1）" class="headerlink" title="async函数使用的几种场景（出自上述参考资料1）"></a>async函数使用的几种场景（出自上述参考资料1）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolveAfter2Seconds = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"starting slow promise"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"slow promise is done"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resolveAfter1Second = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"starting fast promise"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fast promise is done"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sequentialStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==SEQUENTIAL START=='</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.</span></span><br><span class="line">  <span class="keyword">const</span> slow = <span class="keyword">await</span> resolveAfter2Seconds();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fast = <span class="keyword">await</span> resolveAfter1Second();</span><br><span class="line">  <span class="built_in">console</span>.log(slow);</span><br><span class="line">  <span class="built_in">console</span>.log(fast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==CONCURRENT START with await=='</span>);</span><br><span class="line">  <span class="keyword">const</span> slow = resolveAfter2Seconds(); <span class="comment">// starts timer immediately</span></span><br><span class="line">  <span class="keyword">const</span> fast = resolveAfter1Second();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> slow);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> fast); <span class="comment">// waits for slow to finish, even though fast is already done!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stillConcurrent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==CONCURRENT START with Promise.all=='</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.all([resolveAfter2Seconds(), resolveAfter1Second()]).then(<span class="function">(<span class="params">messages</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(messages[<span class="number">0</span>]); <span class="comment">// slow</span></span><br><span class="line">    <span class="built_in">console</span>.log(messages[<span class="number">1</span>]); <span class="comment">// fast</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parallel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==PARALLEL with Promise.then=='</span>);</span><br><span class="line">  resolveAfter2Seconds().then(<span class="function">(<span class="params">message</span>)=&gt;</span><span class="built_in">console</span>.log(message));</span><br><span class="line">  resolveAfter1Second().then(<span class="function">(<span class="params">message</span>)=&gt;</span><span class="built_in">console</span>.log(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/2018/11/11/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
      <url>/2018/11/11/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><ul><li>姓名：杨胤</li><li>本科：<strong>北京工业大学(211)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水务工程</li><li>研究生：<strong>北京工业大学(211)</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;市政工程（<strong>保送</strong>） </li><li>技术博客：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a></li><li>github账号：<a href="https://github.com/ginnko" target="_blank" rel="noopener">https://github.com/ginnko</a></li></ul><a id="more"></a><hr><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p><strong>2017.10 ~ 现在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端开发工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同方有云科技有限公司</strong></p><ul><li>负责公司官网的前端开发和维护(<a href="https://www.tfcloud.com/" target="_blank" rel="noopener">https://www.tfcloud.com/</a>)</li><li>负责公司技术文档模板的开发和维护（使用sphinx，<a href="https://github.com/ginnko/sphinx_rtd_theme" target="_blank" rel="noopener">https://github.com/ginnko/sphinx_rtd_theme</a> ）</li><li>负责公司云服务产品（UOS）面板的开发和维护</li><li>负责公司云存储产品（UDS）面板的开发和维护</li><li>负责公司裸机管理产品（UBS）面板的开发和维护</li><li>负责公司内部组件库的维护</li></ul><p>2015.8 ~ 2017.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;市政设计工程师&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;北京市政设计研究总院有限公司 </p><hr><h3 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h3><p>掌握： html、css、javascript、React、Ant Design</p><p>熟悉： git、Redux、React-router、Bootstrap、less、sphinx</p><p>了解： webpack、gulp、echarts、jQuery、ejs、Jekyll、css-sprites、Sass、D3、Vue</p><hr><h3 id="主要技术学习"><a href="#主要技术学习" class="headerlink" title="主要技术学习"></a>主要技术学习</h3><ul><li><p>javascript</p><ul><li>读过的书：《Javascript权威指南》、《JavaScript高级程序设计》、《Javascript模式》、《你不知道的Javascript》、《Javascript设计模式与开发实践》、《JavaScript DOM编程艺术》、《ECMAScript 6 入门》（笔记：<a href="https://github.com/ginnko/memos" target="_blank" rel="noopener">https://github.com/ginnko/memos</a> ）</li><li>教程：MDN教程（笔记：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a> ），相关技术文章和博客</li><li>学习过的源码：underscore（笔记：<a href="https://github.com/ginnko/learn-javascript-via-underscore" target="_blank" rel="noopener">https://github.com/ginnko/learn-javascript-via-underscore</a> ）</li><li>目前在看：《33个javascript核心概念》</li></ul></li><li><p>css</p><ul><li>读过的书：《HTML &amp; CSS设计与构建网站》、《CSS设计指南》、《CSS权威指南》、《精通CSS-高级Web标准解决方案》</li><li>教程：MDN教程（笔记：<a href="https://ginnko.github.io/">https://ginnko.github.io/</a> ），相关技术文章和博客</li></ul></li><li><p>网络</p><ul><li>读过的书：《图解http》、《网络是怎样连接的》（笔记：<a href="https://github.com/ginnko/memos" target="_blank" rel="noopener">https://github.com/ginnko/memos</a> ）</li><li>教程：MDN教程</li><li>辅助工具：httpie</li></ul></li><li><p>React  </p><ul><li>读过的书：《React学习之路》、《React小书》、《React设计模式》、React官方文档</li><li>教程：相关技术文章和博客</li><li>DIY React：模拟一个简单的React库（笔记：<a href="https://github.com/ginnko/learn-react-via-diy" target="_blank" rel="noopener">https://github.com/ginnko/learn-react-via-diy</a> ）</li><li>目前在看：React16之后版本的内部运行机制（笔记：<a href="https://github.com/ginnko/learn-react-via-diy" target="_blank" rel="noopener">https://github.com/ginnko/learn-react-inner-workings</a> ）</li></ul></li><li><p>Redux</p><ul><li>读过的书：《React小书》、Redux官方文档和教程</li><li>教程：相关技术文章和博客</li><li>DIY Redux：《React小书》 (笔记：<a href="https://github.com/ginnko/redux-learn" target="_blank" rel="noopener">https://github.com/ginnko/redux-learn</a>)</li></ul></li><li><p>其他</p><p>React-router、git、sphinx、antDesign、chrome使用技巧、gulp、less、Bootstrap、Sass、D3技术文档、博客和教程  </p></li></ul><hr><h3 id="练习项目"><a href="#练习项目" class="headerlink" title="练习项目"></a>练习项目</h3><p><em>（以下练习项目均可点击至相关页面）</em></p><ul><li><p><a href="https://github.com/ginnko/company_page" target="_blank" rel="noopener">公司旧官网模仿</a><br>不借助第三方库模仿公司旧官网（大约完成90%）。</p></li><li><p><a href="https://github.com/ginnko/front-end-demos/tree/master/responsivewebpage" target="_blank" rel="noopener">响应式页面</a><br>模仿一个互联网金融网站的主页面。广告部分的动画实现借助owlcarousel2库，图片兼容性借助picturefill库。</p></li><li><p><a href="https://codepen.io/ginnko/full/JydBWO/" target="_blank" rel="noopener">一个简单的RPG游戏</a><br>FreeCodeCamp上的项目，使用React做的一个RPG游戏。</p></li><li><p><a href="https://codepen.io/ginnko/full/YQvVRw/" target="_blank" rel="noopener">Conway’s Game of Life</a><br>FreeCodeCamp上的项目，使用React实现的英国数学家Conway创造的一个细胞生存游戏，规则：1.本轮某个细胞存活如果与它相邻有2个或3个细胞存活，那它在下一轮也将继续存活；<br>2.某个死亡的细胞周围如果有3个活着的细胞存在，那么下一轮这个细胞将复活。<br>可以控制游戏盘的大小，游戏运行的速度，可以随机生成或手动添加细胞。</p></li><li><p><a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">分数排名榜</a><br>FreeCodeCamp上的项目，使用React实现的FreeCodeCamp这个编程学习社区的分数排名，可以显示30天内或总的分数排名。排名会显示用户名和头像，顺序可以是从小到大或从大到小。</p></li><li><p><a href="https://codepen.io/ginnko/full/XgzqKG/" target="_blank" rel="noopener">食谱编辑器</a><br>FreeCodeCamp上的项目，使用React实现的一个可以存储在浏览器中的食谱应用，可以添加、删除、编辑项目。</p></li><li><p><a href="https://codepen.io/ginnko/full/zzZmvJ/" target="_blank" rel="noopener">Markdown预览</a><br>FreeCodeCamp上的项目，这个应用可以用来实时预览用Markdown书写的文档。</p></li><li><p><a href="https://codepen.io/ginnko/full/YQRgxM/" target="_blank" rel="noopener">美国GDP逐年变化可视化</a><br>FreeCodeCamp上的项目，使用D3框架将美国GDP可视化成一组条状图，可以通过鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/mwvmdW/" target="_blank" rel="noopener">世界自行车竞赛排名</a><br>FreeCodeCamp上的项目，使用D3框架将世界自行车竞赛排名可视化成一系列点状图，可以显示选手是否曾经使用兴奋剂，可以通过鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/bRZeWy/" target="_blank" rel="noopener">全球地表平均温度可视化</a><br>FreeCodeCamp上的项目，使用D3框架将1753-2015年每个月全球的地表平均温度可视化成一组条状图，能看出地球在逐渐变暖。</p></li><li><p><a href="https://codepen.io/ginnko/full/xreaEp/" target="_blank" rel="noopener">相邻国家可视化</a><br>FreeCodeCamp上的项目，使用D3框架中的force layout实现主要国家的相邻国家的可视化，可以任意拖动。使用css-sprites插入每个国家的国旗，移动鼠标到相应国旗显示国家名称（有时国旗显示比较慢）。</p></li><li><p><a href="https://codepen.io/ginnko/full/LLwyvv/" target="_blank" rel="noopener">全球陨石地图</a><br>FreeCodeCamp上的项目，使用D3框架中的map实现全球陨石落地地点的可视化，地图可以拖动，可以缩放，圆圈的大小表示陨石相对大小，鼠标移动查看详细数据。</p></li><li><p><a href="https://codepen.io/ginnko/full/dRPXGv/" target="_blank" rel="noopener">Tic Tac Toe Game</a><br>FreeCodeCamp上的项目，一个游戏，三子连成一条线即算赢，可以人机对战也可以双人对战，一局结束后记录结果并自动开始下一局。</p></li><li><p><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">番茄工作法计时器</a><br>FreeCodeCamp上的项目，一个番茄工作法计时器，在session length中输入工作时长，在break length中输入休息时长，点击start，即开始循环计时。可以暂停，可以重置。</p></li><li><p><a href="https://codepen.io/ginnko/full/oWKbKz/" target="_blank" rel="noopener">计算器</a><br>FreeCodeCamp上的项目，模仿实体计算器，双行显示，能够计算20位以内的数字。</p></li><li><p><a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">维基百科搜索引擎</a><br>FreeCodeCamp上的项目，使用英文够搜索维基百科内的所有词条并显示前10项内容。</p></li><li><p><a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">天气地址查看器</a><br>FreeCodeCamp上的项目，显示所在地点的具体地址和天气情况。  </p></li></ul><hr><h3 id="语言能力"><a href="#语言能力" class="headerlink" title="语言能力"></a>语言能力</h3><ul><li>英语：IELTS  6.5，CET6  512</li><li>日语：基本具备二级水平</li></ul><hr><h3 id="个人描述"><a href="#个人描述" class="headerlink" title="个人描述"></a>个人描述</h3><p>毕业之后在设计院工作，终因自己对编程的执念于17年4月辞职，开始前端的自学之路。17年10月进入目前的公司，正式开始前端开发。一年实际开发的经历和持续的学习，让我对前端有了更深刻的认识，也多了一份自信，难得的是能感受到这份工作带来的成就感和快乐，我相信自己可以借助前端走的更远。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之三——《React小书》第一、第二阶段</title>
      <link href="/2018/11/02/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/"/>
      <url>/2018/11/02/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><a href="http://huziketang.mangojuice.top/books/react/" target="_blank" rel="noopener">React小书</a></p><h3 id="关于对React这个库的理解"><a href="#关于对React这个库的理解" class="headerlink" title="关于对React这个库的理解"></a>关于对React这个库的理解</h3><p>首先，React是一个库，而不是一个框架，它存在的意义是从下面几个角度降低前端开发的复杂性：</p><ol><li>封装了DOM操作</li><li>增强了代码的可复用性</li><li>封装了数据驱动页面更新的过程</li><li>封装了浏览器的兼容性</li><li>封装了事件处理过程</li></ol><a id="more"></a><h3 id="虚拟DOM存在意义"><a href="#虚拟DOM存在意义" class="headerlink" title="虚拟DOM存在意义"></a>虚拟DOM存在意义</h3><ol><li>根据不同的平台进行相应的抽象，这也是react-dom被抽出的原因</li><li>数据更新时，操作虚拟DOM的效率远高于操作实际DOM节点的效率</li></ol><h3 id="React中的event对象"><a href="#React中的event对象" class="headerlink" title="React中的event对象"></a>React中的event对象</h3><p>React中的<code>event</code>对象并不是浏览器提供的，而是它自己内部构建的。React将浏览器原生的event对象封装了以下，对外提供统一的API和属性，这样就不用考虑不同浏览器的兼容性问题。同时，这个event对象是符合W3C标准的，它具有类似event.stopPropagation、event.preventDefault这种常用的方法。</p><h3 id="React中的事件绑定"><a href="#React中的事件绑定" class="headerlink" title="React中的事件绑定"></a>React中的事件绑定</h3><p>React调用你传给它的方法的时候，并不是通过对象方法的方式调用(<code>this.handleClickOnTitle</code>)，而是直接通过函数调用(<code>handleClickOnTitle</code>)，<strong>所以事件监听函数内并不能通过<code>this</code>获取到实例</strong>。</p><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p><a href="https://reactjs.org/docs/react-component.html#defaultprops" target="_blank" rel="noopener">defaultProps</a></p><p>当设置这个组件类的静态属性后，没有给组件传递参数的时候(<code>undefined</code>)，会自动使用defaultProps中的值，如果传入<code>null</code>，将会使用<code>null</code>，而不是默认值。</p><p>一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomButton.defaultProps = &#123;</span><br><span class="line">color: <span class="string">'blue'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关于componentWillUnmount"><a href="#关于componentWillUnmount" class="headerlink" title="关于componentWillUnmount"></a>关于componentWillUnmount</h3><p>componentWillUnmount：组件对应的 DOM 元素从页面中删除之前调用。</p><p>下面这样的场景就很有用了，在同事写的代码里有见过类似的写法：</p><p>多次的隐藏和显示会让 React.js 重新构造和销毁 Clock 组件，每次构造都会重新构建一个定时器。而销毁组件的时候没有清除定时器，所以你看到报错会越来越多。而且因为 JavaScript 的闭包特性，这样会导致严重的内存泄漏。</p><p>这时候componentWillUnmount 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 Clock 添加 componentWillUnmount，在组件销毁的时候清除该组件的定时器.</p><p>如果组件删除了，但是定时器没有被消除就会出现下图的错误：</p><p><img src="/images/react/componentWillUnmount.png" alt="componentWillUnmount"></p><h3 id="关于props-children"><a href="#关于props-children" class="headerlink" title="关于props.children"></a>关于props.children</h3><p>这个属性是个 <strong>数组</strong> ！！！！！！</p><p>所以可以这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layout</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'two-cols-layout'</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">'sidebar'</span>&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className='main'&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children[1]&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="关于dangerouslySetInnerHTML"><a href="#关于dangerouslySetInnerHTML" class="headerlink" title="关于dangerouslySetInnerHTML"></a>关于dangerouslySetInnerHTML</h3><p>一般要这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  className=<span class="string">'editor-wrapper'</span></span><br><span class="line">  dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="keyword">this</span>.state.content&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>当需要往页面动态插入HTML结构的时候，我们只能使用<code>dangerouslySetInnerHTML</code>，注意为避免XSS攻击，需要对一些敏感字符进行转义处理：</p><p>一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p dangerouslySetInnerHTML=&#123;&#123;</span><br><span class="line">  __html: <span class="keyword">this</span>._getProcessedContent(comment.content)</span><br><span class="line">&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">_getProcessedContent (content) &#123;</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">  .replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>)</span><br><span class="line">  .replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#039;"</span>)</span><br><span class="line">  ..replace(<span class="regexp">/`([\S\s]+?)`/g</span>, <span class="string">'&lt;code&gt;$1&lt;/code&gt;'</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面<code>_getProcessedContent</code>函数中的前五个<code>replace</code>都是用来进行转义处理的操作。</p><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><p>这个函数不要再使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十四-backgrounds</title>
      <link href="/2018/09/11/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-backgrounds/"/>
      <url>/2018/09/11/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-backgrounds/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_boxes/Backgrounds" target="_blank" rel="noopener">链接</a></p><h3 id="What-exactly-is-a-background"><a href="#What-exactly-is-a-background" class="headerlink" title="What exactly is a background"></a>What exactly is a background</h3><ol><li>默认情况下，背景会延伸到边框的外延。外边距并不算元素区域的一部分，而是算元素的外部区域。</li></ol><h3 id="The-basics-color-image-position-repeat"><a href="#The-basics-color-image-position-repeat" class="headerlink" title="The basics: color, image, position, repeat"></a>The basics: color, image, position, repeat</h3><h4 id="background-color"><a href="#background-color" class="headerlink" title="background color"></a>background color</h4><ol><li>元素默认的背景色是<code>transparent</code></li></ol><a id="more"></a><h3 id="background-image"><a href="#background-image" class="headerlink" title="background image"></a>background image</h3><p><code>background-image: url(https://mdn.mozillademos.org/files/13026/fire-ball-icon.png);</code> url中不用必须写成字符串</p><ol><li>background images使用css属性设置，所以对于辅助设备是不可见的。</li></ol><p>下面这段话解释了什么时候用background，什么时候用img元素。</p><blockquote><p>Background images are not content images – they are just for decoration – if you want to include an image on your page that is part of the content, then you should do so with an <code>&lt;img&gt;</code> element.</p></blockquote><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background repeat"></a>background repeat</h3><p>可以取得值有：</p><ul><li>no-repeat: 横向，竖向都完全不重复，只会显示一次</li><li>repeat-x: 会在横向重复</li><li>repeat-y：会在纵向重复</li><li>repeat： <em>默认值</em> ，在横向和纵向皆重复</li></ul><h3 id="background-position"><a href="#background-position" class="headerlink" title="background position"></a>background position</h3><p>这个属性允许摆放background image的位置，属性值是两个由空格分隔的值，可以是绝对值也可以是相对值，这两个值定义了<code>背景图片</code>的横纵坐标。</p><blockquote><p>Generally the property will take two values separated by a space, which specify the horizontal (x) and vertical (y) coordinates of the image. The top left corner of the image is the origin — (0,0). </p></blockquote><p>下面的观点出自<a href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/02/01/1948644.html" target="_blank" rel="noopener">这里</a>以及<a href="https://blog.csdn.net/u013778905/article/details/52811146" target="_blank" rel="noopener">这里</a>，其实并没有说清楚，结合自己的感觉，罗列如下：</p><ul><li><p>使用绝对值定位其实指的是图片的左上角相对于背景的左上角的偏移。</p></li><li><p>使用百分数定位是改变了背景图和元素的对齐基点，background-position： 100% 50%; 就是将背景图片的 100%（right） 50%（center） 这个点，和元素的 100%（right） 50%（center） 这个点对齐。</p></li><li><p>使用关键字定位感觉类似百分比</p></li></ul><h3 id="background-image-gradients"><a href="#background-image-gradients" class="headerlink" title="background image:gradients"></a>background image:gradients</h3><p>有两种gradient方式：线性和辐射</p><h4 id="线性gradient"><a href="#线性gradient" class="headerlink" title="线性gradient"></a>线性gradient</h4><p><code>background-image: linear-gradient(to bottom, orange, yellow);</code></p><p>linear-gradient函数接收三个参数：方向、起始颜色、结束颜色。</p><p>color stops: 下面的<code>orange 40%</code>就是一个color stops，可以指定任意个color stops，40%表示的是位置而不是颜色的程度，是沿着指定的方向按此值确定的，此处可以使用绝对值。</p><p><code>background-image: linear-gradient(to bottom, yellow, orange 40%, yellow);</code></p><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background attachment"></a>background attachment</h3><p>首先，这个属性只有在内容出现滚动的时候才会生效。</p><p>这个属性有三个值可用：</p><ul><li><p>scroll：页面滚动，背景图也跟着滚动，元素滚动，背景图固定</p></li><li><p>fixed：使背景图相对于视口fixed，无论内容还是页面滚动背景图都不会滚动</p></li><li><p>local：页面滚动或元素滚动，背景图都跟着滚动</p></li></ul><p>要看一下这个简写属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十三-box model recap</title>
      <link href="/2018/09/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-box-model-recap/"/>
      <url>/2018/09/10/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-box-model-recap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_boxes/Box_model_recap" target="_blank" rel="noopener">链接</a></p><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p><code>overflow</code>的默认值是<code>visible</code>。</p><a id="more"></a><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>默认情况下，<code>backgrounds</code>延伸到<code>border</code>的外边延。</p><p>使用<code>background-clip</code>属性可以设置<code>backgrounds</code>仅延伸到内容的边缘。</p><p><code>background-clip</code>可以设置的值有：</p><ul><li><p><code>border-box</code></p></li><li><p><code>padding-box</code></p></li><li><p><code>content-box</code></p></li><li><p><code>text</code></p></li></ul><p>设置在文本上的时候，可以这样设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-clip</span>: <span class="selector-tag">text</span>;</span><br><span class="line">-webkit-background-clip: text; // 针对chrome</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p><code>outline</code><strong>不是</strong>盒模型的一部分，看起来像是border，但实质是画在盒子的上方，同时也不会改变盒子的尺寸（具体来讲是画在边框外，在外边距内）。</p><h3 id="advanced-box-properties"><a href="#advanced-box-properties" class="headerlink" title="advanced box properties"></a>advanced box properties</h3><ol><li>setting width and height constraints</li></ol><p>一个常见的用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  width:  70%; // 给容器设置弹性宽度</span><br><span class="line">  max-width: 1280px; // 设置最大值，阻止宽度过大  </span><br><span class="line">  min-width： 480px; // 设置最小值，阻止宽度过小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>margin: 0 auto;</code>来给inner盒子居中在parent中时，需要设置本盒子的宽度，这个宽度设置成 <strong>百分比</strong> 也是有效果的。<code>auto</code>的意思是让容器左右两侧的外边距分享可用的空间，以实现居中的效果。</p><ol start="2"><li>changing the box model completely</li></ol><p>盒子的总宽 = <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-right</code> + <code>border-left</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十二-multiple-column layout</title>
      <link href="/2018/09/09/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-multiple-column-layout/"/>
      <url>/2018/09/09/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-multiple-column-layout/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Multiple-column_Layout" target="_blank" rel="noopener">链接</a></p><h3 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h3><p>真是出乎意料，这个属性竟然几乎被全部的浏览器支持！！！</p><ul><li><code>column-count</code>将创建属性值那么多数量的列。</li></ul><p>使用<code>column-count</code>创建出来的列具有弹性宽度。</p><ul><li><code>column-width</code></li></ul><p>使用这个属性将按照设定的属性值根据container的尺寸提供尽可能多的列，剩余的空间将<code>填充</code>到已生成的列中。也就是说没有办法得到设定的宽度，除非container的宽度恰好能被设定的宽度整除。</p><a id="more"></a><h3 id="设置列的样式"><a href="#设置列的样式" class="headerlink" title="设置列的样式"></a>设置列的样式</h3><p>出乎意料！！！通过<code>multicol</code>创建的列不能单独设置样式。没有办法做到一列比另一列宽，或是改变单独一列文本的颜色。只能通过<code>column-gap</code>或是<code>column-rule</code>这两个属性来整体改变每一列的样式。</p><p><strong>好像是个问题：通过column-*设置的样式貌似都没有办法通过浏览器的样式查看器进行查看和调试</strong></p><p><code>column-rule</code>是<code>column-rule-color</code>，<code>column-rule-style</code>以及<code>column-rule-width</code>三个属性的缩写。用于设置列边的样式。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">4px</span> dotted <span class="built_in">rgb</span>(79, 185, 227);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是<code>column-rule</code>属性并不会为它自己占据什么空间，而是<code>lies across</code>通过<code>column-gap</code>属性设置的<code>gap上</code>。如果想增加<code>column-rule</code>两边的空间，只有增加<code>column-gap</code>的值才能做到。</p><h3 id="columns-and-fragmentation"><a href="#columns-and-fragmentation" class="headerlink" title="columns and fragmentation"></a>columns and fragmentation</h3><blockquote><p>The content of a multi-column layout is fragmented. It essentially behaves the same way as content behaves in paged media —- such as when you print a webpage. When you turn your content into a multicol container it is fragmented into columns, and the content breaks to allow this to happen.</p></blockquote><p>这个<a href="https://codepen.io/pen/" target="_blank" rel="noopener">例子</a>中会出现标题和文本被分割的情况。</p><p>在容器中的元素上使用<code>break-inside: avoid</code>，明确告知我们不想对这个盒子使用片段化。</p><p>避免浏览器的不支持，建议混合使用下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">break-inside</span>: avoid;</span><br><span class="line">  <span class="attribute">page-break-inside</span>: avoid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十一-positioning</title>
      <link href="/2018/09/08/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-positioning/"/>
      <url>/2018/09/08/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-positioning/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning" target="_blank" rel="noopener">链接</a></p><h3 id="static-positioning"><a href="#static-positioning" class="headerlink" title="static positioning"></a>static positioning</h3><p><em>static positioning</em> 是每个元素获得的默认属性，这个属性的意思是：把这个元素摆在文档正常流的正常位置就好。</p><h3 id="relative-positioning"><a href="#relative-positioning" class="headerlink" title="relative positioning"></a>relative positioning</h3><p>设置为<code>position: relative</code>的元素：依然占据文档正常流中的位置，但是可以通过<code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>调整位置。</p><a id="more"></a><h3 id="absolute-positioning"><a href="#absolute-positioning" class="headerlink" title="absolute positioning"></a>absolute positioning</h3><p>一个绝对定位的元素不再在文档普通流中存在，<strong>它存在于自己的层中</strong>。这意味着我们可以创建孤立的ui特性同时不会干扰页面上的其他元素。比如 <em>弹出消息框</em>，<em>控制菜单</em>, <em>拖拽或低落的效果</em>。</p><p>对于绝对定位元素，margin属性依然有效。</p><h3 id="positioning-contexts"><a href="#positioning-contexts" class="headerlink" title="positioning contexts"></a>positioning contexts</h3><blockquote><p>if no ancestor elements have their position property explicitly defined, then by default all ancestor elements will have a static position. The result of this is, the absolutely positioned element will be contained in the <strong>initial containing block</strong>. The initial containing block has the dimensions of the viewport, and is also the block that contains the html element. Simply put, the absolutely positioned element will be contained outside of the html element, and be positioned relative to the initial viewport.</p></blockquote><p>解决了我的一大困惑：<strong>父元素没有做任何特殊处理的绝对定位元素，将被包含在html元素之外（这意思是不再被html元素包裹？），将相对于初始包含块定位。</strong></p><p>可以通过给父元素指定<code>position: relative</code>或<code>position: absolute</code>来更改positioning contexts。</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>首先要知道的是：当我们绝对定位一个元素之后，它就会出现在最顶层，因为<em>绝对定位元素</em>在和<em>non-positioned</em>元素争夺高空权的时候，胜出。</p><p>但是，当有多个（同一父元素下的兄弟？示例里使用的这种形式）元素时，就可以使用<code>z-index</code>属性来控制z-axis方向上的顺序。</p><h3 id="fixed-positioning"><a href="#fixed-positioning" class="headerlink" title="fixed positioning"></a>fixed positioning</h3><p>固定定位元素相对于 <strong>浏览器视口</strong> 定位。</p><h3 id="sticky-positioning"><a href="#sticky-positioning" class="headerlink" title="sticky positioning"></a>sticky positioning</h3><p>之前有看过这个</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之九-grids</title>
      <link href="/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-grids/"/>
      <url>/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-grids/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids" target="_blank" rel="noopener">链接</a></p><p>Grid布局是二维的布局方法。能同时在row和column两个方向上进行布局。</p><h3 id="What-is-grid-layout"><a href="#What-is-grid-layout" class="headerlink" title="What is grid layout"></a>What is grid layout</h3><p><img src="/images/css/grids-scheme.png" alt="grids-scheme"></p><a id="more"></a><h3 id="defining-a-grid"><a href="#defining-a-grid" class="headerlink" title="defining a grid"></a>defining a grid</h3><p><strong>下面的内容皆是创建网格时所用：</strong></p><ol><li><p>设置一个grid box默认是创建了 <strong>一列</strong> 的grid</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加列, 使用<code>grid-template-columns</code>属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>说明：创建列的宽度的单位可以使用任意单位。</p><ol start="3"><li>使用<code>fr</code>创建弹性尺寸的行与列</li></ol><p><code>1fr</code>表示一个grid盒子中的 <strong>可用空间</strong> 的一块,也就是按比例布局。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！<code>fr</code>分发的是可用空间，而不是所有的空间。因此，如果一个track（不知道翻译成什么好，理解为一列吧）中的东西过大，就会压缩外面剩余的可用空间。</p><ol start="4"><li><p>使用<code>grid-column-gap</code>创建列间距，使用<code>grid-row-gap</code>创建行间距，<code>grid-gap</code>同时创建行和列间距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了代码更无懈可击，推荐使用下面这种bulletproof的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  gap: 20px; // 这个在vscode里被识别为无效...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复track listings，使用<code>repeat</code>函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>implicit and explicit grid（这里要翻译成隐式和显示创建）</p></li></ol><p>使用<code>grid-template-columns</code>以及<code>grid-template-rows</code>来显式创建行和列。</p><blockquote><p>The implicit grid is created whrn content is placed outside of that grid - such as into our rows.</p></blockquote><p>上面这是啥意思？</p><p>默认情况下，在隐式网格中创建的tracks都是自动调整大小的，这意味着，通常情况下，它们都能盛下其中的内容。</p><p>其实不太明白，但是可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>来隐式设置网格，值可以取<code>auto</code>也可以取<code>具体的值</code>。</p><ol start="8"><li><p><code>minmax()</code>function</p><p><code>minmax(100px, auto);</code>表示最小值是100px，最大值为auto，也就是大小能容纳内容。</p></li><li><p>组合使用<code>minmax()</code>函数和<code>repeat()</code>函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, minmax(200px, 1fr));</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(100px, auto);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repeat函数中，</p><p>第一个参数表示要创建的个数，使用auto-fill表示创建尽可能多的列来满足container的空间</p><p>第二个参数表示每列的尺寸，最小尺寸为200px，最大尺寸为1fr</p></li></ol><h3 id="Line-based-placement"><a href="#Line-based-placement" class="headerlink" title="Line-based placement"></a>Line-based placement</h3><ul><li><p><code>grid-column-start</code></p></li><li><p><code>grid-column-end</code></p></li><li><p><code>grid-row-start</code></p></li><li><p><code>grid-row-end</code></p></li></ul><p>缩写形式：</p><ul><li><p><code>grid-column</code></p></li><li><p><code>grid-row</code></p></li></ul><p>比如像下面这样使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="positioning-with-grid-template-areas"><a href="#positioning-with-grid-template-areas" class="headerlink" title="positioning with grid-template-areas"></a>positioning with grid-template-areas</h3><p>使用<code>grid-template-areas</code>和<code>grid-area</code>两个属性。</p><ul><li><p><code>grid-template-areas</code>用来设置位置</p></li><li><p><code>grid-grid</code>用来给内容命名</p></li></ul><p>比如像下面这样使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">      <span class="string">"header header"</span></span><br><span class="line">      <span class="string">"sidebar content"</span></span><br><span class="line">      <span class="string">"footer footer"</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-template-areas</code>遵循下面的原则：</p><ol><li><p>每一个网格的cell都要被填充</p></li><li><p>跨越两个cells，重复名字即可</p></li><li><p>留下一个空白cell，使用句点即可</p></li><li><p>每一个dom元素只能占据矩形空间</p></li><li><p>没一个dom元素只能占据连续空间</p></li></ol><p>ps.火狐有<code>Firefox Grid Inspector</code>这个神器，为毛chrome没有？？？</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之十-floats</title>
      <link href="/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-floats/"/>
      <url>/2018/09/07/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-floats/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats" target="_blank" rel="noopener">链接</a></p><h3 id="浮动的结果"><a href="#浮动的结果" class="headerlink" title="浮动的结果"></a>浮动的结果</h3><p><code>float</code>本来是用来在一块文本中浮动图片的,多行布局交给了<code>flex</code>和<code>grid</code>，链接中的文章就是从这个角度来介绍float的。</p><p>浮动元素会脱离正常流。</p><p>浮动只会在元素所在的原始行开始浮动，并不会像<code>position: absolute</code>“浮的”那么彻底。</p><blockquote><p>the element with the float set on it is taken out of the normal layout flow of the document and stuck to the left and side of its parent container. Any content that comes below the floated element in the normal layout flow will now wrap around it, filling up the space to the right-hand side of it as far up as the top of the floated element. There it will stop.</p></blockquote><p>只能通过给<code>浮动元素</code>的一侧添加外边距来调整浮动元素和环绕它的文本的间距。</p><a id="more"></a><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>使用<code>clear</code>属性，可以取得值有：</p><ul><li><p>left</p></li><li><p>right</p></li><li><p>both</p></li></ul><h3 id="clearing-boxes-wrapped-around-a-float"><a href="#clearing-boxes-wrapped-around-a-float" class="headerlink" title="clearing boxes wrapped around a float"></a>clearing boxes wrapped around a float</h3><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>Float<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(207,232,220);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(79,185,227);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会出现图片中的布局：</p><p><img src="/images/css/clearing-box.png" alt="clearing-box"></p><p>造成这种结果的原因是浮动元素脱离了正常流。想做到文本在浮动元素旁边排列且外部盒子能包住两个元素，靠给文本添加清除浮动是无法做到的，只会导致文本另起一行。</p><p>解决办法：</p><ol><li>clearfix hack</li></ol><p>实质就是在wrapper后面添加内容，并两侧清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>overflow</code>值非<code>visible</code></li></ol><p>实质是这个属性让wrapper成为了一个新的BFC，而BFC在计算高度的时候会包含浮动元素。</p><ol start="3"><li>使用<code>display: flow-root</code></li></ol><p>专业的做法，实质也是创建了新的BFC。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之七-BFC2</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-bfc2/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-bfc2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xiaohuochai/p/5248536.html" target="_blank" rel="noopener">链接</a></p><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>常说的文档流可以分为<code>定位流</code>，<code>浮动流</code>，<code>普通流</code>三种。而<code>普通流</code>其实就是指BFC中的FC（formatting context），直译过来就是格式化上下文，<strong>它是页面上的一块渲染区域，有一套渲染规则，决定了其子元素如何布局以及和其他元素之间的关系和作用。</strong>常见的FC有BFC，IFC，GFC，FFC。BFC是block formatting context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域。</p><a id="more"></a><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC是页面上的一个隔离的独立容器，<strong>容器里面的子元素不会影响到外面的元素，反之亦然</strong>。它与普通的块框类似，但不同之处在于：</p><ol><li><p>可以阻止元素被浮动元素覆盖</p></li><li><p>高度计算是会包含浮动元素，解决父元素高度坍塌的问题</p></li><li><p>属于同一个BFC的两个相邻块级资源素的上下外边距会发生坍塌的现象，所以当两个相邻块级子元素分属于不同的BFC时可以阻止外边距坍塌。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之八-flexbox</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-flexbox/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-flexbox/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener">链接</a></p><p>flex是一维布局方法，将flex items在row方向上布局或是在column方向上布局。flex item会伸缩来适应剩余空间或空间不够的情况。<strong>成为flex-items的元素可以认为是一个 <em>块级盒子</em>。</strong></p><h3 id="设置在-flexbox-上的属性"><a href="#设置在-flexbox-上的属性" class="headerlink" title="设置在 flexbox 上的属性"></a>设置在 flexbox 上的属性</h3><ol><li>display: box</li><li>flex-direction: row | column | row-reverse | column-reverse</li><li><p>flex-wrap: wrap </p><p> 当flex items数量过多，导致超出flex box的时候，上面这个属性会让flex items分布在多行显示，消除溢出flex box的问题。</p></li><li><p>flex-flow = flex-direction + flex-wrap</p><p> 上面的设置可以写成： <code>flex-flow: row wrap;</code></p></li></ol><a id="more"></a><h3 id="设置在-flex-items-上的属性"><a href="#设置在-flex-items-上的属性" class="headerlink" title="设置在 flex items 上的属性"></a>设置在 flex items 上的属性</h3><ol><li><p>flex: 1 200px;</p><p> 第1个无单位的属性表示元素将在主轴上占据多少空间（设置完padding和margin后留下的剩余空间）。</p><p> 第2个<code>200px</code>参数表明最小尺寸。</p><p> 上面这个属性的意思是：每一个flex item首先会给<code>200px</code>的可用空间。之后，剩余的空间将按照比例<code>1</code>来分。</p></li><li><p>flex是一个缩写属性，最多能设置三个值（<strong>mdn上建议使用缩写形式</strong>）：</p><ul><li>flex-grow：无单位的比例</li><li>flex-shrink： 无单位的比例</li><li>flex-basis： 最小空间</li></ul></li><li><p>align-items:控制flex items如何在交叉轴上摆放，可以取得值有：</p><ul><li>stretch：默认值，将会拉伸flex items的高度和父元素相同</li><li>center：flex items将保持固有尺寸，但是会沿着交叉轴居中</li><li>flex-start/flex-end：定位在交叉轴的start/end位置</li></ul></li><li><p>justify-content：控制flex items在主轴上如何摆放，可以取得值有：</p><ul><li>flex-start(默认值):从主轴的start处开始</li><li>flex-end：从主轴的end处开始</li><li>center：定位在主轴的中间</li><li>space-around: 在每个元素的左右两侧都留相同的空间，导致最靠边的两个元素左右两侧距离边框有距离，且元素和元素之间的空间要比刚说的这个空间大。整个主轴的空间被这些flex items瓜分。</li><li>space-between: 最外侧的两个元素靠近边框的一侧没有多余的空间，整个主轴的空间被flex items瓜分，剩余的空间都分布在flex items之间了。</li></ul></li><li><p>order:</p><ul><li>默认值： 0</li><li>数值越大排序越靠后</li></ul></li></ol><h3 id="Nested-flex-boxes"><a href="#Nested-flex-boxes" class="headerlink" title="Nested flex boxes"></a>Nested flex boxes</h3><p>这个已经用过多次了</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之六-普通流</title>
      <link href="/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-normal-flow/"/>
      <url>/2018/09/05/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-normal-flow/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow" target="_blank" rel="noopener">链接</a></p><p>在正常流中，</p><p><em>块级元素</em> 竖向堆叠， 它们之间的距离由各自的外边距叠加而成。</p><a id="more"></a><p><em>内联元素</em> 在同一行水平挨着摆放。</p><p><em>外边距坍塌</em>, 如果两个相邻的的元素且都设置了外边距（ <strong>这里感觉特指是块级元素，且特指上下外边距，试了下，内联元素不会发生坍塌，块级元素的左右外边距也不会发生坍塌，印象中也说的是块级元素的上下外边距</strong> ）</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之五-css布局介绍</title>
      <link href="/2018/09/04/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-introduction-to-css-layout/"/>
      <url>/2018/09/04/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-introduction-to-css-layout/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Introduction" target="_blank" rel="noopener">链接</a></p><p><img src="/images/css/css定位方案.png" alt="一张神图"></p><h3 id="Normal-flow"><a href="#Normal-flow" class="headerlink" title="Normal flow"></a>Normal flow</h3><p>能够改变元素的布局的方法如下：</p><ol><li><code>display</code></li><li><code>Floats</code></li><li><code>position</code></li><li><code>Table layout</code></li><li><code>Multi-column layout</code></li></ol><a id="more"></a><h4 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h4><p>在父元素上设置<code>display：flex</code>，然后它的直属子元素就变成了<code>flex items</code>。</p><p>比如下面这个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>flex初始设置：</p><p>没有给<code>wrapper</code>设置<code>display:flex</code>之前，它的三个子元素将竖向堆叠;设置后，它们将排成一行，<strong>这是由于它们成为了flex items 并且拥有了flex box给它们的初始属性</strong>，其中<code>flex-direction: row</code>，所以就排成了一行。它们都被拉伸到最高<code>item</code>的高度，这是因为<code>align-items: stretch</code>,这意味着<code>items</code>拉伸到flex容器的高度，这里是由最高的<code>item</code>决定的。<code>items</code>从容器的开始排成一行，在该行的后面留下多余的空间。</p><p>上面提到的<code>flex-direction</code>和<code>align-items</code>都是应用在<code>flexbox</code>上面的。</p><h4 id="Grid-Layout"><a href="#Grid-Layout" class="headerlink" title="Grid Layout"></a>Grid Layout</h4><p>flexbox是为一维布局设计的，也就是说只能横向或竖向布局。grid布局是为二维布局设计的，同时在横向和竖向两个方向上布局。</p><p>使用<code>display: grid</code>将布局方式转换为grid布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box5"</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box6"</span>&gt;</span>Six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面提到的<code>grid-template-rows</code>以及<code>grid-template-columns</code>属性是应用在<code>gridbox</code>上的。上面的例子定义了三列，每列1fr，两行，每行100px。</p><p>下面的这个例子简直惊了…</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span> / <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h4><h4 id="Positioning-techniques"><a href="#Positioning-techniques" class="headerlink" title="Positioning techniques"></a>Positioning techniques</h4><p>positioning允许你将处在正常流中的元素所在位置移到他处。<strong>Positioning不是创建主页面布局的方法，更多的是用来微调页面上个别元素的位置。</strong></p><p>positioning可以取以下五个值：</p><ol><li><code>static</code>：默认值，在<code>Normal flow</code>中</li><li><code>relative</code>：在<code>Normal flow</code>中</li><li><p><code>absolute</code>：完全脱离<code>Normal flow</code></p><p> 在<a href="./2018-08-31-css查漏补缺之一-格式上下文.md">格式化上下文</a>一文中，有记录：子元素浮动导致父元素高度出现坍塌的原因是在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由其他的子元素的高度撑开的。但是如果子元素是设置了浮动，<strong>脱离了文档流</strong>,那么父元素计算高度的时候就会忽略该子元素，出现父元素高度为0的现象。解决办法是让父元素新建一个BFC，其在计算高度的时候，会把浮动资源素包进来。</p><p> <code>absolute</code>也会导致元素完全脱了<code>normal flow</code>，但即便给其父元素设置了创建BFC的属性，也不能解决副元素高度坍塌的问题，看来，对于<code>absolute</code>是包不进来了。</p></li><li><p><code>fixed</code>：完全脱离<code>Normal flow</code></p></li><li><code>sticky</code>：元素开始表现的像<code>static</code>，直到它 hit a defined offset from the viewport，此刻就开始按<code>fiexed</code>行事。</li></ol><p>点击<a href="https://codepen.io/ginnko/pen/OogrwQ" target="_blank" rel="noopener">此处</a>详见示例。</p><blockquote><p> A stickily positioned element is treated as relatively positioned until it crosses a specified threshold, at which point it is treated as fixed until it reaches the boundary of its parent. </p></blockquote><p>一个使用<code>position: sticky</code>布局的元素在到达设置的阈值之前将表现为<code>relative</code>的布局形式，到达阈值后将被当作<code>fixed</code>布局，直到它碰到它的父元素。</p><h4 id="Table-layout"><a href="#Table-layout" class="headerlink" title="Table layout"></a>Table layout</h4><p>现代浏览器使用<code>flexbox</code>以及<code>grid</code>，这个就不看了</p><h4 id="Multi-column-layout"><a href="#Multi-column-layout" class="headerlink" title="Multi-column layout"></a>Multi-column layout</h4><p>点击<a href="https://codepen.io/ginnko/pen/BOZEoR" target="_blank" rel="noopener">此处</a>详见示例。这个例子在容器元素上使用<code>column-width: 200px;</code>，使得浏览器创建尽可能多的200像素的<code>column</code>填充进容器，然后将剩余的空间布置在创建的<code>column</code>周围。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之三-浮动和清除浮动</title>
      <link href="/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89-%E6%B5%AE%E5%8A%A8%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89-%E6%B5%AE%E5%8A%A8%E5%92%8C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">链接</a></p><p>使用<code>float</code>就意味着使用了<code>块状布局</code>，在某些情况下它修改了<code>display</code>的计算值</p><p><img src="/images/css/float-block.png" alt="float-block"></p><p>图中<code>inline-block</code>和<code>table-*</code>系列以及<code>flex-*</code>系列的本身会创建一个新的BFC，好像也没啥关系诶…</p><p>注：使用<code>js</code>访问这个<code>float</code>属性时，要写成<code>cssFloat</code>。</p><h3 id="how-floated-elements-are-positioned"><a href="#how-floated-elements-are-positioned" class="headerlink" title="how floated elements are positioned"></a>how floated elements are positioned</h3><p>当一个元素被设置为浮动，它就脱离了文档的正常流（但它仍然是文档的一部分），它向左或右移动，直到它碰到了 <strong>包含它的容器的边缘或者其他的浮动元素的边缘</strong>(注意这个描述！！！)。</p><a id="more"></a><p>比如下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span><br><span class="line">     Morbi tristique sapien ac erat tincidunt, sit amet dignissim</span><br><span class="line">     lectus vulputate. Donec id iaculis velit. Aliquam vel</span><br><span class="line">     malesuada erat. Praesent non magna ac massa aliquet tincidunt</span><br><span class="line">     vel in massa. Phasellus feugiat est vel leo finibus congue.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background</span>: cyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clear" target="_blank" rel="noopener">链接</a></p><p>清除浮动的含义：强制一个元素移动到一个浮动元素的下方。比如你想让一个段落挨着一个浮动元素，但是强制让标题位于另一行。</p><p><code>clear</code>属性定义了一个元素能在一个浮动元素的旁边还是必须要移动到它的下方。<code>clear</code>这个属性既能应用在<code>浮动元素</code>上又能应用在<code>非浮动元素</code>上。</p><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之四-盒模型</title>
      <link href="/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/09/03/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction-to-the-CSS-basic-box"><a href="#Introduction-to-the-CSS-basic-box" class="headerlink" title="Introduction to the CSS basic box"></a>Introduction to the CSS basic box</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">链接</a></p><p>每一个盒模型都是由四个部分组成，由它们各自的edge定义：内容edge、内边局edge、边框edge以及外边距edge。</p><p><img src="/images/css/box-model.png" alt="盒模型"></p><ul><li><p>内容区域：如果<code>box-sizing</code>属性被设置为<code>content-box</code>(默认值)，内容区域的尺寸可以被进一步通过<code>width</code>,<code>min-width</code>,<code>max-width</code>,<code>height</code>,<code>min-height</code>,<code>max-height</code>定义。</p></li><li><p>内边距区域：在内容区域的基础上扩张</p></li><li><p>边框区域：在内边距的基础上扩张。如果<code>box-sizing</code>属性被设置为<code>border-box</code>，边框区域的宽度能被进一步通过<code>width</code>，<code>min-width</code>，<code>max-width</code>，<code>height</code>，<code>min-height</code>，<code>max-height</code>定义。当给这个盒子设置了背景（背景颜色或者是背景图片），背景会延伸到边框的外延，位于边框的下方。可以通过<code>background-clip</code>这个属性对上述背景特征进行修改。</p></li><li><p>外边距区域：在边框的基础上扩张。</p></li></ul><p>对于未替换的内联元素，占据空间的大小是由<code>line-height</code>这个属性决定的，尽管边框和内边距依然会展示在内容周围。</p><a id="more"></a><h3 id="外边距坍塌"><a href="#外边距坍塌" class="headerlink" title="外边距坍塌"></a>外边距坍塌</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">链接</a></p><p>外边距坍塌：一个块状元素的 <strong>上下外边距</strong>，有时会重叠成单个边距，大小是这两个边距中的大者。 <strong>浮动元素</strong>和 <strong>绝对定位元素</strong>永远不会发生编剧坍塌的问题。</p><p>外边距坍塌发生的三种情况：</p><ol><li><p>相邻兄弟元素</p></li><li><p>父元素和第一个或者最后一个子元素：如果没有边框，内联部分，没有BFC被创建，也没有清除机制分隔一个块和它的子块元素的margin-top或者margin-bottom，那么就会发生外边距坍塌，坍塌的外边距延伸到父元素外。</p></li><li><p>空块元素：如果没有边框，没有内边距，没有内联内容，没有高度和最小高度的属性设置分隔一个块状元素的上下外边距，那它的上下外边距就会坍塌。</p></li></ol><p>注意：</p><ol><li><p>如果有负外边距存在，外边距坍塌后的大小是最大正外边距与最小负外边距之和;</p></li><li><p>如果参与坍塌的双方外边距都是负值，坍塌后的尺寸是最小负外边距。对于相邻和包含元素都适用。</p></li></ol><h3 id="visual-formatting-model"><a href="#visual-formatting-model" class="headerlink" title="visual formatting model"></a>visual formatting model</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model" target="_blank" rel="noopener">mdn(看不明白)</a></p><p><a href="http://layout.imweb.io/article/box-type.html" target="_blank" rel="noopener">简单易懂的文章</a></p><ol><li>块级元素和块盒子</li></ol><p>块级元素定义：当一个元素的<code>display</code>属性的计算值为<code>block</code>，<code>list-item</code>，<code>table</code>,<code>flex</code>,<code>grid</code>时，它就是块级元素，块级元素会生成块级盒子，一个块级元素会垂直堆叠。</p><p>行内级元素：当一个元素的<code>display</code>属性的计算值为<code>inline</code>,<code>inline-block</code>,<code>inline-table</code>,<code>inline-flex</code>,<code>inline-grid</code>时，它就是行内级元素，行内级元素生成行内级盒。</p><p>行内级元素生成的盒子又可以分为 <strong>行内盒</strong>和 <strong>原子行内盒</strong>（感觉这名字有点傻逼…）。行内盒（<code>display: inline</code>）一行显示不下的话会折行显示，而原子行内盒（<code>display: inline-block</code>）不能拆分，其中的内容一行显示不下的话会整体下移（卧槽，做了个实验，真的不折行诶，如果在原子行内盒中的内容过多，依然不弯，而是自动加了水平滚动条，真是盒子界的钢铁直男！）。</p><p>块容器盒：就是该元素的直接子元素只能是块级盒，或只能是行内级盒。</p><p>匿名盒：匿名盒当然是没有名字，所以断然不会被css选择器选中，也就不能为其设置样式。匿名盒的所有样式均来自<em>继承</em>或是<em>初始值</em>。有匿名块盒也有匿名行内盒。</p><p>行盒：行盒与行内盒是不一样的，<strong>行盒是由行内格式化上下文产生的盒，用于表示一行</strong>。费解：既然有了行内盒还要行盒干嘛？行盒从块盒的一边延伸到另一边，当有左浮动时，行盒从浮动元素的最右边延伸到块盒的最右边，右浮动相反。</p><p>定位方案：</p><p>一旦生成盒子，css引擎就需要在布局中定位这些盒子，定位的方案有如下三种：</p><ol><li>正常流</li><li>浮动算法</li><li>绝对定位方案</li></ol><ul><li><p>正常流：盒子是一个挨着一个排列的，在BFC中，是竖向排列的，在IFC中，是横向排列的。正常流当<code>position</code>设置为<code>static</code>或是<code>relative</code>或者<code>float</code>属性被设置为<code>none</code>就会被激活。</p></li><li><p>浮动：浮动会创建浮动盒子，浮动盒子会被摆在当前行的开头或是行尾。</p></li><li><p>绝对定位：在绝对定位中，盒子会从<code>flow</code>中被完全移除，和<code>flow</code>再无交集。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之二-BFC</title>
      <link href="/2018/09/02/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-BFC/"/>
      <url>/2018/09/02/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-BFC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">链接</a></p><p>BFC可以理解为了一个区域，其中有规定块状盒子该如何布局，浮动元素将如何和其他元素打交道。</p><p>下面至少一个方法就能创建一个BFC</p><ol><li>根元素</li><li>浮动（<code>float</code>属性值不是<code>none</code>）</li><li>绝对定位元素（<code>position</code>是<code>absolute</code>或者<code>fixed</code>）</li><li>设置为<code>inline-block</code>的元素（<code>display: inline-block</code>）</li><li>table cells（HTML table cells或者是<code>display: table-cell</code>）</li><li>table caption（HTML table captions 或者是<code>display: table-caption</code>）</li><li>通过<code>display:</code>设置值为<code>table</code>或者<code>table-row</code>或者<code>table-row-group</code>或者<code>table-header-group</code>或者<code>table-footer-group</code>或者<code>inline-table</code>（对于HTML的tables, table row, table bodies, table headers 以及 table footers 默认就会创建）——隐式创建的table-cell</li><li>块状元素的<code>overflow</code>属性值设置为非<code>visible</code></li><li>设置<code>display: flow-root</code></li><li>元素被设置为<code>contain:layout或者content或者strict</code></li><li>flex items（被设置为<code>display: flex 或者 inline-flext</code>的元素的 <strong>直接子元素</strong>）</li><li>grid items（被设置为<code>display: grid 或者 inline-grid</code>的元素的 <strong>直接子元素</strong>）</li><li>多列容器（元素被设为<code>column-count</code>或者<code>column-width</code>不为<code>auto</code>）——这个听都没听过…</li><li><code>column-span:all</code>永远都会创建一个新的BFC —— 没听过…</li></ol><p><strong>如果一个元素创建了一个BFC，那么这个元素的一切子元素都位于这个BFC中。</strong></p><a id="more"></a><p>只有位于同一个BFC中的元素，对它们使用布局或者清除浮动或者边距坍塌规则才会起作用。</p><p>例子已在<a href="./2018-08-31-css查漏补缺之一-格式上下文.md">上一篇</a>中有写。</p><p>下面看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">浮动</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clear" target="_blank" rel="noopener">清除浮动</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Flow_Layout_and_Writing_Modes" target="_blank" rel="noopener">flow-layout-and-writing-modes</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model" target="_blank" rel="noopener">visual-formatting-model</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model" target="_blank" rel="noopener">css-box-model</a>五篇。</p><p>ps.感觉mdn上关于css的文章没有什么顺序诶…有点乱…</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css查漏补缺之一-格式上下文</title>
      <link href="/2018/08/31/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2018/08/31/css%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Formatting_Contexts_Explained" target="_blank" rel="noopener">链接</a></p><h3 id="格式上下文"><a href="#格式上下文" class="headerlink" title="格式上下文"></a>格式上下文</h3><p>页面上的所有东西都处在一个格式上下文中，这个格式上下文可以理解为一个固有结界，它依据规则规定如何摆放内容。</p><p><code>Block Formatting Context</code>根据<code>Block Layout rules</code>来摆放它的子元素。</p><p><code>Flex Formatting Context</code>把它的子元素按照<code>flex items</code>摆放。</p><p><code>html</code>元素定义了最初的<code>BFC</code>,意味着<code>html</code>中的元素都依据<code>Normal Flow</code>的规则摆放。这个规则由<code>css盒模型</code>勾勒，定义了元素的<code>margin</code>，<code>border</code>， <code>padding</code>是如何和相邻的block元素交互的。</p><a id="more"></a><h3 id="创建BFC"><a href="#创建BFC" class="headerlink" title="创建BFC"></a>创建BFC</h3><p><code>html</code>元素不是唯一具有创建BFC能力的元素。新的BFC和document的效果类似，就好像在一个主布局中开辟了一个迷你布局。浮动和清除浮动只会应用在位于相同格式上下文中的元素，而margin也只会collapse在位于相同格式上下文中的元素。</p><p>除了html，下面这些情况也会创建BFC</p><ol><li>浮动元素</li><li>绝对定位元素</li><li>有<code>display:inline-block</code>属性值的元素</li><li>table cells或者是有<code>display：table-cell</code>属性值的元素</li><li>table caption或者是有<code>display：table-caption</code>属性值的元素</li><li>块状元素的<code>overflow</code>属性的属性值是<code>visible</code>以外的值</li><li><code>display: flow-root</code></li><li>有<code>contain:layout,content或者strict</code>的元素</li><li>flex项目</li><li>grid项目</li><li>多列容器</li><li>有<code>column-span：all</code>的元素</li></ol><hr><p>下面是几个脱离正常流的例子</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动元素会脱离<code>正常流</code>，创建一个新的BFC。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/In_Flow_and_Out_of_Flow#Floated_Items" target="_blank" rel="noopener">这个浮动的例子</a></p><p>直接翻译这个例子下面的解释：你能看到紧随其后的段落的背景颜色穿过浮动元素。只有段落中的行盒子被压缩导致了文本环绕浮动元素的效果。<strong>段落的盒子依旧按照正常流的规则摆放</strong>，所以要使得浮动元素周围有空间，只能通过<code>给浮动元素增加外边距的办法</code>，给还处在正常流中的内容应用其他方法都做不到。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>给一个元素赋值<code>position: absolute</code>或者<code>position: fixed</code>都会将它从正常流中移除，并且它占有的空间也会一同被夺走。</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>给一个元素赋值<code>position:relative</code>表示他将会继续待在正常流中，然而你可以使用<code>offset</code>将它向四处推动。它在正常流中的空间依然会被保留。</p><hr><p>继续创建BFC的话题</p><p>下面这个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(244, 206, 247);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid rebeccapurple;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>I am a floated box!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am content inside the container.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个新的BFC会承载这个浮动元素。之前典型的做法是设置<code>overflow: auto</code>或者是设置其他非默认值<code>overflow: visible</code>。现在我们的<code>div</code>成为我们布局中的一个迷你布局了，<strong>任何子元素都将被它包含在其中</strong>。</p><p>使用<code>overflow</code>来创建BFC的问题在于<code>overflow</code>属性是用来告知浏览器你想如何处理满溢的内容（也就是说虽然能达到效果但是不合语义）。仅使用这个方法，在某些情况下，还会出现导航条或是修剪阴影的副作用。除此之外，对于后面的开发者也会带来阅读理解的问题，他们可能意识不到你是出于这个目的设置了这个属性在此，如果这样做了，最好留下注释。</p><p>一个完美的解决办法是使用<code>display: flow-root</code>这个新属性来创建新的BFC，这个属性不会带来任何副作用（看名字就知道干嘛用哒）。在<code>div</code>上使用<code>display: flow-root</code>，其中的所有子元素都将是这个新BFC的参与者，就不会出现浮动元素戳破其父元素（父元素有内容）或者父元素高度为零（父元素没有内容）的情况了。</p><p><strong>元素浮动父元素高度出现坍塌的原因：在计算页面排版的时候，如果没有设置父元素的高度，那么该父元素的高度是由他的子元素的高度撑开的。但是如果子元素是设置了浮动，脱离了文档流，那么父元素计算高度的时候就会忽略该子元素，就可能会出现父元素高度为零的情况。</strong></p><p><strong>新建BFC解决高度坍塌的原理：父元素在新建一个BFC的时候，其高度计算时，会把浮动子元素包进来。</strong></p><h3 id="inline-formatting-context"><a href="#inline-formatting-context" class="headerlink" title="inline formatting context"></a>inline formatting context</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Formatting_Contexts_Explained#An_inline_formatting_context" target="_blank" rel="noopener">链接</a></p><p>IFC（为啥没有这种缩写？这里就用这个缩写了）存在于其他格式上下文中，可以被想成是一个段落的上下文。这个段落创建了一个IFC，其中比如<code>strong</code>，<code>a</code>，<code>span</code>这些元素都是用在文本上的。</p><p><strong>盒模型</strong>不会完全用在IFC中的内容上。在水平书写的一行文本中，<strong>水平方向上的</strong><code>padding</code>，<code>borders</code>以及<code>margin</code>将会生效，将左右两侧的文本推开。<code>margin</code>在竖直方向上不会生效，<code>boder</code>和<code>padding</code>在竖直方向上会生效，但起不到推开上下内容的作用。</p><p>示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Before that night—<span class="tag">&lt;<span class="name">strong</span>&gt;</span>a memorable night<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, as it was to prove—hundreds of millions of people had watched the rising smoke-wreaths of their fires without drawing any special inspiration from the fact.”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他格式上下文"><a href="#其他格式上下文" class="headerlink" title="其他格式上下文"></a>其他格式上下文</h3><p>创建任何种类的格式上下文，都将改变位于其中的子元素的排布方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之二十 ——《继承和原型链》</title>
      <link href="/2018/08/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C%E5%8D%81-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/08/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C%E5%8D%81-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">链接地址</a></p><h3 id="获取和设置原型对象的标准方法"><a href="#获取和设置原型对象的标准方法" class="headerlink" title="获取和设置原型对象的标准方法"></a>获取和设置原型对象的标准方法</h3><ul><li>获取：<code>Object.getPrototypeOf()</code></li></ul><p>以后可以不用<code>__proto__</code>这个属性了。</p><a id="more"></a><h3 id="设置一个对象的属性"><a href="#设置一个对象的属性" class="headerlink" title="设置一个对象的属性"></a>设置一个对象的属性</h3><p>通常，设置一个对象的属性会创建这个对象自身的属性。但如果这个对象继承了<code>getter</code>或<code>setter</code>属性，就会出现例外。</p><p>比如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  <span class="keyword">get</span> b() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> c(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ins = <span class="built_in">Object</span>.create(o);</span><br><span class="line"></span><br><span class="line">ins.c = <span class="number">50</span>;<span class="comment">//这行代码并不会给ins设置自己的c属性，而是会沿着原型链找到作为`setter`的c属性，结果是ins中多了一个属性a，属性值为25。</span></span><br></pre></td></tr></table></figure><h3 id="不同方式创建对象以及导致的原型链"><a href="#不同方式创建对象以及导致的原型链" class="headerlink" title="不同方式创建对象以及导致的原型链"></a>不同方式创建对象以及导致的原型链</h3><ol><li><p>使用字面两创建</p><ul><li><code>var o = {a: 1};</code>, 原型链：<code>o ---&gt; Object.prototype ---&gt; null</code>。</li><li><code>var b = [&#39;yo&#39;, &#39;whadup&#39;, &#39;?&#39;];</code>, 原型链： <code>b ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</code>。</li><li><code>function f() {return 2}</code>, 原型链： <code>f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code>。</li></ul></li><li><p>使用构造函数创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertices = [];</span><br><span class="line">  <span class="keyword">this</span>.edges = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph.prototype = &#123;</span><br><span class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Object.create</code>创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (inherited)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</span><br><span class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// d ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); </span><br><span class="line"><span class="comment">// undefined, because d doesn't inherit from Object.prototype</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>class</code>创建</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sideLength, sideLength);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> sideLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = newLength;</span><br><span class="line">    <span class="keyword">this</span>.width = newLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a><code>hasOwnProperty</code></h3><p>这个属性定义在<code>Object.prototype</code>上，是js中唯一一个处理对象属性且不会贯穿原型链的处理方法。</p><h3 id="扩展原型链的方法比较"><a href="#扩展原型链的方法比较" class="headerlink" title="扩展原型链的方法比较"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#Summary_of_methods_for_extending_the_protoype_chain" target="_blank" rel="noopener">扩展原型链的方法比较</a></h3><p>MDN上推荐使用下面两种方法进行原型链的扩展。不推荐使用<code>Object.setPrototypeOf</code>以及<code>__proto__</code>。</p><p>另外感觉<code>class</code>也是一种实现扩展原型链的方法，感觉这里落下了。</p><ol><li>传统的方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="keyword">new</span> foo;</span><br><span class="line">proto.bar_prop = <span class="string">'bar val'</span>;</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>Object.create</code></li></ol><p>下面的例子显示，<code>Object.create</code>可以传入第二个参数，表示添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(foo.prototype);</span><br><span class="line">proto.bar_prop = <span class="string">'bar val'</span>;</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.prototype = &#123;</span><br><span class="line">  foo_prop: <span class="string">'foo val'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(</span><br><span class="line">  foo.prototype,</span><br><span class="line">  &#123;</span><br><span class="line">    bar_prop: &#123;</span><br><span class="line">      value: <span class="string">'bar val'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">bar.prototype = proto;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="keyword">new</span> bar;</span><br></pre></td></tr></table></figure><h3 id="prototype和Object-getPrototypeOf"><a href="#prototype和Object-getPrototypeOf" class="headerlink" title="prototype和Object.getPrototypeOf"></a><code>prototype</code>和<code>Object.getPrototypeOf</code></h3><p>当你调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>时，javascript实际执行的是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.[[Prototype]] = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十九 ——《闭包》</title>
      <link href="/2018/08/14/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B9%9D-%E9%97%AD%E5%8C%85/"/>
      <url>/2018/08/14/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B9%9D-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">链接地址</a></p><h3 id="关于lexical的解释"><a href="#关于lexical的解释" class="headerlink" title="关于lexical的解释"></a>关于<code>lexical</code>的解释</h3><blockquote><p>The word “lexical” refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope.</p></blockquote><a id="more"></a><h3 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h3><blockquote><p>A closure is the combination of a function andn the lexical environment within which that function was declared.</p></blockquote><p><strong>闭包具有封装和隐藏数据的优点。</strong></p><p>比如下面这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p><code>add5</code>和<code>add10</code>都是闭包，它们共享相同的函数体定义，但是存储了不同的词法环境。在<code>add5</code>的词法环境中，<code>x</code>是5；在<code>add10</code>的词法环境中，<code>x</code>是10。</p><p>再比如下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;   </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 0</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 2</span></span><br><span class="line">counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(counter.value()); <span class="comment">// logs 1</span></span><br></pre></td></tr></table></figure><p>在前面的例子中，每一个闭包都有它自己的词法环境。然而，这里我们创建了一个单一的词法环境，这个环境被三个函数共享。这个共享的词法环境是在一个匿名函数的函数体中创建的，这个匿名函数创建完就执行了。这个词法环境包含两个私有条目：一个叫做<code>privateCounter</code>的变量以及一个叫做<code>changeBy</code>的函数。这两个私有条目都不可以从匿名函数外访问到。相反，它们只能被匿名函数返回的三个公共函数访问。</p><h3 id="一个常见的闭包错误"><a href="#一个常见的闭包错误" class="headerlink" title="一个常见的闭包错误"></a>一个常见的闭包错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"help"</span>&gt;Helpful notes will appear here&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;E-mail: &lt;input type="text" id="email" name="email"&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;Name: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;p&gt;Age: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"age"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>原因：传给<code>onfocus</code>的函数是闭包。循环创建了这三个闭包，但这三个共享了相同的唯一的词法环境,这个此法环境有一个改变中的变量<code>item.help</code>。<strong>当<code>onfocus</code>的回调函数执行的时候，<code>item.help</code>的值才会确定。(只有函数执行的时候才会上溯搜寻参数)</strong>而此时，循环已经结束，被三个闭包共享的变量对象<code>item</code>指向<code>helpText</code>数组的最后一项。</p><p>解决的关键是让这<strong>三个闭包不共享相同的词法环境</strong>。</p><ol><li>方法1</li></ol><p>在循环词法环境和比包之间创建一个过渡的嵌套环境，立即执行保存了正确的参数，同时也给闭包创建了不同于其他两个比包的词法环境。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelpCallback</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="2"><li>方法2</li></ol><p>使用匿名闭包，和上面的方法本质相同，这种方法是把循环的整个过程通过匿名立即执行函数保存成一个区别于其它两个的词法环境。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">       <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); <span class="comment">// Immediate event listener attachment with the current value of item (preserved until iteration).</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="3"><li>方法3</li></ol><p>使用<code>let</code>，每个闭包绑定了块作用域的变量，这就不再需要闭包创建独立的词法环境了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ol start="4"><li>方法4</li></ol><p>使用<code>forEach</code>替代<code>for</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">  helpText.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(text.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(text.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十八 ——《相等判断》</title>
      <link href="/2018/08/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AB-%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD/"/>
      <url>/2018/08/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AB-%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">链接地址</a></p><h3 id="loose-equality"><a href="#loose-equality" class="headerlink" title="loose equality"></a>loose equality</h3><p><img src="/images/js/7.png" alt="==转换"></p><ol><li><code>Number</code>，<code>String</code>，<code>Boolean</code>类型在和<code>Number</code>，<code>String</code>，<code>Boolean</code>类型比较的时候，如果两个不是相同类型，会将两个比较的值都转成数字后再进行比较。转换时，相当于使用<code>+</code>。</li></ol><a id="more"></a><ol start="2"><li><p><code>Number</code>，<code>String</code>，<code>Boolean</code>类型在和<code>Object</code>类型比较的时候，会把<code>Object</code>类型转换成基础类型。转换过程会调用<code>A.toString</code>和<code>A.valueOf</code>这两个方法，不同类型进行转换时，这两个方法调用的顺序不同。转换顺序详见<a href="http://ecma-international.org/ecma-262/5.1/#sec-8.12.8" target="_blank" rel="noopener">规范</a>。</p><p> <em>此处要加上几个关于对象转换成基本值的示例，一步步按转换步骤写。暂时没有找到…明天看下犀牛书的说明好了。</em></p><p> 犀牛书原文：</p><blockquote><p>“+”和“=”应用的对象到原始值的转换包含日期对象的一种特殊情形。日期类是js语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说，<strong>对象到原始值的转换基本上是对象到数字的转换</strong><code>（首先调用valueof()）</code>，日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString返回的原始值将被直接使用，而不会被强制转换为数字或字符串。</p></blockquote><blockquote><p>对象转换为数字的细节解释了为什么空数组会被转换为数字0以及为什么具有单个元素的数组同样会被转换成一个数字。数组集成了默认的valueOf方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换成为空字符串，空字符串转为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换为数字。</p></blockquote></li></ol><h3 id="同值相等判断"><a href="#同值相等判断" class="headerlink" title="同值相等判断"></a>同值相等判断</h3><p><code>Object.is()</code>除下面的特殊情况外，基本类似<code>===</code>的比较结果。</p><p><strong>通常要避免使用这个函数，比较NaN时，可以使用isNaN函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="严格相等比较算法"><a href="#严格相等比较算法" class="headerlink" title="严格相等比较算法"></a><a href="http://ecma-international.org/ecma-262/5.1/#sec-11.9.6" target="_blank" rel="noopener">严格相等比较算法</a></h3><p>The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:</p><ol><li>If Type(x) is different from Type(y), return false.</li><li>If Type(x) is Undefined, return true.</li><li>If Type(x) is Null, return true.</li><li>If Type(x) is Number, then<ol><li>If x is NaN, return false.</li><li>If y is NaN, return false.</li><li>If x is the same Number value as y, return true.</li><li>If x is +0 and y is −0, return true.</li><li>If x is −0 and y is +0, return true.</li><li>Return false.</li></ol></li><li>If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.</li><li>If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.</li><li>Return true if x and y refer to the same object. Otherwise, return false.</li></ol><h3 id="绝对相等比较算法"><a href="#绝对相等比较算法" class="headerlink" title="绝对相等比较算法"></a><a href="http://ecma-international.org/ecma-262/5.1/#sec-11.9.3" target="_blank" rel="noopener">绝对相等比较算法</a></h3><p>共10个steps，详见链接。下面是一些注意：</p><ol><li><p>Given the above definition of equality:</p><ul><li>String comparison can be forced by: “” + a == “” + b.</li><li>Numeric comparison can be forced by: +a == +b.</li><li>Boolean comparison can be forced by: !a == !b.</li></ul></li><li><p>The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other. For Example:</p><ul><li>new String(“a”) == “a” and “a” == new String(“a”)are both true.</li><li>new String(“a”) == new String(“a”) is false.</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十七 ——《null&amp;undefined》</title>
      <link href="/2018/08/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%83-null&amp;undefined/"/>
      <url>/2018/08/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%83-null&amp;undefined/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">链接地址(评论区RedNax的评论)</a></p><p>感觉这段评论将<code>undefined</code>和<code>null</code>的不同说的很清楚，而且也说明白了应该在什么地方使用。</p><p>react的源码<code>ReactElement.js</code>中的<code>createElement</code>函数中就有如下定义：</p><p>如此看来这样的定义才是合理的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> source = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li><p>null 和 undefined在现代JS语义里面是有明确区别的：</p><p> null 表示一个值被定义了，定义为“空值”；</p><p> undefined 表示根本不存在定义。</p><p> 所以设置一个值为 null 是合理的，如objA.valueA = null;但设置一个值为 undefined 是不合理的，如objA.valueA = undefined; // 应该直接使用 delete objA.valueA; 任何一个存在引用的变量值为undefined都是一件错误的事情。</p><p> 这样判断一个值是否存在，就可以用objA.valueA === undefined // 不应使用 null 因为 undefined == null，而 null 表示该值定义为空值。</p><p> 这个语义在JSON规范中被强化，这个标准中不存在 undefined 这个类型，但存在表示空值的 null 。在一些使用广泛的库（比如jQuery）中的深度拷贝函数会忽略 undefined 而不会忽略 null ，也是针对这个语义的理解。</p></li></ol><ol start="2"><li><p>JS 中同时存在 undefined 和 null 是合理的。</p><p> 首先在 Java 中不存在 undefined 是很合理的：Java 是一个静态类型语言，对于 Java 来说不可能存在一个“不存在”的成员（不存在的话直接就编译失败了），所以只用 null 来表示语义上的空值。而 JavaScript 是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），所以这就要一个值来表示对某成员的 getter 是取不到值的。</p></li></ol><ol start="3"><li><p>typeof null 结果是 ”object“ 更像是一个设计失误</p><p> 因为 typeof null === “object” 而认为 null 语义是表示空对象是个不谨慎的猜测，感觉像是先射箭后画靶一般。简单的反例：在强类型数据交换协议 odata（<a href="http://www.odata.org/）的" target="_blank" rel="noopener">http://www.odata.org/）的</a> JSON 格式中，即使一个成员定义为特定类型（比如string），也可以设置其值为 null 来表示这个值是空值，这可不是表示这个成员是空对象，只是说值为空而已（和空字符串、0、false有所区别）。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十六 ——《客户端内存》</title>
      <link href="/2018/07/30/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%85%E5%AD%98/"/>
      <url>/2018/07/30/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%85%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" target="_blank" rel="noopener">链接地址</a></p><p>客户端存储由js的api构成，这些api允许你在客户端存储数据，当需要的时候再获取它们，比如：</p><ol><li><p>个性化站点</p></li><li><p>保存先前站点的活动状态，比如从先前的session中存储购物车中的内容，或者记住用户先前是否已经登录</p></li><li><p>保存数据或是assets到本地，以便离线使用或者同样的网站再次加载能以更快的速度</p></li><li><p>保存网页应用生成的文件到本地以便离线使用</p></li></ol><p>客户端存储在现代浏览器中可以取代cookie诶。</p><a id="more"></a><ol><li><p>web storage</p><p>用来存储简单的小型数据。web storage包含两种结构，一种是sessionStorage，一种是localStorage。</p><ul><li><p>sessionStorage：数据存在的时长是浏览器打开的这段时期，关闭浏览器则数据丢失；</p></li><li><p>localStorage：使用这种类型保存数据，即使浏览器关闭再打开数据也依然存在。<strong>localStorage是按domain分隔的！！！</strong></p><ol><li><p>存储数据：<code>localStorage.setItem(&#39;name&#39;, &#39;bobo&#39;)</code></p></li><li><p>拿到数据：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = localStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line">myName</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><pre><code>3. 移除数据：`localStorage.removeItem(&apos;name&apos;);`</code></pre><ol start="2"><li><p>Indexed DB</p><p>用来存储复杂的大型数据。</p><p>一个简单的使用案例：</p><ol><li><p>创建一个变量用来存储数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db；</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>创建IDB是异步的操作，所以一般写在<code>window.onload</code>的回调函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>创建名叫<code>notes</code>的第<code>1</code>个版本的数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">'notes'</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>handle创建结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">'notes'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Database failed to open'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Database opened successfully'</span>);</span><br><span class="line"></span><br><span class="line">    db = request.result;</span><br><span class="line"></span><br><span class="line">    displayData();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>DB说IDB暂且用不到，搁置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十五 ——《从服务器获取数据》</title>
      <link href="/2018/07/27/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%94-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/07/27/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%94-%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>XMLHttpRequest</p><p> 使用步骤</p><ol><li><p>使用<code>XMLHttpRequest()</code>构造函数创建一个新的请求对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></li></ol></li></ol><a id="more"></a><pre><code>2. 使用`open()`方法指定用于从网络请求资源的**方法**以及**url**    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br></pre></td></tr></table></figure>3. 设置响应类型（XHR默认返回文本）    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.responseType = <span class="string">'text'</span>;</span><br></pre></td></tr></table></figure>4. XHR使用`onload`事件处理来处理响应    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    poemDisplay.textContent = request.response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>5. 发出请求    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.send()</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>fetch</p><ol><li><p>速览<br> 使用fetch替换上面的XHR的代码：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">        poemDisplay.textContent = text;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> fetch返回一个<code>promise</code>对象！在fetch后面的<code>then（）</code>函数将解析从服务器返回的响应。</p><p> 当fetch（）的promise解析时，这个函数会自动将响应从服务器传递给参数。在函数内部，我们获取响应并运行其<code>text()</code>方法。这将响应作为原始文本返回。<code>text()</code>返回一个promise对象，所以我们连接另外一个<code>.then()</code>在她上面，在其中我们定义了一个函数来接收text()promise解析的生文本。</p><p> 当使用链式写法：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> response.text()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">poemDisplay.textContent = text;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 注意上面前一个then函数的回调函数中有一个<code>return</code>。</p></li><li><p>使用fetch</p><ol><li><p>注意事项</p><ol><li><p>当接收到一个代表错误的http请求状态码时，从<code>fetch()</code>返回的promise<strong>不会被标记为reject</strong>，即使该http响应的状态码是404或500。相反，它会将promise状态标记为resolve（但是会将resolve的返回值ok属性设置为false），仅当网络故障时或请求被阻止时，才会标记为reject。</p></li><li><p>默认情况下，fetch不会从服务端发送或接收任何cookies，如果站点依赖于用户的session，则会导致未经认证的请求（要发送cookies，必须设置<code>credentials</code>选项）。</p></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十三 ——《元编程》</title>
      <link href="/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-%E5%85%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%89-%E5%85%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming" target="_blank" rel="noopener">链接地址</a></p><a id="more"></a><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理对象</a></p><p> <code>let p = new Proxy(target, handler);</code></p><ul><li><p>target表示用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></li><li><p>handler表示一个对象，其属性是当执行一个操作时定义代理的行为的函数。（handler的属性键都是对象的原生函数？感觉是哦）</p></li></ul><ol><li><p>使用<code>get</code>关键字，当对象中不存在属性名时，返回缺省值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">37</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  p = <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b); <span class="comment">// 1, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure></li><li><p>无操作转发代理</p><p> 使用一个原生的js对象，代理会将所有应用到它的操作转发到这个对象上。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>; <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);  <span class="comment">// 37  操作已经被正确转发</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>3. 验证    通过代理验证向一个对象传的值，这个例子使用`set`。    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">'young'</span>; <span class="comment">// Uncaught TypeError: The age is not an integer</span></span><br><span class="line"></span><br><span class="line">page.age = <span class="number">300</span>; <span class="comment">// Uncaught RangeError: The age seems invalid</span></span><br></pre></td></tr></table></figure>4. 撤销proxy    Proxy.revocable()方法被用来创建可撤销的Proxy对象。这意味着代理可以通过revoke函数来撤销并且关闭代理。此后，代理上的任意的操作都会导致TypeError。    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> revocable = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"[["</span> + name + <span class="string">"]]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> proxy = revocable.proxy;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// "[[foo]]"</span></span><br><span class="line"></span><br><span class="line">revocable.revoke();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError is thrown</span></span><br><span class="line">proxy.foo = <span class="number">1</span>           <span class="comment">// TypeError again</span></span><br><span class="line"><span class="keyword">delete</span> proxy.foo;       <span class="comment">// still TypeError</span></span><br><span class="line"><span class="keyword">typeof</span> proxy            <span class="comment">// "object", typeof doesn't trigger any trap</span></span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>反射</p><p> 这个mdn讲的很粗略，日后看下阮老师的<a href="http://es6.ruanyifeng.com/#docs/reflect" target="_blank" rel="noopener">书</a>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十四 ——《客户端web api》</title>
      <link href="/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-%E5%AE%A2%E6%88%B7%E7%AB%AFweb_api/"/>
      <url>/2018/07/25/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E5%9B%9B-%E5%AE%A2%E6%88%B7%E7%AB%AFweb_api/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>javascript api的共同点</p><ol><li><p>基于对象</p></li><li><p>有可识别的入口点</p></li><li><p>它们使用事件来处理状态的变化</p></li><li><p>它们在适当的地方有额外的安全机制</p></li></ol></li></ol><a id="more"></a><ol start="2"><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents" target="_blank" rel="noopener">操作文档</a></p><ol><li><p>document.querySelector(selectors)</p><ol><li><p>文档对象模型Document引用的querySelector()方法返回文档中与指定选择器或选择器组匹配的第一个 html元素Element。 如果找不到匹配项，则返回null。</p></li><li><p>selectors:包含一个或多个要匹配的选择器的 DOM字符串DOMString。 该字符串必须是有效的CSS选择器字符串</p></li><li><p><strong>使用深度优先的遍历顺序</strong></p></li><li><p>返回Element对象</p></li></ol></li><li><p>document.querySelectorAll(selectors)</p><ol><li><p><strong>使用深度优先的遍历顺序</strong></p></li><li><p>selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串</p></li><li><p>返回一个<strong>静态的</strong> NodeList 类型的对象</p></li></ol></li><li><p>document.createElement();</p><p> <code>var para = document.createElement(&#39;p&#39;);</code></p></li><li><p>Node.appendChild()</p><p> <code>sect.appendChild(para);</code></p></li><li><p>Document.createTextNode()</p><p> 创建一个文本节点</p></li><li><p>node.textContent</p></li><li><p>node.innerText</p></li><li><p>node.innerHTML</p><p> 返回文本内容和标签</p></li><li><p>Node.removeChild()</p><p> 当知道要删除节点以及父节点的时候可以使用这个方法：</p><p> <code>sect.removeChild(linkPara);</code></p></li><li><p>删除一个仅基于自身引用的节点</p><p><code>linkPara.parentNode.removeChild(linkPara);</code></p></li><li><p>Node.cloneNode(deep)</p><ol><li><p>deep: 如果为true，表示执行深复制，当前节点的所有子节点也会一并复制</p></li><li><p>如果deep参数设为false,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的Text节点</p></li><li><p>这个函数复制的节点信息包括：克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=”alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件</p></li></ol></li><li><p>HTMLElement.style</p><ol><li>使用这个属性的结果是样式都是<strong>内联样式</strong>。</li></ol></li><li><p>Element.setAttribute()</p><ol><li>使用这个方法设置的样式是普通的css样式表的样式：<code>Element.setAttribute(class, className)</code>。</li></ol></li><li><p>获取视窗尺寸</p><p><code>window.innerWidth</code>：视窗宽度</p><p><code>window.innerHeight</code>:视窗高度</p></li><li><p>视窗的resize事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    WIDTH = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">    HEIGHT = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    div.style.width = WIDTH + <span class="string">'px'</span>;</span><br><span class="line">    div.style.height = HEIGHT + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>给DOM添加节点需要上述1、2、3、4、5五个方法;</p><p>  下面这个例子里添加文本使用的是Node.textContent属性。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sect = <span class="built_in">document</span>.querySelector(<span class="string">'section'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">para.textContent = <span class="string">'We hope you enjoyed the ride.'</span>;</span><br><span class="line"></span><br><span class="line">sect.appendChild(para);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">' — the premier source for web development knowledge.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> linkPara = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">linkPara.appendChild(text);</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十二 ——《迭代器和生成器》</title>
      <link href="/2018/07/24/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2018/07/24/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%BA%8C-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>迭代器</p><p> 迭代器是一个<strong>对象</strong>，知道如何每次访问集合中的一项，并跟踪该序列中的当前位置。它提供一个<code>next()</code>方法，用来返回序列中的下一项。这个方法返回包含两个属性：<code>done</code>和<code>value</code>。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">          &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">          &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'yo'</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'ya'</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().done); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>生成器</p><p> 迭代器需要显式地维护其内部状态，<strong>生成器</strong>允许自定义一个包含自有迭代算法的函数，同时它可以自动维护自己的状态。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = idMaker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>可迭代对象</p><p> 为了实现可迭代，一个对象必须实现<code>@@iterator</code>方法，就是说这个对象或其原型链中的一个对象必须具有带<code>Symbol.iterator</code>键的属性。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">    myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    [...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 高级生成器</span><br><span class="line"></span><br><span class="line">    The next() 方法也接受可用于修改生成器内部状态的值。传递给next()的值将被视为暂停生成器的最后一个<span class="keyword">yield</span>表达式的结果。</span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">    使用 next(x) 重新启动 fibonacci 序列生成器：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function* fibonacci() &#123;</span></span><br><span class="line"><span class="string">      var fn1 = 0;</span></span><br><span class="line"><span class="string">      var fn2 = 1;</span></span><br><span class="line"><span class="string">      while(true) &#123;</span></span><br><span class="line"><span class="string">        var current = fn1;</span></span><br><span class="line"><span class="string">        fn1 = fn2;</span></span><br><span class="line"><span class="string">        fn2 = current + fn1;</span></span><br><span class="line"><span class="string">        var reset = yield current;</span></span><br><span class="line"><span class="string">        if (reset) &#123;</span></span><br><span class="line"><span class="string">          fn1 = 0;</span></span><br><span class="line"><span class="string">          fn2 = 1;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var sequence = fibonacci();</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 0</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 2</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 3</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 5</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 8</span></span><br><span class="line"><span class="string">    console.log(sequence.next(true).value); // 0</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 1</span></span><br><span class="line"><span class="string">    console.log(sequence.next().value);     // 2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十一 ——《对象模型的细节》</title>
      <link href="/2018/07/23/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2018/07/23/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81%E4%B8%80-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="noopener">链接地址</a></p><ol><li>JavaScript 是一种基于原型而不是基于类的面向对象语言。</li></ol><a id="more"></a><ol start="2"><li><p>对象模型使用（创建Employee层级结构）</p><p> Employee的层级结构见下图：</p><p> <img src="/images/js/6.png" alt="employee层级结构"></p><ol><li><p>创建Employee的构造函数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">"general"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Manager和WorkerBee</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Manager</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.reports = [];<span class="comment">//增加了reports属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Manager.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBee</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Employee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.projects = []<span class="comment">//增加了projects属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerBee.prototype = <span class="built_in">Object</span>.create(Employee.prototype);</span><br></pre></td></tr></table></figure></li><li><p>创建SalesPerson和Engineer</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SalesPerson</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'sales'</span>;<span class="comment">//给这个属性重新赋值</span></span><br><span class="line">  <span class="keyword">this</span>.quota = <span class="number">100</span>;<span class="comment">//增加quota属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SalesPerson.prototype = <span class="built_in">Object</span>.create(WorkerBee.prototype);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  WorkerBee.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.dept = <span class="string">'engineering'</span>;<span class="comment">//给这个属性重新赋值</span></span><br><span class="line">  <span class="keyword">this</span>.machine = <span class="string">''</span>;<span class="comment">//增加了machine属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = <span class="built_in">Object</span>.create(WorkerBee.prototype);</span><br></pre></td></tr></table></figure></li><li><p>利用构造函数创建对象</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mark = <span class="keyword">new</span> WorkerBee;</span><br></pre></td></tr></table></figure><p> 上面的代码经历了下面的创建过程：</p><blockquote><p>当javascript发现<code>new</code>操作符时，它会创建一个<strong>通用对象</strong>,并将其作为关键字<code>this</code>的值传递给<code>WorkerBee</code>的构造函数。该构造函数显式地设置projects属性的值，然后隐式地将其内部的<code>[[Prototype]]</code>属性设置为<code>WorkerBee.prototype</code>的值。内置的<code>[[Prototype]]</code>属性决定了用于返回属性值的原型链。一旦这些属性设置完成，javascript返回新创建的对象，然后赋值语句会将变量mark的值指向该对象。</p></blockquote><blockquote><p>这个过程不会显式的将 mark所继承的原型链中的属性值作为本地变量存放在 mark 对象中。当请求属性的值时，JavaScript 将首先检查对象自身中是否存在属性的值，如果有，则返回该值。如果不存在，JavaScript会检查原型链（使用内置的 [[Prototype]] 属性）。如果原型链中的某个对象包含该属性的值，则返回这个值。如果没有找到该属性，JavaScript 则认为对象中不存在该属性。</p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mark.name = <span class="string">""</span>;</span><br><span class="line">mark.dept = <span class="string">"general"</span>;</span><br><span class="line">mark.projects = [];</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>    &gt;mark 对象从`mark.__proto__`中保存的原型对象中继承了`name`和`dept`属性的值。并由`WorkerBee`构造器函数为`projects`属性设置了本地值。 这就是`JavaScript`中的属性和属性值的继承。    使用`Object.hasOwnProperty`检验上面三个属性，返回`true`，可见不论是构造函数显式设置的属性还是通过原型链隐式传回的属性，这些属性都是对象自身的属性，如果此时修改这些属性，只是针对这个对象，不会影响原型，不会影响相同原型的其他对象。5. 对象模型的另一种使用    1. 创建可以传参数的构造函数     <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, dept</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dept= dept || <span class="string">'general'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    2. 在下一层构造函数中调用上层构造函数    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WorkerBee</span>(<span class="params">name, dept, projs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Employee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, dept);</span><br><span class="line">  <span class="keyword">this</span>.projects = projs || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerBee.prototype = <span class="keyword">new</span> Employee;</span><br></pre></td></tr></table></figure>    注意上面的代码！先将`Employee`赋值给`this.base`，然后再通过`this.base`调用，这时，Employee内部的`this`指向`this.base`中的`this`也就是使用`new`关键字创建的对象。    3. 使用`new`调用构造函数创建对象    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mark = <span class="keyword">new</span> WorkerBee(<span class="string">"smith, mark"</span>, <span class="string">'training'</span>, [<span class="string">'javascript'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params">name, projs, mach</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = WorkerBee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, <span class="string">"engineering"</span>, projs);</span><br><span class="line">  <span class="keyword">this</span>.machine = mach || <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Engineer.prototype = <span class="keyword">new</span> WorkerBee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Engineer(<span class="string">"Doe, Jane"</span>, [<span class="string">"navigator"</span>, <span class="string">"javascript"</span>], <span class="string">"belau"</span>);</span><br></pre></td></tr></table></figure>    javascript会按以下步骤执行:    1. new 操作符创建了一个新的通用对象，并将其 __proto__ 属性设置为 Engineer.prototype。    2. new 操作符将该新对象作为 this 的值传递给 Engineer 构造器。    3. 构造器为该新对象创建了一个名为 base 的新属性，并指向 WorkerBee 的构造器。这使得 WorkerBee 构造器成为 Engineer 对象的一个方法。    4. 构造器调用`base`方法，将传给该构造器的参数中的两个，作为参数传递给base方法，同事还传递一个字符串参数`engineering`。显式地在构造器中使用`engineering`表明所有Engineer对象继承的`dept`属性具有相同的值，且该值重载了继承自`Employee`的值。    5. 因为`base`是`Engineer`的一个方法，在调用`base`时，javascrit将在步骤1中创建的对象绑定给`this`关键字。这样，`WorkerBee`函数接着将`Doe， Jane`和`engineering`参数传递给`Employee`构造器函数。当从`Employee`构造器函数返回时，`WorkerBee`函数用剩下的参数设置`projects`属性。    6. 当从`base`方法返回后，`Engineer`构造器将对象的`machine`属性初始化为`belau`    7. 当从构造器返回时，javascript将新对象赋值给`jane`变量。    **重要说明：**    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Engineer</span> (<span class="params">name, projs, mach</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = WorkerBee;</span><br><span class="line">  <span class="keyword">this</span>.base(name, <span class="string">"engineering"</span>, projs);</span><br><span class="line">  <span class="keyword">this</span>.machine = mach || <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Engineer(<span class="string">"Doe, Jane"</span>, [<span class="string">"navigator"</span>, <span class="string">"javascript"</span>], <span class="string">"belau"</span>);</span><br><span class="line">Employee.prototype.specialty = <span class="string">"none"</span>;</span><br></pre></td></tr></table></figure>    如果代码写成上面这样，对象jane不会继承speciality属性。必须显式地设置原型才能确保动态的继承，也就是添加下面这行代码：    `Engineer.prototype = new WorkerBee;`    此刻，对象jane就可以动态的继承speciality属性了。</code></pre><ol start="3"><li><p>instance操作符</p><p> instanceof 操作符可以用来将一个对象和一个函数做检测，如果对象继承自函数的原型，则该操作符返回真。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http查漏补缺之二 《cookie》</title>
      <link href="/2018/07/21/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-cookie/"/>
      <url>/2018/07/21/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-cookie/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">mdn地址</a></p><ol><li><p>set-cookie响应头部</p><p> 服务器使用Set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。</p><p> 写法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>cookie请求头部</p><p> 现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送给服务器。</p></li><li><p>会话期cookie</p><p> 会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。</p></li><li><p>持久性cookie</p><p> 和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p><p> <strong>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</strong></p></li><li><p>secure标记</p><p> cookie只能通过https协议发送。</p></li><li><p>httpOnly标记</p><p> cookie无法被<code>document.cookie</code>获取，只能发送给服务端，可以避免跨域脚本攻击（XSS）。</p></li><li><p>Cookie的作用域</p><p> domain和path这两个标识符定义了Cookie的作用域。</p><p> Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。</p><blockquote><p>例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p></blockquote><p> Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</p><blockquote><p>例如，设置 Path=/docs，则以下地址都会匹配：<br> /docs<br> /docs/Web/<br> /docs/Web/HTTP</p></blockquote></li><li><p>第三方cookie</p><p> 如果Cookie的域和页面的域不同，则称之为第三方Cookie；</p><p> 如果Cookie的域和页面的域相同，那么我们称这个Cookie为第一方Cookie。</p></li><li><p>涉及cookie的安全问题</p><ol><li><p>xss（跨站攻击）</p><p> 在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。</p></li><li><p>csrf（跨站请求伪造）</p><p> 比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求。当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之十——《使用对象》</title>
      <link href="/2018/07/18/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/18/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%8D%81-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>JavaScript中的对象只能使用String类型作为键类型。</p></li><li><p>对对象的枚举</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function showProps(obj, objName) &#123;</span><br><span class="line">  var result = &quot;&quot;;</span><br><span class="line">  for (var i in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">        result += objName + &quot;.&quot; + i + &quot; = &quot; + obj[i] + &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的列子使用了<code>for in</code> 和 <code>hasOwnProperty</code>，自己几乎没有这样写过代码，都是先用<code>Object.keys</code>获取所有的键，然后循环键组成的数组进行操作。下次可以试一波。</p></li></ol><a id="more"></a><ol start="3"><li><p>枚举一个对象属性的三种方法</p><ol><li><p><code>for in</code>依次访问一个对象及其原型链中所有可枚举的属性。</p></li><li><p><code>Object.keys(o)</code>返回一个对象 o 自身包含（不包括原型中）的所有属性的名称的数组。</p></li><li><p><code>Object.getOwnPropertyNames(o)</code>该方法返回一个数组，它包含了对象 o 所有拥有的属性（无论是否可枚举）的名称。<strong>注意！不论可否枚举！！！不论可否枚举！！！不论可否枚举！！！</strong></p></li></ol></li><li><p>创建对象的方法</p><ol><li><p>使用对象字面两</p></li><li><p>使用构造函数</p></li><li><p>使用 Object.create 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Animal properties and method encapsulation</span><br><span class="line">var Animal = &#123;</span><br><span class="line">  type: &quot;Invertebrates&quot;, // Default value of properties</span><br><span class="line">  displayType : function() &#123;  // Method which will display type of Animal</span><br><span class="line">    console.log(this.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create new animal type called animal1 </span><br><span class="line">var animal1 = Object.create(Animal);</span><br><span class="line">animal1.displayType(); // Output:Invertebrates</span><br><span class="line"></span><br><span class="line">// Create new animal type called Fishes</span><br><span class="line">var fish = Object.create(Animal);</span><br><span class="line">fish.type = &quot;Fishes&quot;;</span><br><span class="line">fish.displayType(); // Output:Fishes</span><br></pre></td></tr></table></figure></li></ol></li><li><p>getters与setters</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 7,</span><br><span class="line">  get b() &#123; </span><br><span class="line">    return this.a + 1;</span><br><span class="line">  &#125;,</span><br><span class="line">  set c(x) &#123;</span><br><span class="line">    this.a = x / 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.a); // 7</span><br><span class="line">console.log(o.b); // 8</span><br><span class="line">o.c = 50;</span><br><span class="line">console.log(o.a); // 25</span><br></pre></td></tr></table></figure></li></ol><pre><code>1. 上面定义getters使用了get2. 定义setters使用了set3. 使用getter和setter时的方式和普通对象属性相同</code></pre><ol start="6"><li><p>第二种使用getters和setters的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d = Date.prototype;</span><br><span class="line">Object.defineProperty(d, &quot;year&quot;, &#123;</span><br><span class="line">  get: function() &#123; return this.getFullYear() &#125;,</span><br><span class="line">  set: function(y) &#123; this.setFullYear(y) &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>delete操作符</p><p> <strong>注意！</strong><code>delete</code>操作符只能用于删除一个不是继承来的属性。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http查漏补缺之一 《缓存》</title>
      <link href="/2018/07/18/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E7%BC%93%E5%AD%98/"/>
      <url>/2018/07/18/http%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>下面主要关于代理服务器的缓存。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">mdn地址</a></p><a id="more"></a><ol><li><p>http缓存</p><p> 使用<code>Cache-Control</code>控制缓存，不同值之间使用逗号和空格分割。</p><ol><li><p>强制确认缓存</p><p> <code>Cache-Control: no-cache</code> ：每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。</p><p> <em>MDN的页面请求头中都带有这个消息头，比如这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">页面</a>。</em></p></li><li><p>缓存过期机制</p><p> <code>Cache-Control: max-age=31536000</code>：max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</p><p> <em>比如这个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">页面</a>的css文件</em></p><p> <img src="/images/http/1.png" alt="缓存过期时间"></p></li><li><p>禁止进行缓存</p><p> <code>Cache-Control: no-store</code></p></li><li><p>缓存验证确认</p><p> <code>Cache-Control: must-revalidate</code></p><p> 如果缓存的响应头信息里含有”Cache-control: must-revalidate”的定义，在浏览的过程中（感觉此处的浏览过程中指的是正常的接到响应）也会触发缓存验证。</p></li></ol></li><li><p>Expires</p><p> Expires响应头包含日期/时间，即在此时间之后，响应过期。</p><p> 如果在<code>Cache-Control</code>相应头设置了 <em>max-age</em> 那么Expires头会被忽略。</p></li><li><p>缓存新鲜度</p><p> 由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。</p><p> 服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。</p><p> 驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个<code>If-None-Match</code>头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 <code>304 (Not Modified)</code>（该响应不会有带有实体信息），<strong>则表示此资源副本是新鲜的</strong>，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。</p><p> 见下图描述：</p><p> <img src="/images/http/HTTPStaleness.png" alt="缓存新鲜度"></p></li><li><p>计算缓存寿命</p><ol><li><p>当有比如<code>Cache-control: max-age=N的请求头</code>这种的特定头，相应的缓存的寿命就是N。</p></li><li><p>如果没有 <code>Cache-control</code>请求头，会去查看是否包含<code>Expires</code>属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。<code>Expires</code>表示一个日期时间，如果<code>Date</code>表示的日期和时间大于<code>Expires</code>则表示缓存已经过期。</p></li><li><p>如果既没有<code>Cache-control</code>， 也没有<code>Expires</code>，就会查找头里的<code>Last-Modified</code>信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10。Date表示消息生成的日期和时间。</p><p><img src="/images/http/2.png" alt="第三种计算缓存时间的方法"></p></li></ol></li><li><p>ff和chrome查看缓存的方法</p><ul><li><p>Firefox: Navigate to about:cache.</p></li><li><p>Chrome: Navigate to chrome://cache.</p></li></ul></li><li><p>计算过期时间</p><p> MDN上给出的计算公式如下：</p><blockquote><p>expirationTime = responseTime + freshnessLifetime - currentAge</p></blockquote><p> 其中，</p><ul><li><p>responseTime：表示浏览器接收到此响应的那个时间点。（感觉这项应该是在浏览器的某处找到）</p></li><li><p>freshnessLifetime： 表示缓存的寿命。</p></li><li><p>currentAge： 感觉对应响应头中的age，表示消息对象在缓存代理服务器中存贮的时长</p><p>这样 <em>寿命</em> - <em>已经存在的时间</em> + <em>最近一次到达浏览器的时间</em> 就得到未来缓存过期的时间。</p></li></ul></li><li><p>资源加速</p><p> 下面这个要问一下。</p><blockquote><p>更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。</p></blockquote><blockquote><p>web开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术[1] 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。</p></blockquote><blockquote><p>这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。</p></blockquote><blockquote><p>加在加速文件后面的版本号不一定是一个正式的版本号字符串，如1.1.3这样或者其他固定自增的版本数。它可以是任何防止缓存碰撞的标记例如hash或者时间戳。</p></blockquote></li></ol><ol start="8"><li><p>缓存验证</p><p> 缓存验证出发的方法：</p><ol><li><p>用户点击刷新按钮时会开始缓存验证;</p></li><li><p>如果缓存的响应头信息里含有”Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。（已在上面做了解释）</p></li><li><p>在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。</p><p>只要出发了缓存验证在请求中就会带有条件<code>If-None-Match</code>或<code>If-Modified-Since</code>（？），不带条件的请求就会重新获取资源。</p></li></ol></li><li><p>缓存过期后的处理方法</p><p> 当缓存的文档过期后，需要进行<strong>缓存验证</strong>或者<strong>重新获取资源</strong>。</p><ul><li><p>缓存校验</p><p>  触发条件： <strong>只有在服务器返回强校验器或者弱校验器时才会进行验证。</strong></p><ol><li><p>如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。</p></li><li><p>Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。</p><p>结果：<strong>当向服务端发起缓存校验的请求时，服务端会返回 200 ok表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。</strong></p></li></ol></li></ul></li><li><p>带Vary头的响应</p><ol><li><p>Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。</p><p> <img src="/images/http/HTTPVary.png" alt="Vary头的使用"></p></li><li><p>使用vary头有利于内容服务的动态多样性。</p><p> 例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。(但这样的话岂不是要写移动和桌面端两份文件，对于前端就是包袱啊！！！不如媒体查询来的方便！！！)</p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之八——《索引集合类》</title>
      <link href="/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AB-%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections" target="_blank" rel="noopener">链接地址</a></p><ol><li><p>用来处理DOM集合的一个更高效的土法子</p><p>从来没有这样用过诶。<code>div = divs[i]</code>这个赋值表达式，当i = length时，返回值为false就会停止这个循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var divs = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">for (var i = 0, div; div = divs[i]; i++) &#123;</span><br><span class="line">  /* Process div in some way */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>以下是几个自己没有怎么常用的数组方法</p><ol><li><p><code>join()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myArray = new Array(&quot;Wind&quot;, &quot;Rain&quot;, &quot;Fire&quot;);</span><br><span class="line">var list = myArray.join(&quot; - &quot;); // list is &quot;Wind - Rain - Fire&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.reverse()</code></p></li></ol></li><li><p><code>map(callback[, thisObject])</code>之类的函数有第二个参数，thisObject 变成回调函数内部的 this 关键字的值。如果没有提供，例如函数在一个显示的对象上下文外被调用时，this 将引用全局对象(window)。 </p></li><li><p>字符串使用数组函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(&apos;a string&apos;, function(chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之九 ——《带键的集合》</title>
      <link href="/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-%E5%B8%A6%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88/"/>
      <url>/2018/07/16/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B9%9D-%E5%B8%A6%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Map"><a href="#1-Map" class="headerlink" title="1.Map"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">1.Map</a></h3><ol><li><p>创建Map</p><ol><li><p>使用<code>set</code>方法添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br></pre></td></tr></table></figure><p><em>set方法返回的是当前的Map对象，因此可以采用链式写法。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map()</span><br><span class="line">  .set(1, &apos;a&apos;)</span><br><span class="line">  .set(2, &apos;b&apos;)</span><br><span class="line">  .set(3, &apos;c&apos;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><a id="more"></a><ol start="2"><li><p>调用构造函数的时候传入一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>判断Map结构中是否包含某个键值，使用<code>has</code>方法</p><p><code>map.has(&#39;name&#39;) // true</code></p></li><li><p>获取Map结构某个键对应的值，使用<code>get</code>方法</p><p><code>map.get(&#39;name&#39;) // &quot;张三&quot;</code></p></li><li><p>删除某个键值对，使用<code>delete</code>方法</p><p><code>m.delete(o) // true</code></p></li><li><p>清除所有成员，使用<code>clear</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">map.set(&apos;foo&apos;, true);</span><br><span class="line">map.set(&apos;bar&apos;, false);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.clear()</span><br><span class="line">map.size // 0</span><br></pre></td></tr></table></figure></li><li><p>对同一个键多次赋值，后面的值将覆盖前面的值。</p></li><li><p>读取一个未知的键返回undefined。</p></li><li><p>只有对同一个对象的引用，Map 结构才将其视为同一个键。<strong>陷阱！大陷阱！！！</strong>墙裂注意下面的代码。原因：<strong>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure></li><li><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p></li><li><p>三个遍历器生成函数</p><ol><li><p>遍历的顺序就是插入的顺序。</p></li><li><p>使用这三个函数返回的是这种形式的结果：<code>MapIterator {&quot;F&quot;, &quot;T&quot;}</code>。这就是传说中的遍历器？！<strong>感觉可以将这个遍历器视为一个数组？下面第11项感觉可以佐证这个猜想。</strong></p></li></ol><p>然后利用这个遍历器的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>for of</code>循环来利用这个遍历器。</p><ol start="3"><li>Map结构的默认遍历器接口就是entries方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;F&quot; &quot;no&quot;</span><br><span class="line">  // &quot;T&quot; &quot;yes&quot;</span><br><span class="line"></span><br><span class="line">  // 等同于使用map.entries()</span><br><span class="line">  for (let [key, value] of map) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Map结构转数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [1, &apos;one&apos;],</span><br><span class="line">  [2, &apos;two&apos;],</span><br><span class="line">  [3, &apos;three&apos;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line">// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line">// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]</span><br></pre></td></tr></table></figure></li><li><p>Map结构的遍历函数<code>forEach</code></p><ol><li>使用方法类似数组的<code>forEach</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>forEach方法还可以接受第二个参数，用来绑定this</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></li><li><p>Map转JSON</p><ol><li>当Map的键为字符串时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function strMapToJson(strMap) &#123;</span><br><span class="line">  return JSON.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line">// &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>当Map的键包含其他类型的值时</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function mapToArrayJson(map) &#123;</span><br><span class="line">  return JSON.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line">// &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;</span><br></pre></td></tr></table></figure></li></ol><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ol><li><p>WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。<strong>一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</strong></p></li><li><p>WeakMap只有四个方法可用：get()、set()、has()、delete()。没有size属性。</p></li></ol><h3 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a><a href="http://es6.ruanyifeng.com/#docs/set-map#Set" target="_blank" rel="noopener">2. Set</a></h3><p>Set类似于数组，但是成员的值都是唯一的，没有重复的值。</p><ol><li><p>创建Set对象</p><ol><li><p>使用<code>add</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>2. 传入数组或类数组参数  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//传入数组参数</span><br><span class="line">  const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">  [...set]</span><br><span class="line"></span><br><span class="line">//传入类数组参数</span><br><span class="line">  const set = new Set(document.querySelectorAll(&apos;div&apos;));</span><br><span class="line">  set.size // 56</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>数组去重的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure></li><li><p>Set对象判断元素是否相等的算法</p><p> 算法类似<code>===</code>，但是NaN在Set中被认为是等于自身的，这点和<code>===</code>不！一！样！</p></li><li><p>Set对象的属性</p><ul><li>size属性，查看元素个数</li></ul></li><li><p>Set对象的方法</p><ul><li><p>add(value)：添加某个值，返回 Set 结构本身。</p></li><li><p>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</p></li><li><p>has(value)：返回一个布尔值，表示该值是否为Set的成员。</p></li><li><p>clear()：清除所有成员，没有返回值。</p><p>Map对象添加元素使用的是<code>set</code>。</p></li></ul></li><li><p>Set对象转成普通数组对象</p><ol><li><p><code>[...setObject]</code></p></li><li><p><code>Array.from(setObject)</code></p></li></ol></li><li><p>遍历器</p><ul><li><p>keys()</p></li><li><p>values()</p></li><li><p>entries()</p></li></ul><p>生成的遍历器结果可以使用<code>for of</code>来循环遍历进行下一步操作。由于Set对象键名和键值相同，所以<code>keys()</code>和<code>values()</code>的结果相同。</p><p>Set结构的实例默认可遍历，默认遍历器生成函数就是<code>values（）</code>方法，所以可以省略写成：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure></li><li><p>forEach（）</p><p> 和Map结构相同，Set结构的forEach（）函数同样可以接受第二个参数，作为第一个函数参数中的this</p></li><li><p>使用Set实现交集、并集、差集</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// set &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></li><li><p>Set的一个用法</p><p><strong>Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</strong></p></li></ol><h3 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h3><p>WeakSet 的成员只能是对象，而不能是其他类型的值。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>在Map和Set中都出现过iterable结构这个东西，这个要看下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之七——《正则表达式》</title>
      <link href="/2018/07/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/07/15/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%83-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><ol><li><p><strong>?</strong></p><ol><li><p>单独使用：匹配前面一个表达式0次或者1次。等价于 {0,1}。</p></li><li><p>如果紧跟在任何量词 <code>*、 +、? 或 {}</code> 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。</p></li></ol></li><li><p><code>x(?=y)</code>: 正向肯定查找。</p><blockquote><p>/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p></blockquote></li></ol><a id="more"></a><ol start="3"><li><p><code>x(?!y)</code>: 正向否定查找。</p><blockquote><p>/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</p></blockquote></li><li><p><code>[^xyz]</code>: 方向字符集和。匹配<strong>任何没有包含</strong>在方括号中的字符。</p></li><li><p><code>.</code>: 匹配除换行符之外的任何单个字符。</p></li><li><p><code>\w</code>： 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</p></li></ol><h4 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h4><ol><li><p><code>RegExp.prototype.exec()</code>：这个函数类似<code>String.prototype.match()</code>,但是返回数组的同时还会同时更新正则表达式的属性。</p><ul><li><p>返回的数组和更新的正则表达式的附带属性见下图</p><p>  <img src="/images/js/5.png" alt="exec()返回值"></p></li><li><p>使用<code>exec（）</code>函数的一个方便用法的示例</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myRe = /ab*/g;</span><br><span class="line">var str = &apos;abbcdefabh&apos;;</span><br><span class="line">var myArray;</span><br><span class="line">while ((myArray = myRe.exec(str)) !== null) &#123;</span><br><span class="line">var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</span><br><span class="line">msg += &apos;Next match starts at &apos; + myRe.lastIndex;</span><br><span class="line">console.log(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <em>注意：</em></p><ol><li><p>不要把正则表达式字面量（或者RegExp构造器）放在 while 条件表达式里（否则每次都会重新设置，会造成while的死循环）;</p></li><li><p>要加g标志（否则不会查找下一个，会造成while的死循环）。</p></li></ol></li></ul></li><li><p><code>RegExp.prototype.test()</code>： 类似<code>String.prototype.search()</code>,只是返回值为布尔值。</p></li><li><p><code>String.prototype.split()</code>: 这个函数是String原型对象上的方法。</p><ul><li><p>不使用捕获组括号</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/\d/);</span><br><span class="line">console.log(splits);</span><br><span class="line">//[ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure></li><li><p>使用捕获组括号</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/(\d)/);</span><br><span class="line">console.log(splits);</span><br><span class="line">//[ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之六——《字符串》</title>
      <link href="/2018/07/09/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/07/09/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%85%AD-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide" target="_blank" rel="noopener">译文链接</a></p><a id="more"></a><ol><li><p>String对象方法</p><ol><li><p><code>String.prototype.charAt()</code>：从一个字符串中返回指定的字符。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var anyString = &quot;Brave new world&quot;;</span><br><span class="line"></span><br><span class="line">console.log(&quot;The character at index 0   is &apos;&quot; + anyString.charAt(0)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 1   is &apos;&quot; + anyString.charAt(1)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 2   is &apos;&quot; + anyString.charAt(2)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 3   is &apos;&quot; + anyString.charAt(3)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 4   is &apos;&quot; + anyString.charAt(4)   + &quot;&apos;&quot;);</span><br><span class="line">console.log(&quot;The character at index 999 is &apos;&quot; + anyString.charAt(999) + &quot;&apos;&quot;);</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line">The character at index 0 is &apos;B&apos;</span><br><span class="line">The character at index 1 is &apos;r&apos;</span><br><span class="line">The character at index 2 is &apos;a&apos;</span><br><span class="line">The character at index 3 is &apos;v&apos;</span><br><span class="line">The character at index 4 is &apos;e&apos;</span><br><span class="line">The character at index 999 is &apos;&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.charCodeAt(index)</code>: 能正确返回一个两个字节组成的字符的码点值。</p></li><li><p><code>String.prototype.pointCodeAt(index)</code>： 能正确返回一个四个字节组成的字符的码点值。</p></li><li><p><code>String.prototype.indexOf()</code>: indexOf() 方法返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。如果未找到该值，则返回-1。<strong>这个方法区分大小写</strong>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;Blue Whale&apos;.indexOf(&apos;lu&apos;)</span><br><span class="line">//1</span><br><span class="line"></span><br><span class="line">//判断某个字符串是否存在于另一个字符串中</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;) !== -1; // true</span><br><span class="line">&quot;Blue Whale&quot;.indexOf(&quot;Bloe&quot;) !== -1; // false</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.lastIndexOf()</code>: lastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。</p><p> 其中， fromIndex从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。</p></li><li><p><code>String.prototype.startsWith()</code>: 用来判断当前字符串是否以另外一个给定的子字符串开头，返回true或false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;To be, or not to be, that is a question.&apos;;</span><br><span class="line"></span><br><span class="line">alert(str.startsWith(&apos;To be&apos;))//true</span><br><span class="line">alert(str.startsWith(&apos;not to be&apos;))//false</span><br><span class="line">alert(str.startsWith(&apos;not to be&apos;, 10))//true</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.endWith()</code>: endsWith()方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;To be, or not to be, that is the question.&quot;;</span><br><span class="line"></span><br><span class="line">alert( str.endsWith(&quot;question.&quot;) );  // true</span><br><span class="line">alert( str.endsWith(&quot;to be&quot;) );      // false</span><br><span class="line">alert( str.endsWith(&quot;to be&quot;, 19) );  // true</span><br><span class="line"></span><br><span class="line">注意最后一个alert，结束位置是19而不是18,19表示的是be后面的那个逗号。</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.includes()</code>: 判断一个字符串中是否包含另一个字符串，返回true或false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;To be, or not to be, that is the question.&apos;;</span><br><span class="line"></span><br><span class="line">console.log(str.includes(&apos;To be&apos;));       // true</span><br><span class="line">console.log(str.includes(&apos;question&apos;));    // true</span><br><span class="line">console.log(str.includes(&apos;nonexistent&apos;)); // false</span><br><span class="line">console.log(str.includes(&apos;To be&apos;, 1));    // false</span><br><span class="line">console.log(str.includes(&apos;TO BE&apos;));       // false</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.concat()</code>:字符串拼接函数，由于性能问题，mdn建议使用<code>+</code>代替这个函数拼接字符串。自己写代码好像还真没用过这个函数。</p></li><li><p><code>String.fromCharCode()</code>：这个函数是String类的静态方法，必须这样使用。返回<strong>字符串</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(65,66,67)//&apos;ABC&apos;</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint()</code>: 这个函数同样是String类的静态方法。参数是高位码点。</p></li><li><p><code>String.prototype.split(seperator[,limit])</code>: 使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。separator 可以是一个字符串或正则表达式。</p><ul><li><p>例1：使用空格作为Seperator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Webkit Moz O ms Khtml&quot;.split( &quot; &quot; )   // [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;, &quot;ms&quot;, &quot;Khtml&quot;]</span><br></pre></td></tr></table></figure></li><li><p>例2：使用正则表达式作为Seperator,正则表达式不需要加<code>g</code>标识符。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello 1 word. Sentence number 2.&quot;;</span><br><span class="line">var splits = myString.split(/(\d)/);</span><br><span class="line"></span><br><span class="line">console.log(splits);</span><br><span class="line"></span><br><span class="line">//[ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ]</span><br></pre></td></tr></table></figure><ul><li>例3：设置第二个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myString = &quot;Hello World. How are you doing?&quot;;</span><br><span class="line">var splits = myString.split(&quot; &quot;, 3);</span><br><span class="line"></span><br><span class="line">console.log(splits);</span><br><span class="line"></span><br><span class="line">//[&quot;Hello&quot;, &quot;World.&quot;, &quot;How&quot;]</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.slice(begin[, end])</code>:返回一个子字符串，提取范围是[begin, end),其中end为可选参数，如果begin或end为负值，则实际为length+begin/length+end。</p></li><li><p><code>String.prototype.substring(begin[, end]</code>: 返回一个子字符串。类似上面的slice方法。当begin&gt;end时，会交换begin和end的位置执行。</p></li><li><p><code>String.prototype.substr(start[, length])</code>：返回一个字符串中从指定位置开始到指定字符数的字符。</p></li><li><p><code>String.prototype.match()</code>： <code>match（）</code>函数是<strong>字符对象</strong>的方法！！！</p><ul><li><p>接受一个<strong>正则表达式</strong></p><ol><li><p>正则表达式没有加<code>g</code>时，返回的数组会带有一个<code>index</code>属性，表示匹配结果的索引；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg = /matc(h)/;</span><br><span class="line"></span><br><span class="line">var str = &apos;this is a match function test.&apos;;</span><br><span class="line"></span><br><span class="line">var re = str.match(reg);</span><br><span class="line"></span><br><span class="line">re;</span><br><span class="line"></span><br><span class="line">// [&quot;match&quot;, &quot;h&quot;, index: 10, input: &quot;this is a match function test.&quot;]</span><br></pre></td></tr></table></figure></li><li><p>如果加了<code>g</code>，则只会返回匹配项组成的数组（不包含括号）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reg = /matc(h)/g;</span><br><span class="line"></span><br><span class="line">var str = &apos;this is a match function test.&apos;;</span><br><span class="line"></span><br><span class="line">var re = str.match(reg);</span><br><span class="line"></span><br><span class="line">re;</span><br><span class="line"></span><br><span class="line">// [&quot;match&quot;]</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><code>String.prototype.replace()</code>:replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。(自己写代码有用到这个函数多次，还算熟)。</p><blockquote><p>str.replace(regexp|substr, newSubStr|function)</p></blockquote><ol><li>第二个参数是<strong>字符串</strong>时, 可以使用下图中所示变量名。对于最后一个变量名<code>$n</code>，要特别说明下，第一个括号用1表示而不是0。</li></ol><p><img src="/images/js/3.png" alt="特殊变量名"></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//交换一个字符串中两个单词的位置</span><br><span class="line"></span><br><span class="line">var re = /(\w+)\s(\w+)/;</span><br><span class="line">var str = &quot;John Smith&quot;;</span><br><span class="line">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class="line">// Smith, John</span><br><span class="line">console.log(newstr);</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>第二个参数是<strong>函数</strong>时，每次匹配成功都会调用这个函数，将返回结果作为替代字符串。</li></ol><p><img src="/images/js/4.png" alt="函数参数"></p></li><li><p><code>String.prototype.search()</code>: 如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。</p><p>使用<strong>-1</strong>来判断是否有匹配成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function testinput(re, str)&#123;</span><br><span class="line">var midstring;</span><br><span class="line">if (str.search(re) != -1)&#123;</span><br><span class="line">    midstring = &quot; contains &quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    midstring = &quot; does not contain &quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log (str + midstring + re);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.prototype.repeat()</code>：记得以前看python的时候好像字符串和乘号能直接翻倍字符串，js中好像没有这种功能。</p></li><li><p><code>String.prototype.trim()</code>: <strong>trim方法</strong>只会删除开头和结尾的空白，对于字符中的空白无能为力。</p></li></ol></li><li><p>模板字符串</p><ol><li>换行：这个超方便。超方便！</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之五——《数字和日期》</title>
      <link href="/2018/07/07/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/"/>
      <url>/2018/07/07/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%94-%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Numbers_and_dates" target="_blank" rel="noopener">译文地址</a></p><ol><li><p>js中数字的范围和类型</p><p>范围： -(2^53 - 1) ~ (2^53 - 1)</p><p>类型： 普通数字， +Infinity， -Infinity， NaN</p></li></ol><a id="more"></a><ol start="2"><li><p>数字对象属性和方法的引用</p><p>属性包括最大值、最小值、非数、正无穷、负无穷、比较值、最大安全数、最小安全数。</p><p><img src="/images/js/1.png" alt="数字对象属性"></p><p>方法调用的时候要使用<code>Number.</code>的形式，忘记这个在哪儿看到的了，总之就是有好处就对了。</p><p><img src="/images/js/2.png" alt="数字对象的方法"></p></li><li><p>实现精确四舍五入保留小数位数的方法</p><ol><li><p><code>Number.prototype.toFixed()</code>：这个写在数字对象原型上的方法就可以做到，只不过会返回字符串形式的结果。（负数因为操作符的优先级问题，在不加括号的情况下不会返回字符串形式）</p></li><li><p>使用这种方法保留小数后几（3）位：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const rounded = Math.round(output * 1000) / 1000;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Math对象的方法</p><p> Math对象不可以自定义。</p><ol><li><p><code>floor（）</code>往下舍;</p></li><li><p><code>ceil（）</code>往上进;</p></li><li><p><code>round（）</code>四舍五入，只可保证整数部分是精确的;</p></li><li><p><code>trunc（）</code>截掉数字的小数部分。</p></li><li><p><code>random（）</code>返回一个浮点,  伪随机数在范围[0，1)， <strong>不能使用它们来处理有关安全的事情。使用Web Crypto API 来代替, 和更精确的window.crypto.getRandomValues() 方法。</strong></p><ol><li><p>得到一个大于等于0，小于1之间的随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getRandom() &#123;</span><br><span class="line">  return Math.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getRandomArbitrary(min, max) &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomInt(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到一个两数之间的随机整数，包括两个数在内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getRandomIntInclusive(min, max) &#123;</span><br><span class="line">  min = Math.ceil(min);</span><br><span class="line">  max = Math.floor(max);</span><br><span class="line">  return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>日期对象</p><ol><li><p>如果不使用<em>new</em>调用<code>Date()</code>,则返回的是当前日期时间的字符串。</p></li><li><p>使用<em>new</em>调用<code>new Date()</code>。使用这种方式创建的时间对象都可以使用Date对象的相关方法进行操作。</p><ol><li><p>如果不传入参数，则返回当前日期时间的时间对象;</p></li><li><p>传入<code>1995, 11, 25, 9, 30, 0</code>表示传入的是1995年11月25日9点30分0秒。</p></li></ol></li><li><p>Date对象的常用方法</p><ol><li><p><code>Date.prototype.getDate()</code>: 根据本地时间返回指定日期对象的月份中的第几天（1-31）。</p></li><li><p><code>Date.prototype.getDay()</code>: 根据本地时间返回指定日期对象的星期中的第几天（0-6）。</p></li><li><p><code>Date.prototype.getFullYear()</code>: 根据本地时间返回指定日期对象的年份。</p></li><li><p><code>Date.prototype.getHours()</code>: 根据本地时间返回指定日期对象的小时（0-23）。</p></li><li><p><code>Date.prototype.getSeconds()</code>: 根据本地时间返回指定日期对象的秒数（0-59）。</p></li><li><p><code>Date.prototype.getMinutes()</code>: 根据本地时间返回指定日期对象的分钟（0-59）。</p></li><li><p><code>Date.prototype.getMonth()</code>: 根据本地时间返回指定日期对象的月份（0-11）。</p></li><li><p><code>Date.prototype.toDateString()</code>: 返回一个人类可读的日期字符串，比如 <em>“Mon Jul 09 2018”</em> 。</p></li><li><p><code>Date.prototype.toLocalDateString()</code>： 返回一个 <em>“2018/7/9”</em> 这样形式的日期字符串。术语叫<strong>该字符串格式与系统设置的地区关联</strong>。</p></li><li><p><code>Date.prototype.toLocaleString()</code>:<br>返回一个 <em>“2018/7/9 上午10:48:34”</em> 这样形式的日期字符串。术语叫<strong>该字符串与系统设置的地区关联</strong>。</p></li><li><p><code>Date.prototype.toLocaleTimeString()</code>:返回一个 <em>“上午10:48:34”</em> 这样形式的时间字符串。</p></li><li><p><code>Date.prototype.toString()</code>: 返回 <em>“Mon Jul 09 2018 10:48:34 GMT+0800 (CST)”</em> 这种形式的字符串。感觉上面那种 <em>toLocale</em> 形式的更有用些。</p></li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome开发者工具使用技巧</title>
      <link href="/2018/07/06/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/07/06/chrome%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ol><li><p>使用开发者工具查看dom节点的监听函数</p><ol><li>使用console查看</li></ol></li></ol><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. let btn = $(&apos;.btn&apos;)[0];//获取类名为btn的dom节点</span><br><span class="line"></span><br><span class="line">2. let listeners = getEventListeners(btn);//获取btn的事件监听函数</span><br><span class="line"></span><br><span class="line">3. debug（listeners.click[0].listen);//设置打断</span><br><span class="line"></span><br><span class="line">4. btn.click();//触发点击事件</span><br></pre></td></tr></table></figure>![查看节点监听函数](/images/chrome/get-debug-event-listeners.gif)2. 使用eventListeners</code></pre><ol start="2"><li><p>快速改变css的数字值</p><ol><li><p><code>up/ctrl+鼠标滚轮</code>:整数1;</p></li><li><p><code>alt+up/alt+鼠标滚轮</code>:小数1;</p></li><li><p><code>shift+up/shift+鼠标滚轮</code>：整数10;</p><p><img src="/images/chrome/quick-change-css-values.gif" alt="css样式数字值快速变化"></p></li></ol></li><li><p>设置条件断点</p><p> <img src="/images/chrome/conditional-breakpoint.gif" alt="设置条件断点"></p></li><li><p>在source panel中快速选择多个同样的词</p><p> <code>ctrl+d</code></p><p> <img src="/images/chrome/select-next-occurrence.gif" alt="快速选择多个同样的词"></p></li><li><p>添加移动设备</p><p> <img src="/images/chrome/add-new-device.gif" alt="添加移动设备"></p></li><li><p>使用<code>console.trace()</code></p><p> 查看代码的执行流程。可以点击跳转到相应的代码处。</p><p> <img src="/images/chrome/console-trace.gif" alt="console.trace()"></p></li><li><p>过滤资源</p><ol><li><p>large-than</p></li><li><p>status-code</p></li><li><p>mime-type</p></li><li><p>method</p></li><li><p>-larger-than</p><p><img src="/images/chrome/network-advanced-filter.gif" alt="过滤资源"></p></li></ol></li><li><p>搜索特定项</p><ol><li><p><code>item</code></p></li><li><p><code>item file:main.js</code></p><p><img src="/images/chrome/project-search-with-file-scope.gif" alt="搜索特定项"></p></li></ol></li><li><p>粘贴复制dom节点</p><p> <img src="/images/chrome/duplicate-dom.gif" alt="粘贴复制dom节点"></p></li><li><p>使用console修改节点</p><p><img src="/images/chrome/console-edit-html.gif" alt="使用console修改节点"></p></li><li><p>禁用css和js查看页面</p><p><img src="/images/chrome/block-requests.gif" alt="禁用css和js查看页面"></p></li><li><p>调整动画效果</p><p><a href="http://www.justinaguilar.com/animations/#" target="_blank" rel="noopener">示例网站</a></p><p><img src="/images/chrome/animation-inspector.gif" alt="调整动画效果"></p></li><li><p>查看jQuery监听函数定义</p><p><img src="/images/chrome/jquery-event-listeners.gif" alt="查看jQuery监听函数定义"></p></li><li><p>查看请求优先级</p><p><code>shift+hover</code></p><ol><li><p>红色表示这些request是由当前request发出的请求;</p></li><li><p>绿色表示当前request是由绿色request发出的请求;</p></li><li><p>右键调出 <em>priority</em> 一栏，显示请求的优先级。</p></li></ol><p><img src="/images/chrome/network-dependency.gif" alt="查看请求优先级"></p></li><li><p>使用style中的工具添加背景颜色和字体颜色——感觉没什么卵用</p><p><img src="/images/chrome/style-rule-toolbar.gif" alt="使用style中的工具添加背景颜色和字体颜色"></p></li><li><p>在console中隐藏不用的 <em>error</em> , <em>warning</em></p><p><img src="/images/chrome/hide-network-console.gif" alt="在console中隐藏不用的error,warning"></p></li><li><p>在style中长hover定位元素</p><p><img src="/images/chrome/hover-over-selector.gif" alt="在style中长hover定位元素"></p></li><li><p>使用<code>console.table</code>显示对象或数组</p><p><img src="/images/chrome/console-table.gif" alt="console.table"></p></li><li><p>使用<code>console.time</code>显示经历时长</p><p><img src="/images/chrome/console-time.gif" alt="console.time"></p></li><li><p>启闭元素的类</p><p><img src="/images/chrome/toggle-element-classes.gif" alt="启闭元素的类"></p></li><li><p>使用google搜索矿搜索github</p><p>git+tab</p></li><li><p>查看资源是如何加载的</p><p><img src="/images/chrome/resource-initiator.gif" alt="查看资源加载"></p></li><li><p><code>ctrl+shift+p</code>调出命令菜单</p></li><li><p>将动画输出到console</p><p>支持的操作：</p><ol><li><p>temp1.play() - Starts playing an animation.</p></li><li><p>temp1.pause() - Pause the playing animation.</p></li><li><p>temp1.reverse() - Play an animation backwards.</p></li><li><p>temp1.playbackRate - Get or set the playback rate of the animation.</p></li></ol><p><img src="/images/chrome/web-animation-api.gif" alt="动画输出到console"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查漏补缺之四——《表达式和运算符》</title>
      <link href="/2018/07/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/07/06/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E5%9B%9B-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<ol><li><p>假值</p><p> <code>false, null, 0, NaN, &quot;&quot;, undefined</code></p></li><li><p>逗号操作符</p><p> 对两个操作数进行求值并<strong>返回最终操作数的值</strong>。它常常用在 for 循环中，在每次循环时对多个变量进行更新。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = [0,1,2,3,4,5,6,7,8,9]</span><br><span class="line">var a = [x, x, x, x, x];</span><br><span class="line"></span><br><span class="line">for (var i = 0, j = 9; i &lt;= j; i++, j--)</span><br><span class="line">  console.log(&apos;a[&apos; + i + &apos;][&apos; + j + &apos;]= &apos; + a[i][j]);</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li><p>delete操作符</p><p> delete不能删除使用var，let，const声明的变量。</p><p> delete删除数组元素值，这个元素还存在，但是值变成了undefined,<br> 执行<code>index in array</code>返回<code>false</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let obt1 = &#123;</span><br><span class="line">  test: &apos;test1&apos;,</span><br><span class="line">  test2: &apos;test2&apos;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let arr1 = [</span><br><span class="line">    1, 2, 3</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let obj1 = &#123;</span><br><span class="line">  test: &apos;test&apos;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(delete obj1);//false</span><br><span class="line">console.log(obj1);//&#123;test: &quot;test&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(delete obt1.test);//true</span><br><span class="line">console.log(obt1);//&#123;test2: &quot;test2&quot;&#125;</span><br><span class="line"></span><br><span class="line">console.log(delete arr1[1]);//true</span><br><span class="line">console.log(arr1);//[1, , 3]</span><br><span class="line">conosle.log(arr1[1]);//undefined</span><br></pre></td></tr></table></figure></li><li><p>表达式和语句</p><p> 表达式： 用来计算出一个值</p><p> 语句： 用来使某个事情发生</p></li><li><p>typeof操作符</p><p> 返回值为字符串形式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof myFun;     // returns &quot;function&quot;</span><br><span class="line">typeof shape;     // returns &quot;string&quot;</span><br><span class="line">typeof size;      // returns &quot;number&quot;</span><br><span class="line">typeof today;     // returns &quot;object&quot;</span><br><span class="line">typeof dontExist; // returns &quot;undefined&quot;</span><br><span class="line">typeof true; // returns &quot;boolean&quot;</span><br><span class="line">typeof null; // returns &quot;object&quot; 这个要注意下</span><br></pre></td></tr></table></figure></li><li><p>in操作符</p><p> <strong>检查它（或其原型链）是否包含具有指定名称的属性的对象。</strong></p><p> <code>prop in object</code></p><p> <em>prop</em>: 一个字符串类型或者 symbol 类型的属性名或者数组索引</p><p> <em>object</em>: 对象或者数组</p></li><li><p>instance操作符</p><p> <strong>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</strong></p><p> <code>object instanceof constructor</code></p></li><li><p>基本表达式</p><ol><li><p>this</p><p> 下面这两种用法之前没有留意过诶。</p><ol><li><p>作为一个DOM事件处理函数</p><p> 当函数被用作事件处理函数时，它的this指向触发事件的元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">function bluify(e)&#123;</span><br><span class="line">console.log(this === e.currentTarget); // 总是 true</span><br><span class="line"></span><br><span class="line">// 当 currentTarget 和 target 是同一个对象时为 true</span><br><span class="line">console.log(this === e.target);        </span><br><span class="line">this.style.backgroundColor = &apos;#A5D9F3&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取文档中的所有元素的列表</span><br><span class="line">var elements = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line"></span><br><span class="line">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">elements[i].addEventListener(&apos;click&apos;, bluify, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为一个内联事件处理函数</p><p> 当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt;</span><br><span class="line">Show this</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//alert 会显示button</span><br></pre></td></tr></table></figure><p> 还有下面这种用法…感觉之前完全没有想过。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function validate(obj, lowval, hival)&#123;</span><br><span class="line">if ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="line">    console.log(&quot;Invalid Value!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Enter a number between 18 and 99:&lt;/p&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>扩展语句</p><p> <strong>注意！！！</strong>在数组或函数中使用展开语法时，该语法只可用于可迭代对象！！！！！</p><ol><li><p>函数调用</p><p> <code>myFunction(...iterableObj);</code></p><ol><li><p>普通函数调用时等价于apply的方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(x, y, z) &#123; &#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">myFunction.apply(null, args);</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>    2. 在new表达式中应用时，不能直接使用数组+apply的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]），这时，使用扩展语句就要方便的多        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dateFields = [1970，0，1]; // 1970年1月1日</span><br><span class="line">var d = new Date（... dateFields）;</span><br></pre></td></tr></table></figure>2. 字面量数组构造或字符串    `[...iterableObj, &apos;4&apos;, ...&apos;hello&apos;, 6];`    1. 利用扩展语法构造字面量数组    2. 数组拷贝        扩展语法与`Object.assign()`执行的都是浅拷贝（只遍历一层）。所以才会出现下述结果：        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [[1], [2], [3]];</span><br><span class="line">var b = [...a];</span><br><span class="line">b.shift().shift(); // 1</span><br><span class="line">// Now array a is affected as well: [[], [2], [3]]</span><br></pre></td></tr></table></figure>    3. 使用`扩展语句`和`Array.concat`有相同的效果        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用Array.concat</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">// 将 arr2 中所有元素附加到 arr1 后面并返回</span><br><span class="line">var arr3 = arr1.concat(arr2);</span><br><span class="line"></span><br><span class="line">//使用扩展语法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">var arr3 = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure>    4. 使用`扩展语句`和`Array.unshift`有相同的效果        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用unshift函数</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">// 将 arr2 中的元素插入到 arr1 的开头</span><br><span class="line">Array.prototype.unshift.apply(arr1, arr2) // arr1 现在是 [3, 4, 5, 0, 1, 2]</span><br><span class="line"></span><br><span class="line">//使用扩展语法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">arr1 = [...arr2, ...arr1]; // arr1 现在为 [3, 4, 5, 0, 1, 2]</span><br></pre></td></tr></table></figure>3. 构造字面量对象时,进行克隆或者属性拷贝    `let objClone = { ...obj };`    1. **使用`扩展语句`和`Object.assign`有相同的效果**；    2. `Object.assign`仅会针对对象自身的可枚举的属性进行操作；    3. `Object.assign`会触发`setter`，而展开语句不会。        关于这条，触发了`setter`又如何，有什么特殊的影响？感觉没有诶。。。MDN的`Object.assign`页面上有下述描述：        &gt;该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。        sowhat？暂时搁置。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之二 ——《语法与类型》</title>
      <link href="/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types" target="_blank" rel="noopener">原文地址</a></p><ol><li><p>在 JavaScript 中大小写敏感，变量 früh 和 Früh 则是两个不同的变量。</p></li><li><p>当你对一个 null 变量求值时，空值 null 在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作 false。</p></li></ol><a id="more"></a><ol start="3"><li><p>局部变量：在函数内部声明的变量。</p></li><li><p>函数提升：只有函数声明会被提升到顶部，而不包括函数表达式。</p></li><li><p>对象属性和数组元素不受保护，可以使用<code>const</code>来声明对象名或数组名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MY_OBJECT = &#123;&quot;key&quot;: &quot;value&quot;&#125;;</span><br><span class="line">MY_OBJECT.key = &quot;otherValue&quot;;</span><br><span class="line"></span><br><span class="line">const MY_ARRAY = [&apos;HTML&apos;,&apos;CSS&apos;];</span><br><span class="line">MY_ARRAY.push(&apos;JAVASCRIPT&apos;);</span><br><span class="line">console.log(MY_ARRAY); //logs [&apos;HTML&apos;,&apos;CSS&apos;,&apos;JAVASCRIPT&apos;];</span><br></pre></td></tr></table></figure></li><li><p>Object.prototype.toString()</p><p> 每个对象都包含一个<code>toString()</code>属性，默认情况会返回 “[object type]”（注意！！！此处返回值确实会带着引号），其中type是对象的类型。</p><p> 可以在对象中重写<code>toString()</code>来覆盖默认返回值。</p></li><li><p>给一个对象定义属性和值的一个不常用的写法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>魔术字符串</p><p> 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。</p></li><li><p><code>for in</code> vs <code>Object.keys</code> vs <code>Object.getOwnPropertyNames</code></p><ul><li><p><code>for in</code> ：用来获取某个对象（<strong>该对象</strong>）及其<strong>原型链</strong>上的可枚举属性。如果仅想获取该对象自身的属性，要借助<code>hasOwnProperty</code>方法。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var key in child) &#123;</span><br><span class="line">    if (child.hasOwnProperty(key)) &#123;</span><br><span class="line">        console.log(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>- `Object.keys` ：用来获取某个对象自身的可枚举属性。其效果等于`for in` + `hasOwnProperty`。- `Object.getOwnPropertyNames` ： 用来获取某个对象自身可枚举以及不可枚举的属性（不可获取以symbol命名的属性名）。</code></pre><ol start="10"><li><p>不要混淆原始的布尔值true和false与 Boolean对象的真和假</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b = new Boolean(false);</span><br><span class="line">if (b) // this condition evaluates to true</span><br><span class="line">if (b == true) // this condition evaluates to false</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之三 —— 《循环和函数》</title>
      <link href="/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/"/>
      <url>/2018/07/04/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<ol><li><p>break</p><ol><li>当在循环中执行break时，会立即终止当前所在的循环。比如下面这几行代码：</li></ol></li></ol><a id="more"></a><pre><code>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    for ( j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">        if (i === 0) &#123;</span><br><span class="line">            console.log(&apos;最里面:&apos;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;里面：&apos;, i);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;外面：&apos;, i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;最外面&apos;);</span><br><span class="line"></span><br><span class="line">//输出顺序：</span><br><span class="line">    最里面: 0</span><br><span class="line">    外面： 0</span><br><span class="line">    里面： 1</span><br><span class="line">    外面： 1</span><br><span class="line">    里面： 2</span><br><span class="line">    外面： 2</span><br><span class="line">    最外面</span><br></pre></td></tr></table></figure>    说明break只跳出了内层循环（所在循环），并没有跳出外面包裹的循环。2. break label 语法    自己从来没有使用过这种语法，但通过下面这个列子感觉这个语法还是蛮方便的：    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">var z = 0</span><br><span class="line">labelCancelLoops: while (true) &#123;</span><br><span class="line">console.log(&quot;外部循环: &quot; + x);</span><br><span class="line">x += 1;</span><br><span class="line">z = 1;</span><br><span class="line">while (true) &#123;</span><br><span class="line">    console.log(&quot;内部循环: &quot; + z);</span><br><span class="line">    z += 1;</span><br><span class="line">    if (z === 10 &amp;&amp; x === 10) &#123;</span><br><span class="line">    break labelCancelLoops;</span><br><span class="line">    &#125; else if (z === 10) &#123;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果满足 z === 10 &amp;&amp; x === 10 的条件，整个循环就会结束，就是使用了break labelCancelLoops 这条语法。</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p><code>for in</code> vs <code>for of</code> vs <code>for</code></p><ol><li><p>for…in 语句循环一个指定的变量来循环一个对象<strong>所有可枚举</strong>的属性。</p></li><li><p>for…of语句在可迭代的对象上创建了一个循环(包括Array, Map, Set, 参数对象（ arguments） 等等)</p></li><li><p>数组适合用传统for循环来操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 7];</span><br><span class="line">arr.foo = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">console.log(i); // logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">console.log(i); // logs &quot;3&quot;, &quot;5&quot;, &quot;7&quot; // 注意这里没有 hello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">console.log(i); //logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;// 注意这里没有 foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传统for循环和for of循环的结果相似。</p></li></ol></li><li><p>函数表达式</p><p> 函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = function fac(n) &#123;return n&lt;2 ? 1 : n*fac(n-1)&#125;;</span><br><span class="line"></span><br><span class="line">console.log(factorial(3));</span><br></pre></td></tr></table></figure><p> 注意下面代码中<code>square</code>并非函数名，下面这个函数是匿名函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var square = function(number) &#123; return number * number; &#125;;</span><br><span class="line">var x = square(4); // x gets the value 16</span><br></pre></td></tr></table></figure></li><li><p>Arguments对象</p><p> arguments 是一个对应于传递给函数的参数的类数组对象。</p><p> arguments对象是所有<strong>非箭头</strong>函数中都可用的局部变量。可以使用arguments对象在函数中引用函数的参数。</p><p> arguments的元素可读可写。</p></li><li><p>apply()函数</p><p> <code>func.apply(thisArg, [argsArray])</code>，其中<code>[argsArray]</code>可以为数组也可以是类数组</p></li><li><p>类数组</p><p> 只要有一个 length 属性和[0…length) 范围的整数属性。比如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;length&apos;: 2, &apos;0&apos;: &apos;eat&apos;, &apos;1&apos;: &apos;bananas&apos;&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找一系列数字中的最大最小值</p><ol><li><p>使用apply和原生Math.max()、Math.min()方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [5, 6, 2, 3, 7];</span><br><span class="line">var max = Math.max.apply(null, numbers);</span><br><span class="line">var min = Math.min.apply(null, numbers);</span><br></pre></td></tr></table></figure></li><li><p>使用数组扩展符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var max = Math.max(...arr);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>类数组转为数组</p><ol><li><p>方法1： 对性能有影响<br> <code>Array.prototype.slice.call(arguments)</code>，这行代码的意思是将slice方法绑定在arguments对象上。</p><p> 简写形式:</p><p> <code>[].slice.call(arguments)</code>，依然是将slice方法绑定在arguments对象上。</p></li><li><p>方法2：</p><p> <code>const args = Array.from(arguments);</code></p></li><li><p>方法3：使用扩展运算符</p><p> <code>var args = [...arguments];</code></p></li></ol></li><li><p><code>arguments.length</code> vs <code>function.length</code></p><p> arguments.length：表示实际传入函数的参数的个数；</p><p> function.length: 指该函数有多少个必须要传入的参数，即形参的个数。形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。</p></li><li><p>剩余参数 vs 默认参数 vs 解构赋值</p><ol><li><p>剩余参数</p><p> 如果函数的最后一个命名参数以…为前缀，则它将组成一个数组。<strong>剩余参数是货真价实的数组而arguments对象只是类数组。</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(...args) &#123;</span><br><span class="line">return args;</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3);//[1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><p> <strong>默认参数是在函数被调用时解析的</strong>，所以如果默认参数是可变动的，则每次的结果可能是不一样的。</p></li><li><p>解构赋值</p><p> <strong>数组的解构赋值</strong>:目测是按数组元素的顺序。（此处仅记录了数组的解构赋值）。</p><ol><li><p>利用数组的解构赋值可以轻松交换值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1, b = 3;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">console.log(a);//3</span><br><span class="line">console.log(b);//1</span><br></pre></td></tr></table></figure></li><li><p>解析一个从函数返回的数组</p><p> 这个自己写代码已经遇到过多次返回数组的情况，但是都使用的传统获取数组对应位置的元素的方法，明显使用数组解构更简洁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">return [1, 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a, b; </span><br><span class="line">[a, b] = f(); </span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 2</span><br></pre></td></tr></table></figure></li><li><p>忽略一些值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [a, , b] = f();</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 3</span><br></pre></td></tr></table></figure></li><li><p>将剩余数组赋值给一个变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...b] = [1, 2, 3];</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // [2, 3]</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>5. 用正则表达式匹配提取值    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;;</span><br><span class="line"></span><br><span class="line">var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);</span><br><span class="line">console.log(parsedURL); // [&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/Web/JavaScript&quot;]</span><br><span class="line"></span><br><span class="line">var [, protocol, fullhost, fullpath] = parsedURL;</span><br><span class="line"></span><br><span class="line">console.log(protocol); // &quot;https&quot;</span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li><p>函数递归</p><p>递归函数就使用了堆栈：函数堆栈。</p><ol><li><p>应用1：获取树结构中所有的节点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function walkTree(node) &#123;</span><br><span class="line">if (node == null) // </span><br><span class="line">    return;</span><br><span class="line">// do something with node</span><br><span class="line">for (var i = 0; i &lt; node.childNodes.length; i++) &#123;</span><br><span class="line">    walkTree(node.childNodes[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>箭头函数</p><p>箭头函数会捕捉闭包上下文的this值，以词法方式绑定this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">this.age = 0;</span><br><span class="line"></span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    this.age++; // |this| properly refers to the person object</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript查缺补漏之一 ——《流程控制与错误处理》</title>
      <link href="/2018/07/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/03/javascript%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%B8%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling" target="_blank" rel="noopener">原文地址</a></p><ol><li><p>如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么。</p><p> 下面代码中有说明，catch中的return会挂起，直到finally中的代码完成，finally中的return会覆盖catch中的return。return之后的console都不会执行。</p></li></ol><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(0);</span><br><span class="line">    throw &quot;bogus&quot;;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return true; // this return statement is suspended</span><br><span class="line">                // until finally block has completed</span><br><span class="line">    console.log(2); // not reachable</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    return false; // overwrites the previous &quot;return&quot;</span><br><span class="line">    console.log(4); // not reachable</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;return false&quot; is executed now  </span><br><span class="line">  console.log(5); // not reachable</span><br><span class="line">&#125;</span><br><span class="line">f(); // console 0, 1, 3; returns false</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>catch中可以再次抛出异常，但如果finally中有返回值，则这个返回值会覆盖catch中抛出的异常。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw &apos;bogus&apos;;</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(&apos;caught inner &quot;bogus&quot;&apos;);</span><br><span class="line">    throw e; // this throw statement is suspended until </span><br><span class="line">            // finally block has completed</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    return false; // overwrites the previous &quot;throw&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // &quot;return false&quot; is executed now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套try…catch</p><p> 任何给定的异常只会被离它最近的封闭 catch 块捕获一次。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&quot;oops&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (ex) &#123;</span><br><span class="line">    console.error(&quot;inner&quot;, ex.message);</span><br><span class="line">    throw ex;</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    console.log(&quot;finally&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ex) &#123;</span><br><span class="line">  console.error(&quot;outer&quot;, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Output:</span><br><span class="line">// &quot;inner&quot; &quot;oops&quot;</span><br><span class="line">// &quot;finally&quot;</span><br><span class="line">// &quot;outer&quot; &quot;oops&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之二——《React模式》</title>
      <link href="/2018/07/03/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C/"/>
      <url>/2018/07/03/react%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8B%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="http://sangka-z.com/react-in-patterns-cn/" target="_blank" rel="noopener">译文链接</a></p><ol><li><p>通过给一个通用函数传入参数定制特定函数的用法</p><p> <code>_onFieldChange</code>函数是一个通用实例方法，通过给这个函数传入不同的参数来实现返回结果的不同。</p><p> 在构造函数中，进行绑定（没有想过这种用法）。</p></li></ol><a id="more"></a><pre><code>  1. `this._onNameChanged = this._onFieldChange.bind(this, &apos;name&apos;);`  2. `this._onPasswordChanged =this._onFieldChange.bind(this, &apos;password&apos;);`**注意点击的回调事件要写在事件处理函数参数的最后**，上述在绑定的过程中传入的参数相当于第一个参数。这是因为：1. 使用箭头函数,事件对象e要显式传递;2. 使用bind方法，事件对象e会隐式传递，e要放在参数的最后。这里使用的是bind方法，事件对象会隐士传递，所以可以直接在`input`的`onChange`属性中单纯传入回调函数并且回调事件要写在回调函数参数的最后。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Form extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this._onNameChanged = this._onFieldChange.bind(this, &apos;name&apos;);</span><br><span class="line">    this._onPasswordChanged =</span><br><span class="line">      this._onFieldChange.bind(this, &apos;password&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;input onChange=&#123; this._onNameChanged &#125; /&gt;</span><br><span class="line">        &lt;input onChange=&#123; this._onPasswordChanged &#125; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  _onFieldChange(field, event) &#123;</span><br><span class="line">    console.log(`$&#123; field &#125; changed to $&#123; event.target.value &#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>解绑强耦合组件的讨论——组合</p><p> 作者认为<strong>组合</strong>是React的最强大的优势之一。</p><p> 书中的组合部分涉及<code>组件作为属性传递</code>，<code>高阶组件</code>，自己现在在写代码的时候会有意的将每个组件都写成单一功能的组件，自己感觉主要的好处还是视觉上的，不会出现看起来庞大数量巨大到恐怖的组件，改bug比较好定位。现在写的多数都是一次性组件，也没有写过组件测试，所以代码重用的优点感受的不明显，降低测试难度完全没有体会。</p><ol><li><p><code>children</code>属性</p><p> 这个属性之前没有好好关注过，如今看来是个相当好用的属性。书里说这个属性一大用途是用来解绑父组件和子组件的强耦合。</p></li><li><p>将组件作为参数传入另一个组件</p><p> 其实上面的<code>children</code>属性也相当与将组件作为参数传入另一个组件。之所以现在不太用这种写法是因为自己还没有写过通用组件，比如项目里的各种modal。写的全都是一次性的组件，写成强耦合的组件或许更直观，代码量也能减少，但如果涉及到组件测试就完逼了，最近写的组件业务逻辑都比较复杂了，组件的测试也肯定会相当复杂。（之前自己从没写过测试组件，现在要练习下。）</p></li><li><p>高阶组件</p><p> <strong>高阶组件的调用要在render（）之前，生成一个唯一的组件，如果在render（）中调用，每次生成的都不一样，会产生性能问题</strong>，见<a href="https://github.com/krasimir/react-in-patterns/issues/12" target="_blank" rel="noopener">作者观点</a>。</p><p> 下面是一个典型的高阶组件，在组件强化函数中，<code>Component</code>组件的参数title和remoteTitle的数据来源一个是配置文件，一个是ajax请求，即能控制原始组建的输入，同时还能传入高阶组件的props，书里说这是高阶组件的最大优点（<strong>控制数据来源</strong>）。感觉甚至可以把ajax请求作为高阶组件的参数传入，这样即保证组件的功能单一可复用，又能让数据和对应的组件组合在一起，还能避免原先的在上层的父组件中写入和父组件完全不相关的数据请求函数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  var config = require(&apos;path/to/configuration&apos;);</span><br><span class="line"></span><br><span class="line">  var enhanceComponent = (Component) =&gt;</span><br><span class="line">  class Enhance extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line"></span><br><span class="line">      this.state = &#123; remoteTitle: null &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      fetchRemoteData(&apos;path/to/endpoint&apos;).then(data =&gt; &#123;</span><br><span class="line">        this.setState(&#123; remoteTitle: data.title &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.props&#125;</span><br><span class="line">          title=&#123; config.appTitle &#125;</span><br><span class="line">          remoteTitle=&#123; this.state.remoteTitle &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">var OriginalTitle  = (&#123; title, remoteTitle &#125;) =&gt;</span><br><span class="line">  &lt;h1&gt;&#123; title &#125;&#123; remoteTitle &#125;&lt;/h1&gt;;</span><br><span class="line">var EnhancedTitle = enhanceComponent(OriginalTitle);</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>4. 将函数作为children和render props    下面这个例子里，App组件中不仅有全部数据，而且还有如何显示数据的方法。TodoList组件单纯只是一个显示数据的容器。使用时，将数据和操作显示数据的方法传入TodoList组件。感觉这个模式和自己之前的想法不太一样。之前自己写代码只是考虑组件功能的单一性，单从这个角度我肯定会把显示数据的方法写在TodoList组件里面，这样做完全没有考虑TodoList组件的复用，显然也没有让TodoList组件成为纯粹的样式渲染组件，明显`将函数作为children`模式以及`render props`模式更胜一筹。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function TodoList(&#123; todos, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section className=&apos;main-section&apos;&gt;</span><br><span class="line">      &lt;ul className=&apos;todo-list&apos;&gt;&#123;</span><br><span class="line">        todos.map((todo, i) =&gt; (</span><br><span class="line">          &lt;li key=&#123; i &#125;&gt;&#123; children(todo) &#125;&lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const todos = [</span><br><span class="line">    &#123; label: &apos;Write tests&apos;, status: &apos;done&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Sent report&apos;, status: &apos;progress&apos; &#125;,</span><br><span class="line">    &#123; label: &apos;Answer emails&apos;, status: &apos;done&apos; &#125;</span><br><span class="line">  ];</span><br><span class="line">  const isCompleted = todo =&gt; todo.status === &apos;done&apos;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;TodoList todos=&#123; todos &#125;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        todo =&gt; isCompleted(todo) ?</span><br><span class="line">          &lt;b&gt;&#123; todo.label &#125;&lt;/b&gt; :</span><br><span class="line">          todo.label</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/TodoList&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    这里作者举了他们项目的一个例子：    &gt;最近，我们在工作中使用这种模式，我们必须将某些界面限制只对具有 read:products 权限的用户开放。我们使用的是 render prop 模式。      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Authorize</span><br><span class="line">permissionsInclude=&#123;[ &apos;read:products&apos; ]&#125;</span><br><span class="line">render=&#123; () =&gt; &lt;ProductsList /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure>    这样写组件语义真的好清晰啊,上面的这三行代码不言自明：`Authorize`组件**验证**是否是有（`permissionsInclude`）权限（`[ &apos;read:products&apos; ]`），如果有，则渲染（`render`）产品列表（`&lt;ProductsList /&gt;`）。**这个组件仅靠组件名称、属性名称就完整描述了这个组件的功能，数据和渲染规则来自父组件，具体渲染细节则被封装进单纯的显示组件`Authorize`中。**    哇擦！有些激动！这真的变成代码写的文章了，而不是冗繁的字码，tsubarashi，真的是代码的艺术啊！    **所以今后写组件，不要盲目的用单一性拆分代码，从语义的角度考虑明显更优雅。**</code></pre><ol start="3"><li><p>展示型组件vs容器型组件</p><p> 以现在写的项目为例，<em>配置选型的创建功能</em>使用了三个组件：<code>base</code>,<code>first_step</code>,<code>second_step</code>。其中后两个组件为函数组件，遵循了展示型组件的原则，最大限度的不去管理数据。<code>base</code>组件则为一个混合组件，有几乎全部的业务逻辑，还有一部分组合<code>first_step</code>和<code>second_step</code>两个组件的显示代码，这一部分可以拆出来作为一个独立的组件，这样就会变成一个纯粹的容器型组件。</p></li><li><p>在组件中更新组件外部数据</p><p> 下面的代码中，<code>Store.set.bind(Store)</code>中的<code>bind(Store)</code>是关键。将函数的执行环境和Store对象绑定。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Store = &#123;</span><br><span class="line">  _flag: false,</span><br><span class="line">  set: function(value) &#123;</span><br><span class="line">    this._flag = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return this._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return &lt;Switcher onChange=&#123; Store.set.bind(Store) &#125; /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>双向绑定</p><p> 之前写的代码里，有几处用到了下面这种写法：</p><p> 父组件向子组件传递了一个<strong>能setState的函数</strong>，当子组件满足某个要求时执行这个函数，修改了父组件中的数据，同时子组件的数据完全来源于父组件，当数据有变化时，子组件再次渲染。</p><p> 但上述写法感觉不是双向绑定，双向绑定是相同数据状态存在多处，此刻再进行类似上述操作，数据状态彼此影响，感觉这个是双向绑定。</p></li><li><p>单项数据流</p><p> 将数据状态存储在全局的一个<code>store</code>对象中，这里作为整个应用数据属性更新的唯一地方。感觉这个是理解Redux的关键啊。下面是书中的例子：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//数据状态存储和更新的唯一地点</span><br><span class="line"></span><br><span class="line">var Store = &#123;</span><br><span class="line">  _handlers: [],</span><br><span class="line">  _flag: &apos;&apos;,</span><br><span class="line">  subscribe: function(handler) &#123;</span><br><span class="line">    this._handlers.push(handler);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(value) &#123;</span><br><span class="line">    this._flag = value;</span><br><span class="line">    this._handlers.forEach(handler =&gt; handler(value))</span><br><span class="line">  &#125;,</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return this._flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//状态组件的数据来源依然是store</span><br><span class="line">//这个组件初始化的时候注册了一个本组件修改状态的函数</span><br><span class="line">//然后将最终修改函数Store.set传给子组件，当子组件满足条件时发动</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; value: Store.get() &#125;;</span><br><span class="line">    Store.subscribe(value =&gt; this.setState(&#123; value &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Switcher</span><br><span class="line">          value=&#123; this.state.value &#125;</span><br><span class="line">          onChange=&#123; Store.set.bind(Store) &#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Switcher(&#123; value, onChange &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123; e =&gt; onChange(!value) &#125;&gt;</span><br><span class="line">      &#123; value ? &apos;lights on&apos; : &apos;lights off&apos; &#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>感觉这本书里讲redux虽然没有很深入但是很好理解，译文点击<a href="http://sangka-z.com/react-in-patterns-cn/chapter-9/" target="_blank" rel="noopener">此处</a>。</p></li><li><p>React context</p><p> 之前没有用过这个功能，只在redux中有见过<code>Provider</code>，但这个组件来自<code>react-redux</code>。</p><p> 下面这段是文章中对context功能的使用说明：</p><blockquote><p>createContext 返回的对象具有 Provider 和 Consumer 属性。它们实际上是有效的 React 类。Provider 以 value 属性的形式接收 context 。Consumer 用来访问 context 并从中读取数据。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createContext &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const Context = createContext(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">export const Provider = Context.Provider;</span><br><span class="line">export const Consumer = Context.Consumer;</span><br></pre></td></tr></table></figure><p> 使用：</p><ol><li><p>传入context</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">const context = &#123; title: &apos;React In Patterns&apos; &#125;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Provider value=&#123; context &#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在子组件中使用<code>Comsumer</code></p><p> <strong>Consumer 类使用函数作为嵌套子元素 ( render prop 模式) 来传递 context 。</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Consumer &#125; from &apos;./context&apos;;</span><br><span class="line"></span><br><span class="line">function Title() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Consumer&gt;&#123;</span><br><span class="line">      (&#123; title &#125;) =&gt; &lt;h1&gt;Title: &#123; title &#125;&lt;/h1&gt;</span><br><span class="line">    &#125;&lt;/Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用模块系统</p><p> 技术：模块创建全局对象+高阶组件</p><p> 描述：之前的项目中，创建数据缓存和router都使用了类似的技术。</p><p> 方法：在创建三个函数和一个存储对象</p><ol><li><p>存储对象</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dependencies = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注册函数用来获取属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export function register(key, dependency) &#123;</span><br><span class="line">dependencies[key] = dependency;</span><br></pre></td></tr></table></figure></li><li><p>获取函数用来拿到需要的值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function fetch(key) &#123;</span><br><span class="line">if (dependencies[key]) return dependencies[key];</span><br><span class="line">throw new Error(`$&#123; key &#125; is not registered as dependency.`);</span><br></pre></td></tr></table></figure></li><li><p>高阶函数用来包装原始组件，获取属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export function wire(Component, deps, mapper) &#123;</span><br><span class="line">  return class Injector extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this._resolvedDependencies = mapper(...deps.map(fetch));</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;Component</span><br><span class="line">          &#123;...this.state&#125;//这里表示的是Injector这个组件维护的状态，但感觉不太有用的到的机会，这种通用函数因该很少有这样的状态吧</span><br><span class="line">          &#123;...this.props&#125;//父组件传入的属性</span><br><span class="line">          &#123;...this._resolvedDependencies&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React查缺补漏之一——《React官方文档》</title>
      <link href="/2018/06/25/2018-6-25-react%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E4%B8%80/"/>
      <url>/2018/06/25/2018-6-25-react%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E4%B9%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>使用React写项目有一个多月了，现返回头重新翻一下官网文档，查缺补漏。</p><a id="more"></a><ol><li><p>使用先前<code>this.state.attr</code>来确定新的属性要使用函数这种第二种状态更新方式。</p><p> <strong>好像自己写的代码有好几处都使用了最常用的方式更新状态，这是错误的！！！</strong></p><p> <img src="/images/react_patch/1.png" alt="第二种更新状态的方式"></p></li><li><p>这里要明确一下绑定类函数的地方</p><p> 事件的回调函数（没有在函数名后加括号的地方），这里想起来之前看到的一篇文章，貌似是阮老师写的，大概意思是函数是独立的，在不同的环境下运行this的指向不同，而事件的回调函数应该也是进入事件队列的，从事件队列被拿到主线程里执行，要保证执行结果就要绑定this的指向。</p></li><li><p>回调函数绑定方法<br> 自己最常用的是在构造函数中使用bind手动绑定，明天要看下箭头函数。使用这种方法，每次初始渲染的时候就会创建一个不同的构造函数。所以，貌似使用bind更保险一些。</p><p> <img src="/images/react_patch/2.png" alt="使用箭头函数绑定this"></p></li><li><p>向事件处理程序传递参数<br> 有两种方法，通常自己常用的是下面使用箭头函数的这种。利用bind可以传递参数的特性也蛮不错的诶，只是自己没有这个意识，以后可以用上。</p><p> <img src="/images/react_patch/3.png" alt="向事件处理程序传递参数的方法"></p><p> 区别：</p><ol><li>使用箭头函数，事件对象e要显式传递</li><li><p>使用bind方法，事件对象e会隐式传递，e要放在参数的最后，如下</p><p><img src="/images/react_patch/4.png" alt="bind方法隐式传递事件对象"></p></li></ol></li><li><p>不参与显示在render中的参数不需要放进<code>this.state</code>中，作为类的静态变量即可</p></li><li><p>哪些参数或状态应该包含在当前组件中，哪些应该作为参数传递进当前组件，现在写的代码有些混乱。感觉要遵循下面的原则：</p><ol><li><p>每个组件尽量完成单一任务，但没必要刻意分割，组件的命名应该是表明当前组件的作用。</p></li><li><p>从语义上判断某个参数是从上层组建传递还是作为当前组件的state的一部分，比如前面的Clock组件，自动更新的状态应该作为组件的一部分。</p></li><li><p>从组建结构判断某个参数是否应该从上层组建传递，比如上层组件有个开关控制按钮。</p></li></ol></li><li><p>渲染多个组件<br> 以前都是直接在主组件中直接写map函数，事实上把map函数生成的多个子元素赋给一个变量是合法有效的，像下面这样。</p><p> <img src="/images/react_patch/5.png" alt="map渲染多个元素"></p><p> 然后在将这个变量包在一个标签中。</p></li><li><p>使用map生成多个兄弟元素时，key的用法</p><p> <strong>数组元素中使用的key在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。</strong></p><p> <code>key会作为给React的提示，但不会传递给你的组件。如果您的组件中需要使用和key相同的值，请将其作为属性传递。</code>之前写代码就遇到过这个诶。通过事件点击回调函数<code>e.target.getAttribute(&#39;key&#39;)</code>获取不到key值，原来是这样。</p></li><li><p>不能修改传入组件的props的属性</p><p> 这些属性是只读的，在最近写的代码中总是出现修改属性而报错的情况，这个要记住！</p></li><li><p>受控组件</p><p>之前咩有想过可以在捕获值之后再进行处理诶。</p><p>使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母，我们可以将handleChange 写为如下：</p><p><img src="/images/react_patch/6.png" alt="受控组件"></p></li><li><p>多个输入的解决方法</p><ol><li><p>首先注意一下这个用法：<br> <code>event.target.type/event.target.name</code>不需要使用节点的函数来获取属性值，直接获取是合法有效的！自己写的代码里很多都用了多此一举的函数来获取。</p></li><li><p>状态名和输入框名称属性名一致，然后利用对象属性名的动态方式改变属性。如下用法：</p></li></ol><p><img src="/images/react_patch/7.png" alt="多个输入的解决方法"></p></li><li><p>插播一个不关react的tip</p><p>四舍五入的保留要求的小数位数：<code>const rounded = Math.round(output * 1000) / 1000;</code>使用这种写法会四舍五入后保留小数后三位。因为<code>Math.round()</code>只能保证整数部分精确，乘以1000后，小数点后移三位，经过Math.Round，小数后一位四舍五入进位成整数，再除1000后正好为四舍五入后的小数后三位。</p></li></ol><h4 id="以下三项感觉都使用在构建通用组件中的"><a href="#以下三项感觉都使用在构建通用组件中的" class="headerlink" title="以下三项感觉都使用在构建通用组件中的"></a>以下三项感觉都使用在构建通用组件中的</h4><ol start="13"><li><p>children属性的使用</p><p>自己写的代码里好像从没有主动使用过this.props.children这个属性，官网里展示的例子看起来很方便啊。</p><p>嵌套 JSX 来传递子组件</p><ol><li><p>感觉这个用法一个是在写通用组件的时候用的上，比如现在项目里的各种modal。其他场合为啥要传递子组件？</p><p> <img src="/images/react_patch/8.png" alt="children属性的使用1"><br> <img src="/images/react_patch/9.png" alt="children属性的使用2"></p><p> 如果是我自己写，现在只会想到把数据或者函数作为参数从父组件传递到子组件中，把h1和p两个标签这种结构上的东西移入子组件中。</p></li><li><p>另一个用法是这些组件写在父组件中作为children属性向子组件中传递，可以不用向下传递需要修改数据的函数。感觉可以作为传递函数的一个替代写法。但依然感觉是在写通用组件的时候用的多。</p><p> <img src="/images/react_patch/12.png" alt="children属性的使用3"></p></li><li><p>当传递给自定义组件的子代的是一个函数</p><p> 哇擦，这个牛逼啊，要注意的是组件在React渲染前要将其转换成React能理解的，所以在Repeat中要返回一个div。<strong>这个用法可以用于扩展JSX</strong>，真妥么是神了。</p><p> <img src="/images/react_patch/13.png" alt="children属性的使用4"></p></li></ol></li><li><p>传递组件</p><p><strong>组件可以接受任意元素，包括基本数据类型、React 元素或函数。</strong>之前完全没有想过要这样用。<br><img src="/images/react_patch/10.png" alt="传递组件"></p></li><li><p>通过配置属性用较特殊的组件来渲染较通用的组件</p><p>现在写的项目里使用modal通用组件的时候通常会带一个<code>config.js</code>的配置文件，就是用来作为通用组件<code>modal</code>的属性进行传递的。</p><p><img src="/images/react_patch/11.png" alt="配置属性渲染通用组件"></p></li><li><p>如果要在组件之间复用 UI 无关的功能，我们建议将其提取到单独的 JavaScript 模块中。这样可以在不对组件进行扩展的前提下导入并使用该函数、对象或类。<em>现在写组件就在这么用。</em></p></li><li><p>JSX中标签的编译</p><p><code>&lt;div className=&quot;sidebar&quot;&gt;</code>会被编译为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">&apos;div&apos;,</span><br><span class="line">&#123;className: &apos;sidebar&#125;,</span><br><span class="line">null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之前一直认为JSX中的div标签和dom中的div标签没有区别。</p></li><li><p>JSX中一对闭合标签中的内容会被转译为<strong>HTML非转义字符串</strong></p></li><li><p>布尔值，Null， Undefined在渲染中会被忽略。</p><ol><li><p>这个有在现在的项目中遇到。</p></li><li><p><strong>这个可以用在条件渲染中。</strong> 如果showHeader为true，那么会渲染出<code>&lt;Header /&gt;</code>组件，为假则不会渲染出来，<code>&lt;Content /&gt;</code>组件则一直会渲染出来。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&#123;showHeader &amp;&amp; &lt;Header /&gt;&#125;</span><br><span class="line">&lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果你想让类似 false、true、null 或 undefined 出现在输出中，你必须先把它转成字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用refs</p><ol><li><p>当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为它的 current 属性以创建 ref 。</p><p> React 会在组件加载时将 DOM 元素传入 current 属性，在卸载时则会改回 null。ref 的更新会发生在componentDidMount 或 componentDidUpdate 生命周期钩子之前。</p></li><li><p>当 ref 属性被用于一个自定义类组件时，ref 对象将接收该组件已挂载的实例作为它的 current 。</p></li><li><p>不能在函数式组件上使用 ref 属性，因为它们没有实例。</p></li><li><p>可以在函数式组件内部使用 ref，只要它指向一个 DOM 元素或者 class 组件。</p><p> <img src="/images/react_patch/14.png" alt="refs用于函数组件内部"></p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的软件收集处</title>
      <link href="/2018/04/14/2018-4-14-%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
      <url>/2018/04/14/2018-4-14-%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><p>开发类</p><ul><li><p>vs code</p><ul><li>配色主题：one dark pro</li><li>图标主题：vscode great icons</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>zeal</p><p>离线文档（这个好好用）</p></li></ul><ul><li><p>应用类</p><ul><li>终端英汉词典：ydcv<ul><li>克隆地址：<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:felixonmars/ydcv.git`</li><li>安装：<code>sudo python setup.py install</code></li><li>设置快捷别名：<a href="https://blog.csdn.net/u011630575/article/details/48030663" target="_blank" rel="noopener">参考这里</a></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reStructuredText语法</title>
      <link href="/2017/11/20/reStructuredText/"/>
      <url>/2017/11/20/reStructuredText/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="noopener">reStructuredText官网-使用手册</a></li><li><a href="http://docutils.sourceforge.net/docs/user/rst/quickstart.html" target="_blank" rel="noopener">reStructuredTex官方语法</a></li><li><a href="http://www.pythondoc.com/sphinx/markup/toctree.html" target="_blank" rel="noopener">关于TOC树</a></li><li><a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a></li><li><a href="http://blog.csdn.net/u012150179/article/details/37743605" target="_blank" rel="noopener">博客2</a></li><li><a href="http://www.jianshu.com/p/1885d5570b37" target="_blank" rel="noopener">博客3</a></li></ol><a id="more"></a><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>一般语法可以参考上述所有资料，本文记录reStructedText的特殊语法。</p><h3 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h3><ul><li><p>文档内链接跳转语法</p><ol><li><p>在目标前 标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. highlight:: rst</span><br><span class="line">.. _3.1.1 云主机服务:</span><br></pre></td></tr></table></figure><p>..后有一个空格，::后有一个空格</p></li><li><p>在起始处 标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ref:`“3.4.1 报警” &lt;3.4.1 报警&gt;`</span><br></pre></td></tr></table></figure><p>前后各有一个空格，&lt;&gt;前有一个空格</p></li></ol></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>实际使用中发现，生成的pdf里，表格中的内容如果是以下划线连接的文字、斜杠连接的文字，表格在宽度不够的情况下无法自动分割文字至多行来适应有限的宽度。（也可能行数超过30行，但目前写的文档最后一列可以自动分割，推测是上述原因）</p><ul><li>写表格使用vim配合vim-table-mode插件。<ul><li>安装：<ol><li>首先安装<strong><a href="https://github.com/Shougo/neobundle.vim" target="_blank" rel="noopener">NeoBundle</a></strong> ；<ul><li>注意：.vimrc文件要自己创建，内容可以复制官方文档中给出的内容。</li></ul></li><li>调出vim，执行<code>:NeoBundleInstall</code> 在官方文档上有说明；</li><li>在<strong>~/.vimrc</strong>文档中添加<code>NeoBundle &#39;dhruvasagar/vim-table-mode&#39;</code> ；</li></ol></li><li>使用：vim界面输入<code>:TableModeToggle</code> 开启表格模式，接着分别输入<code>let g:table_mode_corner_corner=&#39;+&#39;</code> 以及<code>let g:table_mode_header_fillchar=&#39;=&#39;</code> 进入reStructuredText模式。详细使用见<a href="https://github.com/dhruvasagar/vim-table-mode" target="_blank" rel="noopener">官方文档</a> 。</li><li>修改：如果是重新打开文档，那么修改前要输入上述三个命令，进入正确的模式。<strong>修改只要修改内容，不用管边框是否对齐，不要手动调整！vim-table-mode插件会自动补齐。</strong></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> reStructuredText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sphinx</title>
      <link href="/2017/11/20/sphinx/"/>
      <url>/2017/11/20/sphinx/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://www.sphinx-doc.org/en/stable/contents.html" target="_blank" rel="noopener">sphinx官方-主页</a></li><li><a href="http://www.sphinx-doc.org/en/stable/config.html" target="_blank" rel="noopener">sphinx官方-config.py</a> ：生成html、latex以及转换成pdf的多数格式均在这个文件里进行配置</li><li><a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a>：本次使用第三方模板 <em>sphinx_rtd_theme</em></li><li><a href="http://www.sphinx-doc.org/en/stable/latex.html" target="_blank" rel="noopener">sphinx官方-latex输出配置说明</a></li><li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/invocation.html" target="_blank" rel="noopener">sphinx官方-创建指令</a></li><li><a href="http://zh-sphinx-doc.readthedocs.io/en/latest/invocation.html" target="_blank" rel="noopener">sphinx使用手册中文译文</a></li><li><a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>：环境搭建、快速构建</li></ol><a id="more"></a><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>环境搭建参考<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>。</p><ol><li>安装python</li><li>安装sphinx</li><li>安装textlive（可选）</li><li>安装汉字字体（可选）<ul><li>以装宋体为例（<a href="http://blog.csdn.net/wxwpxh/article/details/50532363" target="_blank" rel="noopener">simsun.ttc</a>），字体文件要注意是否可用</li></ul></li><li>安装第三方模板（可选）</li></ol><h3 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h3><p>快速构建参考<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a> 。</p><h3 id="文档结构配置"><a href="#文档结构配置" class="headerlink" title="文档结构配置"></a>文档结构配置</h3><ul><li><p>入口文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :hidden:</span><br><span class="line"></span><br><span class="line">   README</span><br><span class="line">   book/UOS4.0介绍</span><br><span class="line">   book/快速入门/index</span><br><span class="line">   book/UOS项目平台/index</span><br><span class="line">   book/UOS管理平台/index</span><br><span class="line">   book/UOS计费系统/index</span><br><span class="line">   book/UOS审批系统/index</span><br><span class="line">   book/UOS存储平台/index</span><br><span class="line">   book/UOS工单系统/index</span><br></pre></td></tr></table></figure><ul><li><code>.. toctree::</code>：这个指令用来设置文档组织结构，其中<ul><li><code>:maxdepth: 2</code> ：用来设置目录显示层级</li><li><code>:hidden: 用来设置是否在每个主页（index）中显示该目录</code></li><li><code>:number:</code>用来设置是否在目录前列出编号</li><li><code>:caption: 目录</code>用来修改在pdf中index前显示的文字，更多设置详见<a href="http://www.sphinx-doc.org/en/stable/markup/toctree.html#toctree-directive" target="_blank" rel="noopener">官方配置文档</a> </li></ul></li><li>下面的部分表示组织起来的结构，这里分别是各个章节的主页，会显示章节标题。每个章节的主页中再以此种形式列出各自的结构组织。</li></ul></li></ul><h3 id="config-py配置选项"><a href="#config-py配置选项" class="headerlink" title="config.py配置选项"></a>config.py配置选项</h3><ul><li><p>值得注意的通用配置</p><ol><li>文档格式：<code>source_suffix = &#39;.rst&#39;</code></li><li>编码类型（中文一定要用这个）：<code>source_encoding = &#39;utf-8&#39;</code></li><li>文档入口：<code>master_doc = &#39;index&#39;</code>       </li></ol></li><li><p>值得注意的html输出配置</p><ul><li>使用第三方模板（可以参考<a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a> 、<a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">博客1</a>）<ol><li>文档开头：<code>import sphinx_rtd_theme</code></li><li>“Options for HTML output”部分：<code>html_theme = &#39;sphinx_rtd_theme&#39;</code></li></ol></li><li>html_sidebars: html侧边栏显示（可以参考<a href="http://www.sphinx-doc.org/en/stable/theming.html#builtin-themes" target="_blank" rel="noopener">sphtinx官方-模板</a>）</li><li>不显示文档源文件： <code>html_show_sourcelink = False</code></li><li>不在底边显示“sphinx创建”字样： <code>html_show_sphinx = False</code></li></ul></li><li><p>latex输出配置1（用于转换pdf）</p><ul><li><p>处理引擎配置：<code>latex_engine = &#39;xelatex&#39;</code></p></li><li><p>latex_elements配置中：</p><ul><li><p>纸张大小： <code>&#39;papersize&#39;: &#39;a4paper&#39;</code></p></li><li><p>字体大小： <code>&#39;pointsize&#39;: &#39;10pt&#39;</code></p></li><li><p>preamble配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">\\usepackage&#123;xeCJK&#125;</span><br><span class="line">\\usepackage&#123;indentfirst&#125;</span><br><span class="line">\\setlength&#123;\\parindent&#125;&#123;2em&#125;</span><br><span class="line">\\setCJKmainfont&#123;SimSun&#125; #针对中文使用中文字体</span><br><span class="line">\\setCJKmonofont[Scale=0.9]&#123;SimSun&#125;</span><br><span class="line">\\setCJKfamilyfont&#123;song&#125;&#123;SimSun&#125;</span><br><span class="line">\\setCJKfamilyfont&#123;sf&#125;&#123;SimSun&#125;</span><br><span class="line">\\XeTeXlinebreakskip = 0pt plus 1pt</span><br><span class="line">\\setcounter&#123;tocdepth&#125;&#123;2&#125; #目录显示的层级</span><br><span class="line">    \\setcounter&#123;secnumdepth&#125;&#123;0&#125; #文档中标题前显示的编号等级</span><br><span class="line">    &apos;&apos;&apos;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单页输出： <code>&#39;classoptions&#39;: &#39;,oneside&#39;</code></p></li><li><p>章节样式：<code>&#39;fncychap&#39;: &#39;&#39;</code>空字符不使用章节</p></li><li><p>latex_documents配置的最后一项： 使用<code>&#39;howto&#39;</code> ，chm格式。</p></li></ul></li><li><p>latex输出配置2（用于输出pdf）</p><p>latex输出配置1输出的pdf不带页码，为了解决这个问题：</p><ul><li>增加：<code>latex_toplevel_sectioning = &#39;section&#39;</code></li><li>修改：’howto’改为’manual’</li></ul><p>关于latex配置选项，详见：<a href="http://www.sphinx-doc.org/en/stable/latex.html" target="_blank" rel="noopener">官方配置文档1</a>和<a href="http://www.sphinx-doc.org/en/stable/config.html#confval-latex_additional_files" target="_blank" rel="noopener">官方配置文档2</a> 。</p></li></ul><h3 id="表格配置"><a href="#表格配置" class="headerlink" title="表格配置"></a>表格配置</h3><p>表格配置指令使用：<code>.. tabularcolumns::</code> <code>column spec</code> ，放在表格所在文档表格前，详见：<a href="http://www.sphinx-doc.org/en/stable/markup/misc.html#tables" target="_blank" rel="noopener">官方配置文档</a> 。<strong>注意：超过30行的表格latex无法自动控制宽度，可以使用p{width}手动控制</strong> 。</p><h3 id="转换pdf指令"><a href="#转换pdf指令" class="headerlink" title="转换pdf指令"></a>转换pdf指令</h3><p>首先生成latex文档，之后使用xelatex（主要是为了处理中文）生成pdf，第二次使用xelatex为了生成pdf文档目录和文档中的连接。</p><ol><li>make latex</li><li>cd build/latex</li><li>xelatex *.tex</li><li>xelatex *.tex</li></ol><h3 id="关于转换pdf的方法"><a href="#关于转换pdf的方法" class="headerlink" title="关于转换pdf的方法"></a>关于转换pdf的方法</h3><p>试用过四种方法，只有xelatex成功。以下是其他三种未成功的方法：</p><ol><li>latexpdf指令：生成文档错误，未继续；</li><li>借用rst2pdf：sphinx官网上有说rst2pdf已停止维护，针对最新版可能有问题，实际使用中英文能够正常显示，中文显示未乱码，即便编码规则设定为utf-8依然不能正常显示；</li><li>借用rinohtype：sphinx官方推荐的一种直接转换pdf的方法。但实际使用中发现转换时间过长，且依然没有能处理好中文显示的问题。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> sphinx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统使用记录</title>
      <link href="/2017/11/20/ubuntu%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/11/20/ubuntu%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文是ubuntu使用方法汇总。</strong></p><a id="more"></a><h3 id="资料列表"><a href="#资料列表" class="headerlink" title="资料列表"></a>资料列表</h3><ol><li><a href="https://jingyan.baidu.com/article/60ccbceb18624464cab197ea.html" target="_blank" rel="noopener">双系统安装</a></li><li><a href="http://www.jianshu.com/p/2b24cd430a7d" target="_blank" rel="noopener">ubuntu下安装nodejs</a></li><li><a href="http://blog.csdn.net/txl910514/article/details/52136821" target="_blank" rel="noopener">ubuntu安装webstorm</a></li><li><a href="https://www.cnblogs.com/netfoxman/p/5994697.html" target="_blank" rel="noopener">ubuntu下多个python版本切换</a></li><li><a href="http://blog.csdn.net/wangjingfei/article/details/5614203" target="_blank" rel="noopener">ubuntu安装中文字体</a></li><li><a href="http://blog.csdn.net/kevinhg/article/details/5934462" target="_blank" rel="noopener">ubuntu下deb包的安装方法</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">ubuntu下科学上网配置</a></li><li><a href="https://blog.csdn.net/u011630575/article/details/48030663" target="_blank" rel="noopener">ubuntu下给指令设置别名</a></li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p>上述第7个链接只是<strong>shadowsocks-qt5</strong>的安装，火狐浏览器安装FoxyProxy Standard插件，并进行如下配置：</p><ul><li>Proxy Type: SOCKS5</li><li>IP address: 127.0.0.1</li><li>Port: 1080</li></ul></li></ol><h3 id="系统问题"><a href="#系统问题" class="headerlink" title="系统问题"></a>系统问题</h3><ol><li><p><strong>Kernel Panic -not syncing:VFS:Unable to mount foot fs on Unknown-block(0,0)</strong></p><ul><li>症状： 开机启动卡在紫色界面无法进入桌面，在重启后自动运行一系列代码，最后出现上述错误</li><li>原因： 查到的相关信息表明是由于系统的什么核升级没有升级完全导致</li><li>参考： <a href="https://askubuntu.com/questions/41930/kernel-panic-not-syncing-vfs-unable-to-mount-root-fs-on-unknown-block0-0" target="_blank" rel="noopener">Kernel Panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</a></li><li>解决办法：<ol><li>在选择系统的界面进入ubuntu高级选项，然后尝试各个可用版本的<code>recover mode</code>;</li><li>进入<code>recover mode</code>后，不需要点击任何选项，直接<code>tab</code>键进入最下面，点<code>enter</code>，之后可能还得<code>enter</code>，然后会自动执行一串命令行代码，进入当前版本的桌面；</li><li>启动终端；</li><li><code>uname -r</code>查看当前版本；</li><li><code>update-initramfs -u -k version</code>重新恢复/升级安装当前版本</li><li><code>update-grub</code>更新grub</li></ol></li></ul></li><li><p><strong>stdout no space left on device</strong></p><ul><li>症状： 恢复上述版本安装的时候可能会出现这个错误，怀疑平时更新不成功说没有地方也是这个原因。<strong>这个叫移除ubuntu系统中旧版内核，搜索可以这样搜</strong>。</li><li>原因： 就是某个盘给的空间可能小了，然后还存在多个版本，地儿不够，以后再说吧，懒得整</li><li>参考：<br><a href="https://askubuntu.com/questions/929305/gzip-stdout-no-space-left-on-device-e-mkinitramfs-failure-cpio-141-gzip-1/929681#929681" target="_blank" rel="noopener">gzip: stdout: No space left on device E: mkinitramfs failure cpio 141 gzip</a><br><a href="https://askubuntu.com/questions/223248/gzip-stdout-no-space-left-on-device-while-upgrading-the-kernel" target="_blank" rel="noopener">gzip: stdout: No space left on device” while upgrading the kernel</a></li><li>解决办法：<ol><li><code>uname -r</code>查看当前版本；</li><li><code>ls /boot</code>查看所有版本；</li><li><code>sudo apt-get autoremove linux-image-old-version</code>删除不需要的版本释放空间</li></ol></li></ul></li><li><p><strong>启动桌面不显示工具栏</strong></p><ol><li><p>尝试重启，依次输入下面的命令<br><code>ctrl_alt+f1</code></p><p><code>sudo service lightdm restart</code></p></li><li><p>重启不行就重装unity（这是个what），依次输入下面的命令<br><code>sudo apt-get update</code></p><p><code>sudo apt-get install --reinstall ubuntu-desktop</code></p><p><code>sudo apt-get install unity</code></p></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习</title>
      <link href="/2017/07/24/D3%20learn/"/>
      <url>/2017/07/24/D3%20learn/</url>
      
        <content type="html"><![CDATA[<p>这篇是D3的学习总结。由于Freecodecamp的D3新版教程还没有上线，D3的基础学习资料是自己从网上搜集来跟着学的，然后完成了Freecodecamp上的5个小项目。</p><a id="more"></a><h3 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h3><ol><li><p><a href="https://github.com/d3/d3/wiki/Tutorials" target="_blank" rel="noopener">这里</a>是D3官方给出的一些教程，我看了Introductions &amp; Core Concepts部分的前10篇，全部是D3的作者Mike Bostock大神写，其中<a href="https://bost.ocks.org/mike/join/" target="_blank" rel="noopener">Thinking with Joins</a>以及<a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">How Selections Work</a>这两篇看过之后豁然开朗，大概明白了D3为何要写成这样，比如先引用不存在的节点再创造节点。D3做出来的东西真的很惊艳，是我最喜欢的一个库（虽然我也没接触几个…）。<a href="https://codepen.io/ginnko/pen/MoqwPr" target="_blank" rel="noopener">basic bar</a>、<a href="https://codepen.io/ginnko/pen/bRmorb" target="_blank" rel="noopener">letter frequencies</a>、<a href="https://codepen.io/ginnko/pen/GEwqxp" target="_blank" rel="noopener">general update 1</a>、<a href="https://codepen.io/ginnko/pen/YQRGNG" target="_blank" rel="noopener">general update 2</a>、<a href="https://codepen.io/ginnko/pen/eRQdxY" target="_blank" rel="noopener">general update 3</a>、<a href="https://codepen.io/ginnko/pen/pwxVGM" target="_blank" rel="noopener">circle</a>这6个练习是跟着Mike Bostock大神的教程自己敲进去的代码实现。上述给出的教程链接感觉很重要，日后遗忘可以进行参考。</p></li><li><p>使用codepen写练习有时需要外部获取数据文件，比如图片、json文件、tsv文件。对于图片，使用google drive和dropbox均可以达到目的，google drive使用<a href="http://gdurl.com/" target="_blank" rel="noopener">gdurl</a>或<a href="https://sites.google.com/site/gdocs2direct/" target="_blank" rel="noopener">这个</a>均可以生成永久链接（gdurl有时会生成http形式的链接，在codepen中无法使用）。而json文件、tsv文件存储在google drive中无法使用ajax技术获取，目前的办法是存储在dropbox，生成分享链接，稍作修改，作为最后的url。<br>正确的url: <code>https://dl.dropboxusercontent.com/s/</code> + <strong>hfgg7cdoedkv1he/ky-counties.json(dropbox生成的链接中包含这部分，相应替换)</strong> + <code>?dl=1</code>。</p></li><li><p>这里插一段题外话，这三个月的自学让自己发现，那种从非常基础的底层理论入手，全面学习后再进行各项练习的学习方法或许真的不适合自己，当然这也是对特定的学科，特定阶段而言。比如学习语法，就需要全面了解一下常用基础语法，才能顺利进行下一步。但是更重要的进一步的提升需要的是大量的练习，从目的出发，反向学习需要的东西，更有效率。目前发现对于语言（机器语言、自然语言）的学习，这种方法对自己特别有效。但对于写程序而言，这么说似乎有些耍小聪明，毕竟计算机科学是一套完整的理论的体系，还有大量的基础等着我去学习，任重道远。</p></li></ol><p>下面是freecodecamp中的5个项目练习，主要记录自己遇到的一些问题，解决办法，没有解决的问题以及一些感想。</p><h3 id="Visualize-Data-with-a-Bar-Chart"><a href="#Visualize-Data-with-a-Bar-Chart" class="headerlink" title="Visualize Data with a Bar Chart"></a><a href="https://codepen.io/ginnko/full/YQRgxM/" target="_blank" rel="noopener">Visualize Data with a Bar Chart</a></h3><p>这个项目是利用D3做了一张柱状图，涉及的是D3的基本的标准使用方法。  </p><ul><li><strong>引用的库：</strong> d3标准库和d3-tip库  </li><li><strong>过程：</strong> 1. 准备阶段：获取json文件的url、数据转换方式、图纸大小、坐标轴的比例和转换；2.画图阶段：利用d3.json获取数据，完善坐标轴标尺，绘制图形、坐标轴、标题等。  </li><li><p><strong>遇到的问题：</strong><br>1.时间数据的转换<br><code>var parseTime = d3.timeParse(&quot;%Y-%m-%d&quot;);</code><br><code>var timeFormat = d3.timeFormat(%Y-%m);</code><br>利用上面两行代码将以string格式表示的时间数据和js中的时间类型相互转换，更多的转换类型点击<a href="https://github.com/d3/d3-scale/blob/master/README.md#band_bandwidth" target="_blank" rel="noopener">这里</a>。可以在使用数据前统一对数据进行预处理，如下。</p><pre><code>var data = json.data;data.forEach(function(d){d[0] = parseTime(d[0]);d[1] = +d[1];});</code></pre><p>2.比例尺<br>这个项目使用了三种比例尺，时间、线性、序数比例尺，对应d3.scaleTime(用来设置横坐标轴)、d3.scaleLinear（用来设置纵坐标轴以及图形的y值定位）以及d3.scaleBand（用来设置图形的宽度以及图形x值定位）。同时利用<strong>d3.scaleBand</strong>和<strong>d3.scaleTime</strong>来进行图形x方向定位和宽度设置时，图纸宽度的选择是关键！<code>图纸有效宽度/数据数量 = 一个整数</code>，否则画出的bar之间会有间距。其实，只是用d3.scaleBand可以实现目的，在后面的项目中有用法。<br>3.绑定问题<br>将g绑定到svg后，再绑定数据时，不用使用tag名称，会出现数据绑定不全的问题，此时应使用class名称来绑定。具体原因没有找到说法。  </p></li></ul><h3 id="Visualize-Data-with-a-Scatterplot-Graph"><a href="#Visualize-Data-with-a-Scatterplot-Graph" class="headerlink" title="Visualize Data with a Scatterplot Graph "></a><a href="https://codepen.io/ginnko/pen/mwvmdW" target="_blank" rel="noopener">Visualize Data with a Scatterplot Graph </a></h3><p>这个项目的图形是用circle表示的，和bar大同小异。  </p><ul><li><strong>遇到的问题</strong><br>1.在固定的位置用来显示tip：先创建一个固定位置，然后在具体操作代码处稍作调整。<br>创建固定位置：  <pre><code>chart.call(tip);var show = chart.append(&quot;g&quot;).attr(&quot;id&quot;, &quot;show&quot;).attr(&quot;cx&quot;, &quot;5&quot;).attr(&quot;cy&quot;, &quot;5&quot;);</code></pre>调整代码：<br><code>.on(&quot;mouseover&quot;, function(d){tip.show(d,document.getElementById(&quot;show&quot;))})</code></li></ul><h3 id="Visualize-Data-with-a-Heat-Map"><a href="#Visualize-Data-with-a-Heat-Map" class="headerlink" title="Visualize Data with a Heat Map "></a><a href="https://codepen.io/ginnko/pen/bRZeWy?editors=0010" target="_blank" rel="noopener">Visualize Data with a Heat Map </a></h3><p>这个项目用来表示地表温度，画出来有些震撼，基本没有遇到难点。  </p><h3 id="Show-National-Contiguity-with-a-Force-Directed-Graph"><a href="#Show-National-Contiguity-with-a-Force-Directed-Graph" class="headerlink" title="Show National Contiguity with a Force Directed Graph "></a><a href="https://codepen.io/ginnko/pen/xreaEp" target="_blank" rel="noopener">Show National Contiguity with a Force Directed Graph </a></h3><p>这张图使用了d3的force layout。说实话，对force layout的学习并不深入，很多东西还不太明白，此处只记录了force的基本实现过程，其他同上。  </p><ul><li><strong>引用的库：</strong>d3标准库  </li><li><strong>参考文档：</strong><a href="https://github.com/d3/d3/blob/master/API.md#forces-d3-force" target="_blank" rel="noopener">官方文档</a>、<a href="https://bl.ocks.org/mbostock/f584aa36df54c451c94a9d0798caed35" target="_blank" rel="noopener">实例1</a>、<a href="https://bl.ocks.org/mbostock/950642" target="_blank" rel="noopener">实例2</a>、<a href="https://css-tricks.com/css-sprites/" target="_blank" rel="noopener">sprite</a>  </li><li><p><strong>注意：</strong><br>1.div使用left、right属性来定位<br>2.为了在svg中使用css-sprite, link和node要放在同一个div内<br>html：</p><pre><code>&lt;div id=&quot;root&quot; width=&quot;900px&quot; height=&quot;600px&quot;&gt;  &lt;h2&gt;Force Directed Graph of State Contiguity&lt;/h2&gt;  &lt;div id=&quot;node&quot; &gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>js:</p><pre><code>var link = svg.append(&quot;g&quot;).attr(&quot;class&quot;, &quot;links&quot;).selectAll(&quot;line&quot;).data(graph.links).enter().append(&quot;line&quot;).attr(&quot;stroke-width&quot;, 1);var node = d3.select(&quot;#node&quot;).selectAll(&quot;.flag&quot;).data(graph.nodes).enter().append(&quot;div&quot;).attr(&quot;class&quot;, function(d){  return &quot;flag flag-&quot; + d.code;})</code></pre><p>2.这个练习没有使用d3-tip库来实现tooltip，方法如下</p><pre><code>var tip = d3.select(&quot;#root&quot;).append(&quot;div&quot;).attr(&quot;class&quot;, &quot;tooltip&quot;).style(&quot;opacity&quot;, 0);  ....on(&quot;mouseover&quot;, function(d) {  tip.transition()    .duration(200)    .style(&quot;opacity&quot;, .9);  tip.html(d.country)    .style(&quot;left&quot;, (d3.event.pageX) + &quot;px&quot;)    .style(&quot;top&quot;, (d3.event.pageY) + &quot;px&quot;);}).on(&quot;mouseout&quot;, function(d) {  tip.transition()    .style(&quot;opacity&quot;, 0);</code></pre><p>3.css的设置，涉及绝对位置显示和居中的问题</p><pre><code>svg{  border: 1px black solid;  display: block;  margin: auto;}#node{  position: absolute;  margin:auto;  width: 900px;  left: 0;  right: 0;}div.tooltip {  position: absolute;  text-align: center;  padding: 2px;  font: 12px sans-serif;  color: white;  background: steelblue;  border: 0px;  border-radius: 8px;  pointer-events: none;}.flag {    position: absolute;    width: 16px;    height: 11px;    background: url(&apos;http://gdurl.com/R0x1&apos;) no-repeat;}</code></pre></li><li><p><strong>过程：</strong><br>1.创建一个force模拟对象</p><pre><code>var simulation = d3.forceSimulation().force(&quot;link&quot;, d3.forceLink().id(function(d){return d.index;})).force(&quot;charge&quot;, d3.forceManyBody()).force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2)).force(&quot;y&quot;, d3.forceY(0)).force(&quot;x&quot;, d3.forceX(0));</code></pre><p>2.数据绑定</p><pre><code>simulation  .nodes(graph.nodes)  .on(&quot;tick&quot;, ticked);simulation.force(&quot;link&quot;)  .links(graph.links);</code></pre><p>3.正常创建link和node</p><pre><code>var link = svg.append(&quot;g&quot;).attr(&quot;class&quot;, &quot;links&quot;).selectAll(&quot;line&quot;).data(graph.links).enter().append(&quot;line&quot;).attr(&quot;stroke-width&quot;, 1);var node = d3.select(&quot;#node&quot;).selectAll(&quot;.flag&quot;).data(graph.nodes).enter().append(&quot;div&quot;).attr(&quot;class&quot;, function(d){  return &quot;flag flag-&quot; + d.code;}).call(d3.drag()      .on(&quot;start&quot;, dragstarted)      .on(&quot;drag&quot;, dragged)      .on(&quot;end&quot;, dragended)).on(&quot;mouseover&quot;, function(d) {  tip.transition()    .duration(200)    .style(&quot;opacity&quot;, .9);  tip.html(d.country)    .style(&quot;left&quot;, (d3.event.pageX) + &quot;px&quot;)    .style(&quot;top&quot;, (d3.event.pageY) + &quot;px&quot;);}).on(&quot;mouseout&quot;, function(d) {  tip.transition()    .style(&quot;opacity&quot;, 0);</code></pre><p>4.对node和link的操作</p><pre><code>  function ticked(){  link    .attr(&quot;x1&quot;, function(d){return d.source.x;})    .attr(&quot;y1&quot;, function(d){return d.source.y;})    .attr(&quot;x2&quot;, function(d){return d.target.x;})    .attr(&quot;y2&quot;, function(d){return d.target.y;});  node    .style(&quot;left&quot;, function(d){return d.x + &quot;px&quot;;})    .style(&quot;top&quot;, function(d){return d.y + &quot;px&quot;;});}</code></pre><h3 id="Map-data-across-the-globe"><a href="#Map-data-across-the-globe" class="headerlink" title="Map data across the globe"></a><a href="https://codepen.io/ginnko/pen/LLwyvv" target="_blank" rel="noopener">Map data across the globe</a></h3><p>使用D3来绘制地图，做完这个项目，我意识到D3绘图是一层一层画的，不同的内容位于不同的图层，后画的内容显示在上层。开始做项目之前，先跟着下面的两个教程预热了一下，画了<a href="https://codepen.io/ginnko/pen/yXdYQd" target="_blank" rel="noopener">波士顿老鼠分布地图</a>和<a href="https://codepen.io/ginnko/pen/gRNzRB" target="_blank" rel="noopener">美国失业情况地图</a>。  </p></li><li><strong>教程：</strong><a href="https://github.com/topojson/topojson/wiki/Gallery" target="_blank" rel="noopener">地图gallery</a>，<a href="http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/" target="_blank" rel="noopener">DUSPviz</a>  </li><li><strong>涉及的库：</strong>D3标准库，topojson库，D3 queue库  </li><li><strong>重要概念：</strong>1.projection: 自己理解为某种模板，用来处理地理坐标和图纸坐标的关系；2.topojson：用来处理数据的一种方法，主要用了其中的topojson.feature()（用来转换数据）和topojson.mesh()（转换同时筛选数据）；3.queue：用于下载完所需的全部数据再执行后续的操作。  </li><li><strong>过程：</strong> 1.基本设置；2.画地图；3.添加陨石数据；4；添加zoom  </li><li><p><strong>遇到的问题：</strong><br>1.大圆遮挡了小圆<br>使用sort方法对数据进行了从大到小的排序，利用后画的图形在上层的特点。</p><pre><code>data.sort(function(a, b){  if(a.properties.mass &gt; b.properties.mass)    return -1;  else if(a.properties.mass &lt; b.properties.mass)    return 1;  return 0;});  </code></pre><p>2.append数据时，遇到null的情况处理办法</p><pre><code>.attr(&quot;cx&quot;, function(m){return m.geometry == null ? projection([0, 0])[0] : projection(m.geometry.coordinates)[0];}).attr(&quot;cy&quot;, function(m){return m.geometry == null ? projection([0, 0])[0] : projection(m.geometry.coordinates)[1];}).attr(&quot;fill&quot;, function(m, i){return color(i);}).attr(&quot;r&quot;, function(m){return m.geometry == null ? 0 : size(Math.sqrt(m.properties.mass));})  </code></pre><p>3.使用zoom</p><pre><code>var zoom = d3.zoom().scaleExtent([1, 8]).on(&quot;zoom&quot;, zoomed);function zoomed(){  var transform = d3.zoomTransform(this);  g.attr(&quot;transform&quot;, transform);  d3.selectAll(&quot;circle&quot;).attr(&quot;transform&quot;, transform);}svg.call(zoom);  </code></pre><p>4.svg的居中</p><pre><code>svg  border: 1px solid black  display: block  margin: auto</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习</title>
      <link href="/2017/06/19/React%20learn/"/>
      <url>/2017/06/19/React%20learn/</url>
      
        <content type="html"><![CDATA[<p>这篇是React入门的学习总结，主要参考阮一峰大神的教程（如下）和官方文档，用codepen完成了教程里的<a href="https://codepen.io/ginnko/pen/EXWaaw" target="_blank" rel="noopener">demo</a>。</p><a id="more"></a><h2 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h2><h3 id="1-资料"><a href="#1-资料" class="headerlink" title="1. 资料"></a>1. 资料</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮大角虫的教程</a></li><li><a href="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="noopener">官网</a></li><li><a href="https://codepen.io/gaearon/#" target="_blank" rel="noopener">Dan Abramov大神的实例</a></li></ul><h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><ul><li><p>不太清楚React具体能做什么</p><blockquote><p>通过这段时间的练习，感觉React确实很适合UI，大神们说的没错。</p></blockquote></li><li><p>教程里有个使用Promise的例子，虽然明白Promise最主要的有点就是将执行过程和结果分开，但是并没有觉得这有什么特别好处，只是看起来更清晰了？关于Promise的部分参考了<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="noopener">廖大角虫的教程</a>。</p></li><li><p>当使用setInterval()和Ajax的同时使用了bind（）函数，不太理解这个地方。</p><blockquote><p>bind(this)是将当前作用域传入相应的函数，在ES6中被要求要明确的表示，因为不再自动匹配，在下面的<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">“是否使用ES6的方法对比”</a>中有说明。  </p></blockquote></li><li><p>receive box这个应用中，自己写的代码是把所有的功能放进一个组件类中，别人的代码是像函数那样将完成一个功能的代码组合放进一个单独的组件类，在其他组件类中进行调用。后面的练习要使用这种方式。</p></li></ul><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ul><li>组件类的变量名的首字母要<strong>大写</strong>！！！</li><li>rent中的顶级标签只能有一个，所以示例中的全部用<div>标签包裹</div></li><li>关于<a href="https://facebook.github.io/react/docs/handling-events.html" target="_blank" rel="noopener">handle事件和this</a><br>如果一个方法后面没有直接跟着一个括号，就要手动绑定this和这个方法。解决办法有三：  <blockquote><ol><li>手动在constructor方法里绑定，例如：this.handleClick = this.handleClick.bind(this);</li><li>使用属性初始化语法 handleClick = () =&gt;{//其他代码}<strong>结束没有分号</strong></li><li>使用箭头函数，前面不需要事先绑定或使用属性初始化语法，在元素中使用箭头函数： <button onclick="{(e)" => this.handleClick(e)}&gt;Click me</button></li></ol></blockquote></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-Leaderboard"><a href="#1-Leaderboard" class="headerlink" title="1. Leaderboard"></a>1. Leaderboard</h3><p>这个<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>是<a href="https://www.freecodecamp.com/challenges/build-a-camper-leaderboard" target="_blank" rel="noopener">FreeCodeCamp</a>的一个练习，使用React实现（2017.6.23完成）。</p><h4 id="一个方法：componentDidUpdate"><a href="#一个方法：componentDidUpdate" class="headerlink" title="一个方法：componentDidUpdate()"></a>一个方法：componentDidUpdate()</h4><p>第一版使用如下代码，但现在看来是自己对componentDidUpdate()这个方法理解有问题，虽然能够实现下述的功能，但这个方法的真正使用方法应该不是这样。</p><blockquote><p>这个方法用来实现当属性或状态发生变化时，对页面中的相应内容进行变更。<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>中点击30天内的分数排名和总分数排名的切换就是通过这个方法实现的。实现的代码如下：  </p></blockquote><pre><code>componentDidUpdate(){  this.props.promise.then(    value =&gt; this.setState({loading: false, data: value}),    error =&gt; this.setState({loading: false, error: error})  );},handleClick: function(event){  if(flag === 0){    flag = 1;    this.props.promise = $.getJSON(alltime);  }else{    flag = 0;    this.props.promise = $.getJSON(recent);  }}</code></pre><blockquote><p>handleClick属性传给标题中的30天内排名和总分数排名两个标题，当点击时，会相应的改变ajax请求的api并把返回结果传递给promise属性，发生的改变会被componentDidUpdate()方法捕捉，然后使用新的数据重新渲染模板。</p></blockquote><h4 id="一个属性handleClick"><a href="#一个属性handleClick" class="headerlink" title="一个属性handleClick"></a>一个属性handleClick</h4><p>这个<a href="https://codepen.io/ginnko/full/bRqXaN/" target="_blank" rel="noopener">demo</a>最终是通过handleClick属性完成切换是根据30天分数排名还是根据总分数排名，还可以选择是正序显示还是倒序显示，不再使用componentDidUpdate()方法。具体代码如下。</p><pre><code>handleClick: function(event){  var id = event.target.parentElement.getAttribute(&apos;id&apos;);  if(id === &quot;alltime&quot;){    this.props.promise = $.getJSON(alltime);    if(flag2 === 1){      flag1 = 1;      flag2 = 0;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value, mark2 :&quot;↓&quot;, mark1 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }else{      flag1 = 1;      flag2 = 1;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value.reverse(), mark2 :&quot;↑&quot;, mark1 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }  }  if(id === &quot;recent&quot;){    this.props.promise = $.getJSON(recent);    if(flag1 === 1){      flag2 = 1;      flag1 = 0;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value, mark1 :&quot;↓&quot;, mark2 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }else{      flag2 = 1;      flag1 = 1;      this.props.promise.then(        value =&gt; this.setState({loading: false, data: value.reverse(), mark1 :&quot;↑&quot;, mark2 :&quot;&quot;}),        error =&gt; this.setState({loading: false, error: error})      );    }  }}</code></pre><p>有两处引用了handleClick，使用<strong>event.target.parentElement.getAttribute(‘id’)</strong>来判断是哪个发生了点击，并据此显示是根据哪类分数显示。<br>这条代码的使用参考<a href="https://stackoverflow.com/questions/39559222/react-onclick-event-on-link" target="_blank" rel="noopener">此处</a>。event.target可以获得发生点击事件的DOM node本身。然后使用操纵DOM node的方法<a href="https://developer.mozilla.org/en/docs/Web/API/Node/parentElement" target="_blank" rel="noopener">parentElement</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute" target="_blank" rel="noopener">getAttribute()</a>进行判断。event.target真是方便啊！</p><h4 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h4><ol><li>第一次加载时，由于需要渲染，页面是完全白色的，渲染完成后加载相应的内容。但是在初始加载完成后，后面更新数据重新渲染不会再重新加载页面而只是渲染页面变更的部分，之前一直不太明白React的用途，只是听过适合开发UI，或许上面的描述就是一个证据。</li><li>本例中，使用componentDidMount方法来处理ajax请求，根据现在掌握的资料，推断这个方法只能使用一次，也就是在组件加载完成后，之后属性或状态再发生变化要通过componentDidUpdate()方法（有待研究）或handleEvent系列属性来实现。另一个handleEvent属性的实例：<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮大角虫的教程</a>中第9个demo是一个实时显示的应用，使用的是handleChange属性，属性函数里用event.target.value来获取实时改变的值并显示。</li></ol><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ol><li>最初的代码是，关于图标和表格标题的部分都写在html文档中，页面一加载就能看到这两项内容，表格的数据部分用json获取后通过React返回。当React使用render返回一个被DOM元素包裹的数组时，React会自动将其展开一条一条列出。但是，render函数中要求只能有一个顶级标签，导致返回的表格数组和已经写好的表格标题不一样大小，只占其第一列的宽度。没有查到解决办法，参考别人的项目，也没有这样写的，最后只能让所有的部分都由React来实现。希望能找到解决上述问题的方法。</li><li>colspan 属性名在JSX中要写成colSpan才会被识别。</li><li><p>ES6发布后，React的一些方法有了改变，阮一峰大神的教程使用的是ES6发布前的方法。这个demo也没有使用ES6，但是在之后的练习中都要使用最新的方法。下面两个链接是React官方文档和是否使用ES6的一些方法的改变对比：  </p><ul><li><a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">常用方法</a></li><li><a href="https://facebook.github.io/react/docs/react-without-es6.html" target="_blank" rel="noopener">是否使用ES6的方法对比</a>  </li></ul></li></ol><h3 id="2-Recipe-game"><a href="#2-Recipe-game" class="headerlink" title="2. Recipe game"></a>2. Recipe game</h3><p>这个<a href="https://codepen.io/ginnko/full/XgzqKG/" target="_blank" rel="noopener">demo</a>是FreeCodeCamp的一个练习，使用React实现（2017.6.28完成）。大结构使用了Bootstrap的<a href="https://v4-alpha.getbootstrap.com/components/modal/" target="_blank" rel="noopener">Modal</a>和cards中的<a href="https://v4-alpha.getbootstrap.com/components/card/" target="_blank" rel="noopener">list group</a>。使用动态Modal弹出一个窗口接受和修改数据，list group用来组织数据，静态Modal用来显示数据。</p><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>参考资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener">localStorage接口</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">JSON.stringify()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse()</a>  </p><ol><li>能存入localstorage的数据没有限制原数据结构，只要转成字符串都可以存入。存入前使用JSON.stringify（）将原对象转成字符串，取出后使用JSON.parse()还原成原数据结构。  </li><li>使用localStorage.setItem(key, value)存入对象，localStorage.getItem(key)获取对象。  </li><li>对于有默认初始值得情况，使用下面的方法进行第一次赋值，借鉴了<a href="https://codepen.io/awesom3/pen/Hlfma?editors=1010" target="_blank" rel="noopener">Awesomen3ss 大神</a>的方法。  </li></ol><p>项目中的代码如下：  </p><pre><code>var recipeList = [[&quot;Braised string bean with noodle&quot;, &quot;garlic&quot;, &quot;noodle&quot;, &quot;string bean&quot;,&quot;coriander&quot;, &quot;salt&quot;, &quot;light soy sauce&quot;], [&quot;Braised hairtail&quot;, &quot;hairtail&quot;, &quot;vinegar&quot;, &quot;scallion&quot;, &quot;garlic&quot;, &quot;ginger&quot;, &quot;distilled spirit&quot;, &quot;salt&quot;], [&quot;Scrambled eggs with tomatoes&quot;, &quot;tomatoes&quot;, &quot;egg&quot;, &quot;scallion&quot;, &quot;salt&quot;]];  var condition = localStorage.getItem(&quot;recipeList&quot;);if(condition === null){  localStorage.setItem(&quot;recipeList&quot;, JSON.stringify(recipeList));}</code></pre><h4 id="handle事件的绑定和使用"><a href="#handle事件的绑定和使用" class="headerlink" title="handle事件的绑定和使用"></a>handle事件的绑定和使用</h4><ul><li>React的ES6版本中，handle事件要在初始化中明确绑定，参考<a href="https://facebook.github.io/react/docs/handling-events.html" target="_blank" rel="noopener">官方文档</a>。  </li></ul><p>下面的代码是这个项目中的使用：</p><pre><code>constructor(props){  super(props);  this.state = {list: localStorage.getItem(&quot;recipeList&quot;), value: [temRecipe,temIngredients]};  this.handleClick = this.handleClick.bind(this);  this.handleChange = this.handleChange.bind(this);}  </code></pre><ul><li>“this”位于一个函数中时，它的作用域就是这个函数，正常函数的写法无法接触到需要的DOM对象，导致无法加载DOM对象，页面一篇空白的错误，解决方法是使用<a href="https://stackoverflow.com/questions/41174980/handling-clicks-on-dynamically-generated-buttons" target="_blank" rel="noopener">arrow function</a>，handle函数和后面的应用函数都使用箭头函数的形式。<strong>关于this的使用还是不太理解！</strong></li></ul><p>下面的代码是这个项目中的使用：  </p><pre><code>handleChange = (event) =&gt; {//。。。}handleClick = (event) =&gt; {//。。。}var recipeStructure = JSON.parse(this.state.list).map((val, index) =&gt; {//。。。}var ingredientsList = val.slice(1).map((ele, index) =&gt; {//。。。}</code></pre><ul><li>如果一个map函数循环一个数组并作为组件对象输出到最后的DOM结构中时，要在每次输出过程中包含一个类似id的成为key的属性，来帮助React识别哪一条发生了改变，参考<a href="https://facebook.github.io/react/docs/lists-and-keys.html" target="_blank" rel="noopener">官方文档</a>。</li></ul><h4 id="Forms的Controlled-Components"><a href="#Forms的Controlled-Components" class="headerlink" title="Forms的Controlled Components"></a>Forms的Controlled Components</h4><p>“input”、”textarea”标签使用value属性定义页面加载后输入框中的内容，要想实现能够被编辑，需要再添加onChange属性，参考<a href="https://facebook.github.io/react/docs/forms.html#default-value" target="_blank" rel="noopener">官网文档</a>。</p><h3 id="3-Game-of-Life"><a href="#3-Game-of-Life" class="headerlink" title="3. Game of Life"></a>3. Game of Life</h3><p>这个<a href="https://codepen.io/ginnko/full/YQvVRw/" target="_blank" rel="noopener">demo</a>是FreeCodeCamp的一个练习，使用React实现（2017.7.05完成）。在做这个项目之前，把官方文档的基础部分全部看了一遍，这个项目中，尽量应用了学到的一些原则，比如把有具体单一功能的代码放到一个组件或函数中。  </p><ul><li><p>函数</p><blockquote><p>search：获取某个存活细胞周围的8个邻居<br>execute: 判断这当代细胞的存活<br>repeat： 重复执行判断过程  </p></blockquote></li><li><p>组件</p><blockquote><p>NewTable：制造board<br>TableConstruct: 加载board以及三类点击事件（控制、board大小、速度）  </p></blockquote></li></ul><p>感觉TableConstruct的内容依然过多，可以进一步分离。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><ul><li>在React中，如果想要实现通过点击某个按钮来实现改变某个元素变化的速度，就要通过<a href="https://stackoverflow.com/questions/1280263/changing-the-interval-of-setinterval-while-its-running" target="_blank" rel="noopener">SetTimeout()</a>来实现。setTimeout()允许在运行过程中改变时间间隔，setInterval()没有这项功能。</li><li>如果要在setTimeout()或setInterval()的回调函数中直接使用所在组件的this，因为<a href="https://stackoverflow.com/questions/26348557/issue-accessing-state-inside-setinterval-in-react-js" target="_blank" rel="noopener">作用域</a>的原因，要var self = this;通过self传入this或手动绑定this。</li><li><p>setInterval()的循环不能直接放进for或while循环体中，要是用类似迭代的方式。<br>如下代码：</p><pre><code>function repeat(){  execute();  timer = setTimeout(repeat, self.state.speed);}</code></pre></li></ul><h4 id="state-amp-props"><a href="#state-amp-props" class="headerlink" title="state &amp; props"></a>state &amp; props</h4><p>本例中，NewTable组件里同时使用了props和state，忘记官方文档里是不是有说尽量把state和props分开使用了，这个有待确定。代码如下：</p><pre><code>class NewTable extends React.Component{  constructor(props){    super(props);    this.handleClick = this.handleClick.bind(this);    this.state = {};  }  handleClick(e){    var flag = e.target.getAttribute(&quot;class&quot;);    if(flag === &quot;white&quot;){      e.target.setAttribute(&quot;class&quot;, &quot;red&quot;);    }else{      e.target.setAttribute(&quot;class&quot;, &quot;white&quot;);    }  }  render(){    var row = [];    var rowLen = this.props.rowNumber;    var columnLen = this.props.columnNumber;    var key = 0;    var flag = 0;    for(let j = 0; j&lt;rowLen; j++){      var tableData = [];      for(let i = 0; i&lt;columnLen; i++){        if(start === 0){          flag = Math.round(Math.random());        }else{          flag = 0;        }        tableData.push(&lt;td id={key++} r={0} onClick={this.handleClick} className={flag===0?&quot;white&quot;:&quot;red&quot;} role=&quot;button&quot;&gt;&lt;/td&gt;);      }      row.push(&lt;tr&gt;{tableData}&lt;/tr&gt;);    }    start = 1;    return &lt;tbody&gt;{row}&lt;/tbody&gt;;  }}</code></pre><h4 id="关于jQuery和DOM的操作"><a href="#关于jQuery和DOM的操作" class="headerlink" title="关于jQuery和DOM的操作"></a>关于jQuery和DOM的操作</h4><ul><li>使用jQuery删除属性，方法：<code>$(&quot;p&quot;).removeAttr(&quot;id&quot;);</code>即可成功删除id属性。</li><li>DOM元素使用<code>getAttribute()</code>和<code>setAttribute()</code>两个函数来操作属性；而jQuery使用<code>.attr()</code>来操作属性</li></ul><h4 id="JSX中的属性名称"><a href="#JSX中的属性名称" class="headerlink" title="JSX中的属性名称"></a>JSX中的属性名称</h4><p>官方文档中，有说JSX属性名称使用驼峰命名法，这个项目中NewTable组件里的这行代码<code>tableData.push(&lt;td id={key++} r={0} onClick={this.handleClick} className={flag===0?&quot;white&quot;:&quot;red&quot;} role=&quot;button&quot;&gt;&lt;/td&gt;);</code>最开始属性名<strong>r</strong>是写作<strong>relive</strong>但是在后面获取时失败，这明明是一个单词，不知道该在哪里驼峰。。。有待确认。  </p><h3 id="4-Roguelike-Dungeon-Crawler-Game-2017-7-28完成"><a href="#4-Roguelike-Dungeon-Crawler-Game-2017-7-28完成" class="headerlink" title="4. Roguelike Dungeon Crawler Game(2017.7.28完成)"></a>4. <a href="https://codepen.io/ginnko/full/JydBWO/" target="_blank" rel="noopener">Roguelike Dungeon Crawler Game</a>(2017.7.28完成)</h3><p>这个小项目是目前最耗时的一个，写了很久，也有很多想法。最重要的一个想法是基础太重要了，所以决定后面拿出一部分时间来复习css、js基础。下面来说这个项目。  </p><h4 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h4><p>界面可以分成五个部分，左侧的状态、中间的游戏板、上方的阴影遮挡、右侧的解释以及下方的说明。  </p><ul><li>下方的说明：说明部分没有借助React，是使用html节点直接显示</li><li>左侧状态栏、右侧解释栏：独立组件，使用React生成，但是其中信息的更新使用了全局变量，没有通过React的状态更新（因为不知如何用React处理游戏板更新但状态栏和解释栏不变的情况）。</li><li>中间游戏板： 独立组件，使用React生成，每一层的随机设置使用Math.random()函数，层与层的转换借助floor state。</li><li>上方阴影遮挡： 独立组件，使用React生成，代码类似中间游戏板，去掉了随机布置的部分。透明部分使用jQuery和css完成定位和透明度转换。  </li></ul><h4 id="遇到的问题和解决办法"><a href="#遇到的问题和解决办法" class="headerlink" title="遇到的问题和解决办法"></a>遇到的问题和解决办法</h4><ol><li>第一个问题是在<table>标签中使用onKeyDown事件，搜索发现，有两种解决办法。第一种是，在table类的标签中增加<strong>tabindex=”0”</strong>属性，用来解决table类的节点不能focused的问题，但失败了，其没有找到原因，猜测和作用域有关系；第二种办法是，在componentDidMount中设置事件监听函数，进行窗口监听，获取onKeyDown事件，成功，监听代码见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key" target="_blank" rel="noopener">MozillaMDN</a>。  </table></li><li><p>在外部函数中改变组件的state，来re-render。解决办法是利用全局变量floor和新建一个变量var self = this;来消除作用域的隔绝。  </p><pre><code>floor = 1;//全局变量  var self = this;//用self变量消除作用域隔绝问题move (id, nav, self)//将self作为函数参数传入外部move函数  floor++;self.setState({floor: floor});//在move中改变组件的state</code></pre></li><li>地图死角问题。使用外部函数fix来解决，开始想在地图生成组件的最后来解决，但是发现捕捉到的节点全是未定义，由于React在加载前构建的全都是空节点，所以没办法使用这种方法，所以在componentDidMount、componentDidUpdate中调用fix函数通过jQuery来对地图调整。</li><li>左侧状态栏、中间游戏板、右侧解释栏以及上方阴影遮挡的布局问题。最后使用绝对位置和相对位置成功解决。<strong>基础就是这么的重要啊！！！</strong></li><li>上方阴影遮挡空白处随方向键移动问题。通过外部函数eye（），利用jQuery和css解决，使用了jQuery中我不太常用的.filter（）函数。另外，在实现这个功能的过程中，开始fighter从一层进入下一层时，上一层的空白可见区域会遗留而不跟随新的fighter位置变化。开始以为这个问题是因为阴影遮挡组件没有状态改变，所以不会重新加载的原因，但是通过获取fighter的更新位置，发现在地图生成组件和componentDidUpdate中获取的位置是一致的，而且只使用了jQuery和css实现，应该不是React的render问题。最后发现是在事件监听部分，先把fighter的id获取传给了一个变量，再将这个变量传给位于move（）后面的eye（）函数。move（）函数中已经变化了层数，更新了fighter的位置，但是传入的id是上一层的door的位置，所以此处不借助中间变量，直接使用<code>$(&quot;.red&quot;).attr(&quot;id&quot;)</code>获取最新的位置，解决了这个问题。  </li></ol><h4 id="遗留的问题"><a href="#遗留的问题" class="headerlink" title="遗留的问题"></a>遗留的问题</h4><ol><li>地图生成使用了最简单的随机生成，生成复杂的规整地图有些乏力；</li><li>目前没有实现固定小窗口，在小窗口内移动变换空间的功能，猜测使用了overflow属性，但查看资料overflow只对block元素有效，table类元素调整起来貌似有些困难。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegExp</title>
      <link href="/2017/06/13/Regular%20Express/"/>
      <url>/2017/06/13/Regular%20Express/</url>
      
        <content type="html"><![CDATA[<h3 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">Mozilla MDN</a>：详细的RegExp说明和使用</li><li><a href="http://regexr.com/" target="_blank" rel="noopener">在线神器</a>：方便的在线测试和快速构造</li><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499503920bb7b42ff6627420da2ceae4babf6c4f2000" target="_blank" rel="noopener">廖大角虫教程</a>：应用和主要函数一览无余  </li></ol><a id="more"></a><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h3><ol><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec" target="_blank" rel="noopener">exec()函数</a><br><strong>不要把正则表达式字面量（或者正则表达式构造器）放在 while 条件表达式里。由于每次迭代时 lastIndex 的属性都被重置，如果匹配，将会造成一个死循环。</strong></p><pre><code>var myRe = /ab*/g;var str = &apos;abbcdefabh&apos;;var myArray;while ((myArray = myRe.exec(str)) !== null) {  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;  msg += &apos;Next match starts at &apos; + myRe.lastIndex;  console.log(msg);}//Found abb. Next match starts at 3//Found ab. Next match starts at 9</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对使用jsonp进行跨域获取数据的三个项目的总结</title>
      <link href="/2017/06/13/using%20api/"/>
      <url>/2017/06/13/using%20api/</url>
      
        <content type="html"><![CDATA[<p>这篇是对使用API搜集需要的数据并传回到app中的总结。涉及三个应用：<a href="https://codepen.io/ginnko/full/WjgbMM/" target="_blank" rel="noopener">random quote</a>、<a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">local weather</a>以及<a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">wikipedia viewer</a>。实质是利用jsonp进行跨域请求。</p><a id="more"></a><h2 id="1-jsonp的介绍和使用"><a href="#1-jsonp的介绍和使用" class="headerlink" title="1. jsonp的介绍和使用"></a>1. jsonp的介绍和使用</h2><p><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">这篇文章</a>是我目前见过的对jsonp最清晰和简单的描述，感谢这位大神！</p><h2 id="2-random-quote"><a href="#2-random-quote" class="headerlink" title="2. random quote"></a>2. <a href="https://codepen.io/ginnko/full/WjgbMM/" target="_blank" rel="noopener">random quote</a></h2><p>第一次接触api的应用，由于今年6月codepen开始全面使用https协议，所以原本使用http的api已经无法正常显示，目前没有找到好的解决办法。<br>使用的api地址如下：</p><blockquote><p><a href="http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=" target="_blank" rel="noopener">http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=</a>?</p></blockquote><p><strong>endpoint：</strong> <a href="http://api.forismatic.com/api/1.0/" target="_blank" rel="noopener">http://api.forismatic.com/api/1.0/</a><br><strong>?：</strong> 端点和参数的分割<br><strong>=：</strong> 匹配参数和参数值<br><strong>&amp;：</strong> 连接两个不同的参数<br><strong>jsonp=？：</strong> jsonp是callback，即获得回调函数名的参数名，等号后面可以写回调函数名，写？则会由jQuery自动处理。</p><p>一个简单的实践：  </p><pre><code>function randomQuote() {    var url = &quot;http://api.forismatic.com/api/1.0/?method=getQuote&amp;format=jsonp&amp;lang=en&amp;jsonp=?&quot;;    $.getJSON(url, function(json) {      $(&quot;#quote&quot;).text(json.quoteText);      $(&quot;#author&quot;).text(&quot;--&quot; + json.quoteAuthor);    });}</code></pre><p>返回的数据依照相应的参数名进行调用即可。  </p><h2 id="3-local-weather"><a href="#3-local-weather" class="headerlink" title="3. local weather"></a>3. <a href="https://codepen.io/ginnko/full/mmzqVj/" target="_blank" rel="noopener">local weather</a></h2><p>这个应用使用了两个api。<br>获取天气数据使用了darksky的api：  </p><blockquote><p>“<a href="https://api.darksky.net/forecast/37afbe1af1965b09f5c7e0c6f710fc34/&quot;" target="_blank" rel="noopener">https://api.darksky.net/forecast/37afbe1af1965b09f5c7e0c6f710fc34/&quot;</a> + latitude + “,” + longitude + “/?units=auto&amp;callback=?”  </p></blockquote><p>获取位置数据使用了google map的api：</p><blockquote><p>google_map_url = “<a href="https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;" target="_blank" rel="noopener">https://maps.googleapis.com/maps/api/geocode/json?latlng=&quot;</a> + latitude + “,” + longitude + “&amp;key=xxxxxxx&amp;language=en”</p></blockquote><p>其中的latitude和longitude是使用<strong>navigator.geolocation.getCurrentPosition()</strong>获取的，详细文档点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocation" target="_blank" rel="noopener">此处</a>，简单的使用方法如下：</p><pre><code>navigator.geolocation.getCurrentPosition(function(position) {    var latitude;    var longitude;    latitude = position.coords.latitude;     longitude = position.coords.longitude;     //其他函数}</code></pre><h2 id="4-wikipedia-viewer"><a href="#4-wikipedia-viewer" class="headerlink" title="4. wikipedia viewer"></a>4. <a href="https://codepen.io/ginnko/full/Omadzj/" target="_blank" rel="noopener">wikipedia viewer</a></h2><p>Wikipedia的api使用起来感觉相当复杂，点击此处的<a href="https://www.mediawiki.org/wiki/API:Main_page" target="_blank" rel="noopener">使用文档</a>。下面是应用中对地址的具体表示：  </p><blockquote><p>var url = “<a href="https://en.wikipedia.org/w/api.php?action=query&amp;list=search&amp;format=json&amp;prop=extracts&amp;utf8=&amp;srlimit=10&amp;srsearch=&quot;" target="_blank" rel="noopener">https://en.wikipedia.org/w/api.php?action=query&amp;list=search&amp;format=json&amp;prop=extracts&amp;utf8=&amp;srlimit=10&amp;srsearch=&quot;</a>; </p></blockquote><p>var val = $(“#search”).val() + “&amp;callback=?”;  </p><blockquote></blockquote><p>url += val;</p><h2 id="5-实际跨域调用"><a href="#5-实际跨域调用" class="headerlink" title="5. 实际跨域调用"></a>5. 实际跨域调用</h2><p>使用jQuery的getJson函数。</p><blockquote><p>$.getJSON(google_map_url, function(json){//});</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个小项目总结</title>
      <link href="/2017/06/12/sumary%20about%20some%20projects/"/>
      <url>/2017/06/12/sumary%20about%20some%20projects/</url>
      
        <content type="html"><![CDATA[<h2 id="Tic-Tac-Toe游戏"><a href="#Tic-Tac-Toe游戏" class="headerlink" title="Tic Tac Toe游戏"></a><a href="https://codepen.io/ginnko/full/dRPXGv/" target="_blank" rel="noopener">Tic Tac Toe游戏</a></h2><h3 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h3><p>在计算器、番茄闹钟和这个项目中，都遇到了在for循环中用var定义一个循环变量后，即便出了for循环的范围依然可以使用的情况，现在返回头，从廖大角虫的<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344993159773a464f34e1724700a6d5dd9e235ceb7c000" target="_blank" rel="noopener">教程</a>里再明确一下变量作用域。</p><a id="more"></a><ul><li>今后在第一行都写上’use strict’，强制要求通过var申明变量。</li><li>若两个不同的函数各自中声明了相同名字的变量，该变量只在各自的函数体内起作用。</li><li><p>JavaScript的变量作用域是函数内部，<strong>在for循环等语句块中无法定义具有局部作用域的变量</strong>。比如： </p><pre><code>function foo() {    for(var i=0; i&lt;100; i++){    //    }    i += 100; //在for循环外仍然可以使用i！！！}在语句块中使用let声明局部变量：function foo() {    for(let i=0; i&lt;100; i++){    //    }    i += 100; //在for循环外仍然可以使用i！！！}</code></pre></li><li><p>名字空间：</p><pre><code>//唯一的全局变量var MYAPP = {};//其他变量MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;//其它函数MYAPP.foo = function(){    return &quot;foo&quot;;};</code></pre></li></ul><h3 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2. 布尔值"></a>2. 布尔值</h3><p>false不能用具体某个数字表示：-1 ！== false</p><h3 id="3-遇到的具体问题"><a href="#3-遇到的具体问题" class="headerlink" title="3. 遇到的具体问题"></a>3. 遇到的具体问题</h3><ul><li>Tag div 没有disable这个属性</li><li><p>当使用jQuery时，开关click事件可以使用on， off函数，需要一个callback函数。当依次执行关闭、自动开启、手动开启操作时，为避免多次开启，采用下面的方法。<a href="https://codepen.io/ginnko/pen/dRPXGv" target="_blank" rel="noopener">实例</a>：place函数、another函数以及reset函数。</p><pre><code>$(&quot;.pit&quot;).off(&quot;click&quot;);//prevent from being disturbed by the same execution in another function $(&quot;.pit&quot;).on(&quot;click&quot;, place);</code></pre></li><li><p>数组的push（）函数，如果参数是一个数组，那么结果将是一个二维数组，如果改动这个二维数组中的元素，则原来那个作为参数传入的数组中的相应元素也会被改动，push（）函数执行的是浅复制操作。</p></li></ul><h2 id="番茄时钟"><a href="#番茄时钟" class="headerlink" title="番茄时钟"></a><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">番茄时钟</a></h2><h3 id="1-关于延时函数"><a href="#1-关于延时函数" class="headerlink" title="1. 关于延时函数"></a>1. 关于延时函数</h3><p>这个项目里主要用了setInterval()和clearInterval()两个函数，必须成对出现，可<strong>反复延迟执行</strong>传入setInterval的函数直到遇到清除函数。把setInterval()的返回值赋给某个变量，入下列中的id作为唯一标识，并使用id传入clearInterval()停止循环过程。以下代码出自此项目</p><pre><code>function countSession(){if(timeSession &lt; 0){  st = 1;  clearInterval(id);//停止循环过程，但此清除函数不是针对下面的SetInterval()函数，详见项目中的代码  set();  optimize(timeRelax);  timeRelax--;  i++;  id = setInterval(countRelax, 1000);//每延迟一秒执行一次countRelax函数  $(&quot;circle&quot;).attr(&quot;fill&quot;, &quot;#00FF00&quot;);  $(&quot;#progress&quot;).text(&quot;break&quot;);  flag = true; }else{var arr = calculate(timeSession);$(&quot;#show&quot;).text(arr[0] + &quot;:&quot; + arr[1]);$(&quot;path&quot;).attr(&quot;stroke-dasharray&quot;, &quot;&quot; + i*stepSession + &quot;,&quot; + (251.2-i*stepSession));timeSession--;i++;st = 0;flag = true;}</code></pre><p>}</p><h3 id="2-关于svg标签"><a href="#2-关于svg标签" class="headerlink" title="2. 关于svg标签"></a>2. 关于svg标签</h3><p>svg标签的使用点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths" target="_blank" rel="noopener">此处</a>以下代码中，circle标签用来表示大圆，path标签用来表示随着时间变化的外环，text标签用来表示圆内的说明。这个项目参考了<a href="https://codepen.io/web-tiki/full/qEGvMN/" target="_blank" rel="noopener">web-tiki</a>的项目，感谢web-tiki大神。</p><pre><code>&lt;svg role=&quot;button&quot; id=&quot;svg&quot; viewbox=&quot;0 0 100 100&quot;&gt;    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;45&quot; fill=&quot;#FF4500&quot;/&gt;    &lt;path fill=&quot;none&quot; stroke-linecap=&quot;round&quot; stroke-width=&quot;5&quot; stroke=&quot;#fff&quot; stroke-dasharray=&quot;0 251.2&quot;      d=&quot;M50 10         a 40 40 0 0 1 0 80         a 40 40 0 0 1 0 -80&quot;/&gt;    &lt;text id=&quot;show&quot; x=&quot;50&quot; y=&quot;50&quot; text-anchor=&quot;middle&quot; dy=&quot;7&quot; font-size=&quot;15&quot;&gt;START&lt;/text&gt;    &lt;text id=&quot;progress&quot; x=&quot;50&quot; y=&quot;75&quot; text-anchor=&quot;middle&quot; font-size=&quot;10&quot;&gt;&lt;/text&gt;&lt;/svg&gt;</code></pre><h3 id="3-role属性"><a href="#3-role属性" class="headerlink" title="3. role属性"></a>3. role属性</h3><p>role属性位于某个标签内，当拥有某个属性值后会使所在标签具有属性值得某些功能。比如上述代码中的svg标签，role=”button”是的svg标签拥有了click事件。</p><h2 id="JavaScrip计算器"><a href="#JavaScrip计算器" class="headerlink" title="JavaScrip计算器"></a><a href="https://codepen.io/ginnko/full/EXxXJw/" target="_blank" rel="noopener">JavaScrip计算器</a></h2><h3 id="1-RegExp"><a href="#1-RegExp" class="headerlink" title="1. RegExp"></a>1. RegExp</h3><p>这个项目中使用了RegExp的exec()函数，详见这篇<a href>总结</a>。</p><h3 id="2-this-amp-this"><a href="#2-this-amp-this" class="headerlink" title="2. this &amp; $(this)"></a>2. this &amp; $(this)</h3><p>this:表示一个html元素， this.title<br>$(this):表示一个jQuery对象， $(this).attr(“title”)</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
            <tag> variable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax和Promise的简单理解</title>
      <link href="/2017/04/27/JavaScript-summary-of-JSON-Ajax-promise/"/>
      <url>/2017/04/27/JavaScript-summary-of-JSON-Ajax-promise/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Ajax"><a href="#1-Ajax" class="headerlink" title="1. Ajax"></a>1. Ajax</h3><p>Ajax技术能够向服务器请求额外的数据而无需卸载页面，会带来更好的用户体验。</p><a id="more"></a><pre><code>function success(text) {var textarea = document.getElementById(&apos;test-response-text&apos;);textarea.value = text;}function fail(code) {    var textarea = document.getElementById(&apos;test-response-text&apos;);    textarea.value = &apos;Error code: &apos; + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调    if (request.readyState === 4) { // 成功完成        // 判断响应结果:        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}// 发送请求:request.open(&apos;GET&apos;, &apos;/api/categories&apos;);request.send();alert(&apos;请求已发送，请等待响应...&apos;);</code></pre><p>上述代码引自网络<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000" target="_blank" rel="noopener">点击这里</a>  </p><p>Ajax技术基于对象XMLHttpRequest，依赖于4个属性：onreadystatechange、readyState、status、responseText以及2个方法：open()、send()。</p><ul><li><p>open()方法<br>open()方法接受三个参数，如上述代码，<strong>第二个参数只能向同一个域发送请求</strong>。第三个表示是否异步发送请求的布尔值。open()方法启动一个请求准备发送。</p></li><li><p>send()方法<br>send()方法被调用后，请求会被发送至服务器。</p></li><li><p>readyState属性</p></li></ul><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">状态</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">未初始化</td><td style="text-align:center">尚未调用open()方法</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">启动</td><td style="text-align:center">已经调用open()方法，但尚未调用send()方法</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">发送</td><td style="text-align:center">已经调用send()方法，但尚未接收到相应</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">接收</td><td style="text-align:center">已经接收到部分相应数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">完成</td><td style="text-align:center">已经接收到全部响应数据，而且已经可以再客户端使用了</td></tr></tbody></table><ul><li><p>onreadystatechange属性<br>只要readyState属性的值由一个值变成另一个值，都会触发一次onreadystatechange事件，执行回调函数。</p></li><li><p>status属性<br>该属性表示响应的HTTP状态。收到响应后，检查status属性，将HTTP状态代码为200作为成功的标志。</p></li><li><p>responseText属性<br>被返回的文本包含在这个属性里</p></li></ul><p><strong>发送的异步请求能让JavaScript继续执行而不必等待相应。</strong> </p><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p><strong>Promise最大的好处是在异步执行的过程中，把执行代码和处理结果的代码清晰的分离了。</strong></p><pre><code>function test(resolve, reject) {    var timeOut = Math.random() * 2;    log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);    setTimeout(function () {        if (timeOut &lt; 1) {            log(&apos;call resolve()...&apos;);            resolve(&apos;200 OK&apos;);        }        else {            log(&apos;call reject()...&apos;);            reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);        }    }, timeOut * 1000);}new Promise(test).then(function (result) {    console.log(&apos;成功：&apos; + result);}).catch(function (reason) {    console.log(&apos;失败：&apos; + reason);});</code></pre><p>上述代码引自网络<a href="www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000">点击这里</a></p><ul><li><p>test函数相当于定义了一个异步执行的操作，函数内清楚的表明了异步操作成功的结果处理和异步操作失败的结果处理。</p></li><li><p>test函数接收了两个参数，两个参数都是函数，在test中并未给出具体定义。</p></li><li><p>new Promise(test)定义了一个Promise对象，并把一个名为test的异步操作任务传递给了这个Promise对象。</p></li><li><p>Promise对象可以使用两个方法then()和catch()，当调用then()方法时，才真正发出异步请求。then()中定义的函数才是resolve实际代表的函数，当异步操作成功<br>执行其中的函数，并返回一个Promise对象；当异步操作失败，执行catch()中定义的函数，这个函数是reject的实际定义，并返回一个Promise对象。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Ajax </tag>
            
            <tag> Promise </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常用对数组和字符串的操作方法</title>
      <link href="/2017/04/17/JavaScript-string&amp;array-function/"/>
      <url>/2017/04/17/JavaScript-string&amp;array-function/</url>
      
        <content type="html"><![CDATA[<h3 id="对字符串的操作方法"><a href="#对字符串的操作方法" class="headerlink" title="对字符串的操作方法"></a>对字符串的操作方法</h3><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">toUpperCase()</td><td style="text-align:center">把一个字符串全部变为大写并返回一个新的字符串</td><td style="text-align:center">str.toUpperCase();</td></tr><tr><td style="text-align:center">toLowerCase()</td><td style="text-align:center">把一个字符串全部变为小写并返回一个新的字符串</td><td style="text-align:center">str.toLowerCase();</td></tr><tr><td style="text-align:center">indexOf()</td><td style="text-align:center">搜索并返回指定字符串出现的位置</td><td style="text-align:center">str.index(‘Hello’);</td></tr><tr><td style="text-align:center">substring()</td><td style="text-align:center">返回指定索引区间的字符串</td><td style="text-align:center">str.substring(0, 2);</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">返回字符串的长度</td><td style="text-align:center">str.length;</td></tr></tbody></table><a id="more"></a><h3 id="对数组的操作方法"><a href="#对数组的操作方法" class="headerlink" title="对数组的操作方法"></a>对数组的操作方法</h3><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">作用</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">length</td><td style="text-align:center">返回数组的长度</td><td style="text-align:center">arr.length</td></tr><tr><td style="text-align:center">indexOf()</td><td style="text-align:center">搜索并返回指定元素的位置</td><td style="text-align:center">arr.indexOf(30)</td></tr><tr><td style="text-align:center">slice()</td><td style="text-align:center">截取数组的一部分并返回新的数组,参数为空时可以复制一个数组</td><td style="text-align:center">arr.slice(0, 2);</td></tr><tr><td style="text-align:center">push()</td><td style="text-align:center">向数组末尾添加元素，返回新数组长度</td><td style="text-align:center">arr.push(1, 2);</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">删除数组末尾最后一个元素，返回删除的元素</td><td style="text-align:center">arr.pop();</td></tr><tr><td style="text-align:center">unshift()</td><td style="text-align:center">向数组头部添加原素，返回新数组的长度</td><td style="text-align:center">arr.unshift(1, 2);</td></tr><tr><td style="text-align:center">shift()</td><td style="text-align:center">删除数组第一个元素，并返回被删除的元素</td><td style="text-align:center">arr.shift();</td></tr><tr><td style="text-align:center">sort()</td><td style="text-align:center">对数组进行排序，改变数组本身</td><td style="text-align:center">arr.sort();</td></tr><tr><td style="text-align:center">reverse()</td><td style="text-align:center">反转数组元素的顺序，改变数组本身</td><td style="text-align:center">arr.reverse();</td></tr><tr><td style="text-align:center">splice()</td><td style="text-align:center">指定位置删除若干元素并添加若干元素(位置，删除元素个数，添加的元素)</td><td style="text-align:center">arr.splice(2, 0, ‘Google’);</td></tr><tr><td style="text-align:center">concat()</td><td style="text-align:center">连接两个数组，并返回链接后的数组</td><td style="text-align:center">arr1.concat(arr2);</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">用指定字符串连接一个数组中的元素，并返回连接后的数组</td><td style="text-align:center">arr.join(‘-‘);</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2017/04/16/basic-markdown-syntax/"/>
      <url>/2017/04/16/basic-markdown-syntax/</url>
      
        <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>  有几个#，就是几级标题，上面使用的是3级标题。</p><h3 id="2-斜体和加粗"><a href="#2-斜体和加粗" class="headerlink" title="2. 斜体和加粗"></a>2. 斜体和加粗</h3><p>  斜体用一个*包裹：<em>我是斜体</em></p><p>  加粗用两个**包裹：<strong>我是粗体</strong></p><a id="more"></a><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h3><p>  有序列表：1.+空格+内容</p><ol><li><p>我是有序列表</p><p>无序列表：-+空格+内容</p></li></ol><ul><li>我是无序列表</li></ul><h3 id="4-插入图片"><a href="#4-插入图片" class="headerlink" title="4. 插入图片"></a>4. 插入图片</h3><p>  ！+[名称]+(地址)<br>  <img src="/images/background-cover.jpg" alt="你的名字风景"></p><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p>使用&gt;符号  </p><blockquote><p>原谅我这一生不羁放纵爱自由<br>    也会怕有一天会跌倒<br>    背弃了理想 谁人都可以<br>    哪会怕有一天只你共我<br>    仍然自由自我 永远高唱我歌<br>    ————《海阔天空》</p></blockquote><h3 id="6-引用网址"><a href="#6-引用网址" class="headerlink" title="6. 引用网址"></a>6. 引用网址</h3><p>[+名称+]+(+地址+)<br><a href="https://github.com/" target="_blank" rel="noopener">Github</a>是一个伟大的平台！</p><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7. 表格"></a>7. 表格</h3><pre><code>|CNY|HKD||:---|---:||1|1.1292|  英文冒号的位置表示文字在表格中的位置（居中、靠左、靠右）  使用表格前要在_config.yml文件中加入：  markdown: redcarpet  recarpet:      entensitons: [&quot;tables&quot;]</code></pre><blockquote><p>引自2017.4.16汇率  </p></blockquote><blockquote><table><thead><tr><th style="text-align:left">CNY</th><th style="text-align:right">HKD</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">1.1292</td></tr></tbody></table></blockquote><h3 id="7-代码区块"><a href="#7-代码区块" class="headerlink" title="7. 代码区块"></a>7. 代码区块</h3><p>每一行用4个空格开头</p><pre><code>print &quot;我是一行代码,用来输出我是一行代码&quot;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="/2017/04/14/construct-the-blog-with-jekyll/"/>
      <url>/2017/04/14/construct-the-blog-with-jekyll/</url>
      
        <content type="html"><![CDATA[<p>本想着从零开始搭建一个自己的博客，不过当下技术有限，借用大神的模板，勉强搭建起了这个博客，开始记录自己的学习过程。</p><p>昨天倒是完整的看了markdown的规则，不过这种闲聊似的记述貌似也用不上<em>手动扶额流泪</em>。</p><a id="more"></a><p>在本地这个博客已经能成功跑起来了，不过也是费了九牛二虎之力，倒是对博客用得到的技术有了个大概的了解。</p><p>现在是凌晨，睡一觉后，上传到GitHub，正式上线！</p><p>是骡子是马拉出去溜溜！<em>手动扶额流泪</em></p><p>估计把微信<em>扶额流泪</em>的表情添加进来是无望了。<em>手动扶额流泪</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
